import {
  __commonJS,
  __require
} from "./chunk-TDUMLE5V.js";

// node_modules/aframe/dist/aframe-master.js
var require_aframe_master = __commonJS({
  "node_modules/aframe/dist/aframe-master.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.AFRAME = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function e2(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e3) {
              var n2 = t[o2][1][e3];
              return s(n2 ? n2 : e3);
            }, l, l.exports, e2, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module3, exports3) {
        "use strict";
        module3.exports = {
          // Create a <link> tag with optional data attributes
          createLink: function(href, attributes) {
            var head = document.head || document.getElementsByTagName("head")[0];
            var link = document.createElement("link");
            link.href = href;
            link.rel = "stylesheet";
            for (var key in attributes) {
              if (!attributes.hasOwnProperty(key)) {
                continue;
              }
              var value = attributes[key];
              link.setAttribute("data-" + key, value);
            }
            head.appendChild(link);
          },
          // Create a <style> tag with optional data attributes
          createStyle: function(cssText, attributes) {
            var head = document.head || document.getElementsByTagName("head")[0], style = document.createElement("style");
            style.type = "text/css";
            for (var key in attributes) {
              if (!attributes.hasOwnProperty(key)) {
                continue;
              }
              var value = attributes[key];
              style.setAttribute("data-" + key, value);
            }
            if (style.sheet) {
              style.innerHTML = cssText;
              style.sheet.cssText = cssText;
              head.appendChild(style);
            } else if (style.styleSheet) {
              head.appendChild(style);
              style.styleSheet.cssText = cssText;
            } else {
              style.appendChild(document.createTextNode(cssText));
              head.appendChild(style);
            }
          }
        };
      }, {}], 2: [function(_dereq_, module3, exports3) {
        var process = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        (function() {
          try {
            cachedSetTimeout = setTimeout;
          } catch (e2) {
            cachedSetTimeout = function() {
              throw new Error("setTimeout is not defined");
            };
          }
          try {
            cachedClearTimeout = clearTimeout;
          } catch (e2) {
            cachedClearTimeout = function() {
              throw new Error("clearTimeout is not defined");
            };
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e2) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e3) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e2) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e3) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 3: [function(_dereq_, module3, exports3) {
        exports3 = module3.exports = _dereq_("./debug");
        exports3.log = log;
        exports3.formatArgs = formatArgs;
        exports3.save = save;
        exports3.load = load;
        exports3.useColors = useColors;
        exports3.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
        exports3.colors = [
          "lightseagreen",
          "forestgreen",
          "goldenrod",
          "dodgerblue",
          "darkorchid",
          "crimson"
        ];
        function useColors() {
          return "WebkitAppearance" in document.documentElement.style || // is firebug? http://stackoverflow.com/a/398120/376773
          window.console && (console.firebug || console.exception && console.table) || // is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }
        exports3.formatters.j = function(v) {
          return JSON.stringify(v);
        };
        function formatArgs() {
          var args = arguments;
          var useColors2 = this.useColors;
          args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports3.humanize(this.diff);
          if (!useColors2)
            return args;
          var c = "color: " + this.color;
          args = [args[0], c, "color: inherit"].concat(Array.prototype.slice.call(args, 1));
          var index = 0;
          var lastC = 0;
          args[0].replace(/%[a-z%]/g, function(match) {
            if ("%%" === match)
              return;
            index++;
            if ("%c" === match) {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
          return args;
        }
        function log() {
          return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        function save(namespaces) {
          try {
            if (null == namespaces) {
              exports3.storage.removeItem("debug");
            } else {
              exports3.storage.debug = namespaces;
            }
          } catch (e2) {
          }
        }
        function load() {
          var r;
          try {
            r = exports3.storage.debug;
          } catch (e2) {
          }
          return r;
        }
        exports3.enable(load());
        function localstorage() {
          try {
            return window.localStorage;
          } catch (e2) {
          }
        }
      }, { "./debug": 4 }], 4: [function(_dereq_, module3, exports3) {
        exports3 = module3.exports = debug;
        exports3.coerce = coerce;
        exports3.disable = disable;
        exports3.enable = enable;
        exports3.enabled = enabled;
        exports3.humanize = _dereq_("ms");
        exports3.names = [];
        exports3.skips = [];
        exports3.formatters = {};
        var prevColor = 0;
        var prevTime;
        function selectColor() {
          return exports3.colors[prevColor++ % exports3.colors.length];
        }
        function debug(namespace) {
          function disabled() {
          }
          disabled.enabled = false;
          function enabled2() {
            var self2 = enabled2;
            var curr = +/* @__PURE__ */ new Date();
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            if (null == self2.useColors)
              self2.useColors = exports3.useColors();
            if (null == self2.color && self2.useColors)
              self2.color = selectColor();
            var args = Array.prototype.slice.call(arguments);
            args[0] = exports3.coerce(args[0]);
            if ("string" !== typeof args[0]) {
              args = ["%o"].concat(args);
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
              if (match === "%%")
                return match;
              index++;
              var formatter = exports3.formatters[format];
              if ("function" === typeof formatter) {
                var val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            if ("function" === typeof exports3.formatArgs) {
              args = exports3.formatArgs.apply(self2, args);
            }
            var logFn = enabled2.log || exports3.log || console.log.bind(console);
            logFn.apply(self2, args);
          }
          enabled2.enabled = true;
          var fn = exports3.enabled(namespace) ? enabled2 : disabled;
          fn.namespace = namespace;
          return fn;
        }
        function enable(namespaces) {
          exports3.save(namespaces);
          var split = (namespaces || "").split(/[\s,]+/);
          var len = split.length;
          for (var i = 0; i < len; i++) {
            if (!split[i])
              continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              exports3.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              exports3.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          exports3.enable("");
        }
        function enabled(name) {
          var i, len;
          for (i = 0, len = exports3.skips.length; i < len; i++) {
            if (exports3.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = exports3.names.length; i < len; i++) {
            if (exports3.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error)
            return val.stack || val.message;
          return val;
        }
      }, { "ms": 5 }], 5: [function(_dereq_, module3, exports3) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var y = d * 365.25;
        module3.exports = function(val, options) {
          options = options || {};
          if ("string" == typeof val)
            return parse(val);
          return options.long ? long(val) : short(val);
        };
        function parse(str) {
          str = "" + str;
          if (str.length > 1e4)
            return;
          var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
          if (!match)
            return;
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
          }
        }
        function short(ms) {
          if (ms >= d)
            return Math.round(ms / d) + "d";
          if (ms >= h)
            return Math.round(ms / h) + "h";
          if (ms >= m)
            return Math.round(ms / m) + "m";
          if (ms >= s)
            return Math.round(ms / s) + "s";
          return ms + "ms";
        }
        function long(ms) {
          return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
        }
        function plural(ms, n, name) {
          if (ms < n)
            return;
          if (ms < n * 1.5)
            return Math.floor(ms / n) + " " + name;
          return Math.ceil(ms / n) + " " + name + "s";
        }
      }, {}], 6: [function(_dereq_, module3, exports3) {
        "use strict";
        var isObj = _dereq_("is-obj");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Sources cannot be null or undefined");
          }
          return Object(val);
        }
        function assignKey(to, from, key) {
          var val = from[key];
          if (val === void 0 || val === null) {
            return;
          }
          if (hasOwnProperty.call(to, key)) {
            if (to[key] === void 0 || to[key] === null) {
              throw new TypeError("Cannot convert undefined or null to object (" + key + ")");
            }
          }
          if (!hasOwnProperty.call(to, key) || !isObj(val)) {
            to[key] = val;
          } else {
            to[key] = assign(Object(to[key]), from[key]);
          }
        }
        function assign(to, from) {
          if (to === from) {
            return to;
          }
          from = Object(from);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              assignKey(to, from, key);
            }
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                assignKey(to, from, symbols[i]);
              }
            }
          }
          return to;
        }
        module3.exports = function deepAssign(target) {
          target = toObject(target);
          for (var s = 1; s < arguments.length; s++) {
            assign(target, arguments[s]);
          }
          return target;
        };
      }, { "is-obj": 7 }], 7: [function(_dereq_, module3, exports3) {
        "use strict";
        module3.exports = function(x) {
          var type = typeof x;
          return x !== null && (type === "object" || type === "function");
        };
      }, {}], 8: [function(_dereq_, module3, exports3) {
        (function(t, n, r, i) {
          "use strict";
          function st(e2, t2) {
            for (var n2 = 0, r2 = e2.length; n2 < r2; n2++)
              gt(e2[n2], t2);
          }
          function ot(e2) {
            for (var t2 = 0, n2 = e2.length, r2; t2 < n2; t2++)
              r2 = e2[t2], it(r2, w[at(r2)]);
          }
          function ut(e2) {
            return function(t2) {
              F(t2) && (gt(t2, e2), st(t2.querySelectorAll(E), e2));
            };
          }
          function at(e2) {
            var t2 = R.call(e2, "is"), n2 = e2.nodeName.toUpperCase(), r2 = x.call(b, t2 ? m + t2.toUpperCase() : v + n2);
            return t2 && -1 < r2 && !ft(n2, t2) ? -1 : r2;
          }
          function ft(e2, t2) {
            return -1 < E.indexOf(e2 + '[is="' + t2 + '"]');
          }
          function lt(e2) {
            var t2 = e2.currentTarget, n2 = e2.attrChange, r2 = e2.attrName, i2 = e2.target;
            Y && (!i2 || i2 === t2) && t2.attributeChangedCallback && r2 !== "style" && e2.prevValue !== e2.newValue && t2.attributeChangedCallback(r2, n2 === e2[f] ? null : e2.prevValue, n2 === e2[c] ? null : e2.newValue);
          }
          function ct(e2) {
            var t2 = ut(e2);
            return function(e3) {
              $.push(t2, e3.target);
            };
          }
          function ht(e2) {
            G && (G = false, e2.currentTarget.removeEventListener(p, ht)), st((e2.target || n).querySelectorAll(E), e2.detail === u ? u : o), j && vt();
          }
          function pt(e2, t2) {
            var n2 = this;
            U.call(n2, e2, t2), Z.call(n2, { target: n2 });
          }
          function dt(e2, t2) {
            P(e2, t2), nt ? nt.observe(e2, X) : (Q && (e2.setAttribute = pt, e2[s] = tt(e2), e2.addEventListener(d, Z)), e2.addEventListener(h, lt)), e2.createdCallback && Y && (e2.created = true, e2.createdCallback(), e2.created = false);
          }
          function vt() {
            for (var e2, t2 = 0, n2 = I.length; t2 < n2; t2++)
              e2 = I[t2], S.contains(e2) || (n2--, I.splice(t2--, 1), gt(e2, u));
          }
          function mt(e2) {
            throw new Error("A " + e2 + " type is already registered");
          }
          function gt(e2, t2) {
            var n2, r2 = at(e2);
            -1 < r2 && (rt(e2, w[r2]), r2 = 0, t2 === o && !e2[o] ? (e2[u] = false, e2[o] = true, r2 = 1, j && x.call(I, e2) < 0 && I.push(e2)) : t2 === u && !e2[u] && (e2[o] = false, e2[u] = true, r2 = 1), r2 && (n2 = e2[t2 + "Callback"]) && n2.call(e2));
          }
          if (i in n)
            return;
          var s = "__" + i + (Math.random() * 1e5 >> 0), o = "attached", u = "detached", a = "extends", f = "ADDITION", l = "MODIFICATION", c = "REMOVAL", h = "DOMAttrModified", p = "DOMContentLoaded", d = "DOMSubtreeModified", v = "<", m = "=", g = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/, y = ["ANNOTATION-XML", "COLOR-PROFILE", "FONT-FACE", "FONT-FACE-SRC", "FONT-FACE-URI", "FONT-FACE-FORMAT", "FONT-FACE-NAME", "MISSING-GLYPH"], b = [], w = [], E = "", S = n.documentElement, x = b.indexOf || function(e2) {
            for (var t2 = this.length; t2-- && this[t2] !== e2; )
              ;
            return t2;
          }, T = r.prototype, N = T.hasOwnProperty, C = T.isPrototypeOf, k = r.defineProperty, L = r.getOwnPropertyDescriptor, A = r.getOwnPropertyNames, O = r.getPrototypeOf, M = r.setPrototypeOf, _ = !!r.__proto__, D = r.create || function yt(e2) {
            return e2 ? (yt.prototype = e2, new yt()) : this;
          }, P = M || (_ ? function(e2, t2) {
            return e2.__proto__ = t2, e2;
          } : A && L ? /* @__PURE__ */ function() {
            function e2(e3, t2) {
              for (var n2, r2 = A(t2), i2 = 0, s2 = r2.length; i2 < s2; i2++)
                n2 = r2[i2], N.call(e3, n2) || k(e3, n2, L(t2, n2));
            }
            return function(t2, n2) {
              do
                e2(t2, n2);
              while ((n2 = O(n2)) && !C.call(n2, t2));
              return t2;
            };
          }() : function(e2, t2) {
            for (var n2 in t2)
              e2[n2] = t2[n2];
            return e2;
          }), H = t.MutationObserver || t.WebKitMutationObserver, B = (t.HTMLElement || t.Element || t.Node).prototype, j = !C.call(B, S), F = j ? function(e2) {
            return e2.nodeType === 1;
          } : function(e2) {
            return C.call(B, e2);
          }, I = j && [], q = B.cloneNode, R = B.getAttribute, U = B.setAttribute, z = B.removeAttribute, W = n.createElement, X = H && { attributes: true, characterData: true, attributeOldValue: true }, V = H || function(e2) {
            Q = false, S.removeEventListener(h, V);
          }, $, J = t.requestAnimationFrame || t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.msRequestAnimationFrame || function(e2) {
            setTimeout(e2, 10);
          }, K = false, Q = true, G = true, Y = true, Z, et, tt, nt, rt, it;
          M || _ ? (rt = function(e2, t2) {
            C.call(t2, e2) || dt(e2, t2);
          }, it = dt) : (rt = function(e2, t2) {
            e2[s] || (e2[s] = r(true), dt(e2, t2));
          }, it = rt), j ? (Q = false, function() {
            var t2 = L(B, "addEventListener"), n2 = t2.value, r2 = function(e2) {
              var t3 = new CustomEvent(h, { bubbles: true });
              t3.attrName = e2, t3.prevValue = R.call(this, e2), t3.newValue = null, t3[c] = t3.attrChange = 2, z.call(this, e2), this.dispatchEvent(t3);
            }, i2 = function(t3, n3) {
              var r3 = this.hasAttribute(t3), i3 = r3 && R.call(this, t3);
              e = new CustomEvent(h, { bubbles: true }), U.call(this, t3, n3), e.attrName = t3, e.prevValue = r3 ? i3 : null, e.newValue = n3, r3 ? e[l] = e.attrChange = 1 : e[f] = e.attrChange = 0, this.dispatchEvent(e);
            }, o2 = function(e2) {
              var t3 = e2.currentTarget, n3 = t3[s], r3 = e2.propertyName, i3;
              n3.hasOwnProperty(r3) && (n3 = n3[r3], i3 = new CustomEvent(h, { bubbles: true }), i3.attrName = n3.name, i3.prevValue = n3.value || null, i3.newValue = n3.value = t3[r3] || null, i3.prevValue == null ? i3[f] = i3.attrChange = 0 : i3[l] = i3.attrChange = 1, t3.dispatchEvent(i3));
            };
            t2.value = function(e2, t3, u2) {
              e2 === h && this.attributeChangedCallback && this.setAttribute !== i2 && (this[s] = { className: { name: "class", value: this.className } }, this.setAttribute = i2, this.removeAttribute = r2, n2.call(this, "propertychange", o2)), n2.call(this, e2, t3, u2);
            }, k(B, "addEventListener", t2);
          }()) : H || (S.addEventListener(h, V), S.setAttribute(s, 1), S.removeAttribute(s), Q && (Z = function(e2) {
            var t2 = this, n2, r2, i2;
            if (t2 === e2.target) {
              n2 = t2[s], t2[s] = r2 = tt(t2);
              for (i2 in r2) {
                if (!(i2 in n2))
                  return et(0, t2, i2, n2[i2], r2[i2], f);
                if (r2[i2] !== n2[i2])
                  return et(1, t2, i2, n2[i2], r2[i2], l);
              }
              for (i2 in n2)
                if (!(i2 in r2))
                  return et(2, t2, i2, n2[i2], r2[i2], c);
            }
          }, et = function(e2, t2, n2, r2, i2, s2) {
            var o2 = { attrChange: e2, currentTarget: t2, attrName: n2, prevValue: r2, newValue: i2 };
            o2[s2] = e2, lt(o2);
          }, tt = function(e2) {
            for (var t2, n2, r2 = {}, i2 = e2.attributes, s2 = 0, o2 = i2.length; s2 < o2; s2++)
              t2 = i2[s2], n2 = t2.name, n2 !== "setAttribute" && (r2[n2] = t2.value);
            return r2;
          })), n[i] = function(t2, r2) {
            c2 = t2.toUpperCase(), K || (K = true, H ? (nt = function(e2, t3) {
              function n2(e3, t4) {
                for (var n3 = 0, r3 = e3.length; n3 < r3; t4(e3[n3++]))
                  ;
              }
              return new H(function(r3) {
                for (var i3, s3, o2, u2 = 0, a2 = r3.length; u2 < a2; u2++)
                  i3 = r3[u2], i3.type === "childList" ? (n2(i3.addedNodes, e2), n2(i3.removedNodes, t3)) : (s3 = i3.target, Y && s3.attributeChangedCallback && i3.attributeName !== "style" && (o2 = R.call(s3, i3.attributeName), o2 !== i3.oldValue && s3.attributeChangedCallback(i3.attributeName, i3.oldValue, o2)));
              });
            }(ut(o), ut(u)), nt.observe(n, { childList: true, subtree: true })) : ($ = [], J(function d2() {
              while ($.length)
                $.shift().call(null, $.shift());
              J(d2);
            }), n.addEventListener("DOMNodeInserted", ct(o)), n.addEventListener("DOMNodeRemoved", ct(u))), n.addEventListener(p, ht), n.addEventListener("readystatechange", ht), n.createElement = function(e2, t3) {
              var r3 = W.apply(n, arguments), i3 = "" + e2, s3 = x.call(b, (t3 ? m : v) + (t3 || i3).toUpperCase()), o2 = -1 < s3;
              return t3 && (r3.setAttribute("is", t3 = t3.toLowerCase()), o2 && (o2 = ft(i3.toUpperCase(), t3))), Y = !n.createElement.innerHTMLHelper, o2 && it(r3, w[s3]), r3;
            }, B.cloneNode = function(e2) {
              var t3 = q.call(this, !!e2), n2 = at(t3);
              return -1 < n2 && it(t3, w[n2]), e2 && ot(t3.querySelectorAll(E)), t3;
            }), -2 < x.call(b, m + c2) + x.call(b, v + c2) && mt(t2);
            if (!g.test(c2) || -1 < x.call(y, c2))
              throw new Error("The type " + t2 + " is invalid");
            var i2 = function() {
              return f2 ? n.createElement(l2, c2) : n.createElement(l2);
            }, s2 = r2 || T, f2 = N.call(s2, a), l2 = f2 ? r2[a].toUpperCase() : c2, c2, h2;
            return f2 && -1 < x.call(b, v + l2) && mt(l2), h2 = b.push((f2 ? m : v) + c2) - 1, E = E.concat(E.length ? "," : "", f2 ? l2 + '[is="' + t2.toLowerCase() + '"]' : l2), i2.prototype = w[h2] = N.call(s2, "prototype") ? s2.prototype : D(B), st(n.querySelectorAll(E), o), i2;
          };
        })(window, document, Object, "registerElement");
      }, {}], 9: [function(_dereq_, module3, exports3) {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
          }
          return Object(val);
        }
        module3.exports = Object.assign || function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (Object.getOwnPropertySymbols) {
              symbols = Object.getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }
          return to;
        };
      }, {}], 10: [function(_dereq_, module3, exports3) {
        (function(global2) {
          var performance2 = global2.performance || {};
          var present = function() {
            var names = ["now", "webkitNow", "msNow", "mozNow", "oNow"];
            while (names.length) {
              var name = names.shift();
              if (name in performance2) {
                return performance2[name].bind(performance2);
              }
            }
            var dateNow = Date.now || function() {
              return (/* @__PURE__ */ new Date()).getTime();
            };
            var navigationStart = (performance2.timing || {}).navigationStart || dateNow();
            return function() {
              return dateNow() - navigationStart;
            };
          }();
          present.performanceNow = performance2.now;
          present.noConflict = function() {
            performance2.now = present.performanceNow;
          };
          present.conflict = function() {
            performance2.now = present;
          };
          present.conflict();
          module3.exports = present;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 11: [function(_dereq_, module3, exports3) {
        (function(root) {
          var setTimeoutFunc = setTimeout;
          var asap = typeof setImmediate === "function" && setImmediate || function(fn) {
            setTimeoutFunc(fn, 1);
          };
          function bind(fn, thisArg) {
            return function() {
              fn.apply(thisArg, arguments);
            };
          }
          var isArray = Array.isArray || function(value) {
            return Object.prototype.toString.call(value) === "[object Array]";
          };
          function Promise2(fn) {
            if (typeof this !== "object")
              throw new TypeError("Promises must be constructed via new");
            if (typeof fn !== "function")
              throw new TypeError("not a function");
            this._state = null;
            this._value = null;
            this._deferreds = [];
            doResolve(fn, bind(resolve, this), bind(reject, this));
          }
          function handle(deferred) {
            var me = this;
            if (this._state === null) {
              this._deferreds.push(deferred);
              return;
            }
            asap(function() {
              var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
              if (cb === null) {
                (me._state ? deferred.resolve : deferred.reject)(me._value);
                return;
              }
              var ret;
              try {
                ret = cb(me._value);
              } catch (e2) {
                deferred.reject(e2);
                return;
              }
              deferred.resolve(ret);
            });
          }
          function resolve(newValue) {
            try {
              if (newValue === this)
                throw new TypeError("A promise cannot be resolved with itself.");
              if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                var then = newValue.then;
                if (typeof then === "function") {
                  doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
                  return;
                }
              }
              this._state = true;
              this._value = newValue;
              finale.call(this);
            } catch (e2) {
              reject.call(this, e2);
            }
          }
          function reject(newValue) {
            this._state = false;
            this._value = newValue;
            finale.call(this);
          }
          function finale() {
            for (var i = 0, len = this._deferreds.length; i < len; i++) {
              handle.call(this, this._deferreds[i]);
            }
            this._deferreds = null;
          }
          function Handler(onFulfilled, onRejected, resolve2, reject2) {
            this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
            this.onRejected = typeof onRejected === "function" ? onRejected : null;
            this.resolve = resolve2;
            this.reject = reject2;
          }
          function doResolve(fn, onFulfilled, onRejected) {
            var done = false;
            try {
              fn(function(value) {
                if (done)
                  return;
                done = true;
                onFulfilled(value);
              }, function(reason) {
                if (done)
                  return;
                done = true;
                onRejected(reason);
              });
            } catch (ex) {
              if (done)
                return;
              done = true;
              onRejected(ex);
            }
          }
          Promise2.prototype["catch"] = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise2.prototype.then = function(onFulfilled, onRejected) {
            var me = this;
            return new Promise2(function(resolve2, reject2) {
              handle.call(me, new Handler(onFulfilled, onRejected, resolve2, reject2));
            });
          };
          Promise2.all = function() {
            var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
            return new Promise2(function(resolve2, reject2) {
              if (args.length === 0)
                return resolve2([]);
              var remaining = args.length;
              function res(i2, val) {
                try {
                  if (val && (typeof val === "object" || typeof val === "function")) {
                    var then = val.then;
                    if (typeof then === "function") {
                      then.call(val, function(val2) {
                        res(i2, val2);
                      }, reject2);
                      return;
                    }
                  }
                  args[i2] = val;
                  if (--remaining === 0) {
                    resolve2(args);
                  }
                } catch (ex) {
                  reject2(ex);
                }
              }
              for (var i = 0; i < args.length; i++) {
                res(i, args[i]);
              }
            });
          };
          Promise2.resolve = function(value) {
            if (value && typeof value === "object" && value.constructor === Promise2) {
              return value;
            }
            return new Promise2(function(resolve2) {
              resolve2(value);
            });
          };
          Promise2.reject = function(value) {
            return new Promise2(function(resolve2, reject2) {
              reject2(value);
            });
          };
          Promise2.race = function(values) {
            return new Promise2(function(resolve2, reject2) {
              for (var i = 0, len = values.length; i < len; i++) {
                values[i].then(resolve2, reject2);
              }
            });
          };
          Promise2._setImmediateFn = function _setImmediateFn(fn) {
            asap = fn;
          };
          if (typeof module3 !== "undefined" && module3.exports) {
            module3.exports = Promise2;
          } else if (!root.Promise) {
            root.Promise = Promise2;
          }
        })(this);
      }, {}], 12: [function(_dereq_, module3, exports3) {
        function parse(raw) {
          var trim = function(s) {
            return s.trim();
          };
          var obj = {};
          getKeyValueChunks(raw).map(trim).filter(Boolean).forEach(function(item) {
            var pos = item.indexOf(":");
            var key = item.substr(0, pos).trim();
            var val = item.substr(pos + 1).trim();
            obj[key] = val;
          });
          return obj;
        }
        function getKeyValueChunks(raw) {
          var chunks = [];
          var offset = 0;
          var sep = ";";
          var hasUnclosedUrl = /url\([^\)]+$/;
          var chunk = "";
          var nextSplit;
          while (offset < raw.length) {
            nextSplit = raw.indexOf(sep, offset);
            if (nextSplit === -1) {
              nextSplit = raw.length;
            }
            chunk += raw.substring(offset, nextSplit);
            if (hasUnclosedUrl.test(chunk)) {
              chunk += ";";
              offset = nextSplit + 1;
              continue;
            }
            chunks.push(chunk);
            chunk = "";
            offset = nextSplit + 1;
          }
          return chunks;
        }
        function stringify(obj) {
          return Object.keys(obj).map(function(key) {
            return key + ":" + obj[key];
          }).join(";");
        }
        function normalize(str) {
          return stringify(parse(str));
        }
        module3.exports.parse = parse;
        module3.exports.stringify = stringify;
        module3.exports.normalize = normalize;
      }, {}], 13: [function(_dereq_, module3, exports3) {
        (function(global2, factory) {
          typeof exports3 === "object" && typeof module3 !== "undefined" ? factory(exports3) : typeof define2 === "function" && define2.amd ? define2(["exports"], factory) : factory(global2.THREE = global2.THREE || {});
        })(this, function(exports4) {
          "use strict";
          if (Number.EPSILON === void 0) {
            Number.EPSILON = Math.pow(2, -52);
          }
          if (Math.sign === void 0) {
            Math.sign = function(x) {
              return x < 0 ? -1 : x > 0 ? 1 : +x;
            };
          }
          if (Function.prototype.name === void 0) {
            Object.defineProperty(Function.prototype, "name", {
              get: function() {
                return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
              }
            });
          }
          if (Object.assign === void 0) {
            (function() {
              Object.assign = function(target) {
                "use strict";
                if (target === void 0 || target === null) {
                  throw new TypeError("Cannot convert undefined or null to object");
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                  var source = arguments[index];
                  if (source !== void 0 && source !== null) {
                    for (var nextKey in source) {
                      if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                        output[nextKey] = source[nextKey];
                      }
                    }
                  }
                }
                return output;
              };
            })();
          }
          function EventDispatcher() {
          }
          Object.assign(EventDispatcher.prototype, {
            addEventListener: function(type, listener) {
              if (this._listeners === void 0)
                this._listeners = {};
              var listeners = this._listeners;
              if (listeners[type] === void 0) {
                listeners[type] = [];
              }
              if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
              }
            },
            hasEventListener: function(type, listener) {
              if (this._listeners === void 0)
                return false;
              var listeners = this._listeners;
              if (listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1) {
                return true;
              }
              return false;
            },
            removeEventListener: function(type, listener) {
              if (this._listeners === void 0)
                return;
              var listeners = this._listeners;
              var listenerArray = listeners[type];
              if (listenerArray !== void 0) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) {
                  listenerArray.splice(index, 1);
                }
              }
            },
            dispatchEvent: function(event) {
              if (this._listeners === void 0)
                return;
              var listeners = this._listeners;
              var listenerArray = listeners[event.type];
              if (listenerArray !== void 0) {
                event.target = this;
                var array = [], i = 0;
                var length = listenerArray.length;
                for (i = 0; i < length; i++) {
                  array[i] = listenerArray[i];
                }
                for (i = 0; i < length; i++) {
                  array[i].call(this, event);
                }
              }
            }
          });
          var REVISION = "82";
          var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
          var CullFaceNone = 0;
          var CullFaceBack = 1;
          var CullFaceFront = 2;
          var CullFaceFrontBack = 3;
          var FrontFaceDirectionCW = 0;
          var FrontFaceDirectionCCW = 1;
          var BasicShadowMap = 0;
          var PCFShadowMap = 1;
          var PCFSoftShadowMap = 2;
          var FrontSide = 0;
          var BackSide = 1;
          var DoubleSide = 2;
          var FlatShading = 1;
          var SmoothShading = 2;
          var NoColors = 0;
          var FaceColors = 1;
          var VertexColors = 2;
          var NoBlending = 0;
          var NormalBlending = 1;
          var AdditiveBlending = 2;
          var SubtractiveBlending = 3;
          var MultiplyBlending = 4;
          var CustomBlending = 5;
          var BlendingMode = {
            NoBlending,
            NormalBlending,
            AdditiveBlending,
            SubtractiveBlending,
            MultiplyBlending,
            CustomBlending
          };
          var AddEquation = 100;
          var SubtractEquation = 101;
          var ReverseSubtractEquation = 102;
          var MinEquation = 103;
          var MaxEquation = 104;
          var ZeroFactor = 200;
          var OneFactor = 201;
          var SrcColorFactor = 202;
          var OneMinusSrcColorFactor = 203;
          var SrcAlphaFactor = 204;
          var OneMinusSrcAlphaFactor = 205;
          var DstAlphaFactor = 206;
          var OneMinusDstAlphaFactor = 207;
          var DstColorFactor = 208;
          var OneMinusDstColorFactor = 209;
          var SrcAlphaSaturateFactor = 210;
          var NeverDepth = 0;
          var AlwaysDepth = 1;
          var LessDepth = 2;
          var LessEqualDepth = 3;
          var EqualDepth = 4;
          var GreaterEqualDepth = 5;
          var GreaterDepth = 6;
          var NotEqualDepth = 7;
          var MultiplyOperation = 0;
          var MixOperation = 1;
          var AddOperation = 2;
          var NoToneMapping = 0;
          var LinearToneMapping = 1;
          var ReinhardToneMapping = 2;
          var Uncharted2ToneMapping = 3;
          var CineonToneMapping = 4;
          var UVMapping = 300;
          var CubeReflectionMapping = 301;
          var CubeRefractionMapping = 302;
          var EquirectangularReflectionMapping = 303;
          var EquirectangularRefractionMapping = 304;
          var SphericalReflectionMapping = 305;
          var CubeUVReflectionMapping = 306;
          var CubeUVRefractionMapping = 307;
          var TextureMapping = {
            UVMapping,
            CubeReflectionMapping,
            CubeRefractionMapping,
            EquirectangularReflectionMapping,
            EquirectangularRefractionMapping,
            SphericalReflectionMapping,
            CubeUVReflectionMapping,
            CubeUVRefractionMapping
          };
          var RepeatWrapping = 1e3;
          var ClampToEdgeWrapping = 1001;
          var MirroredRepeatWrapping = 1002;
          var TextureWrapping = {
            RepeatWrapping,
            ClampToEdgeWrapping,
            MirroredRepeatWrapping
          };
          var NearestFilter = 1003;
          var NearestMipMapNearestFilter = 1004;
          var NearestMipMapLinearFilter = 1005;
          var LinearFilter = 1006;
          var LinearMipMapNearestFilter = 1007;
          var LinearMipMapLinearFilter = 1008;
          var TextureFilter = {
            NearestFilter,
            NearestMipMapNearestFilter,
            NearestMipMapLinearFilter,
            LinearFilter,
            LinearMipMapNearestFilter,
            LinearMipMapLinearFilter
          };
          var UnsignedByteType = 1009;
          var ByteType = 1010;
          var ShortType = 1011;
          var UnsignedShortType = 1012;
          var IntType = 1013;
          var UnsignedIntType = 1014;
          var FloatType = 1015;
          var HalfFloatType = 1016;
          var UnsignedShort4444Type = 1017;
          var UnsignedShort5551Type = 1018;
          var UnsignedShort565Type = 1019;
          var UnsignedInt248Type = 1020;
          var AlphaFormat = 1021;
          var RGBFormat = 1022;
          var RGBAFormat = 1023;
          var LuminanceFormat = 1024;
          var LuminanceAlphaFormat = 1025;
          var RGBEFormat = RGBAFormat;
          var DepthFormat = 1026;
          var DepthStencilFormat = 1027;
          var RGB_S3TC_DXT1_Format = 2001;
          var RGBA_S3TC_DXT1_Format = 2002;
          var RGBA_S3TC_DXT3_Format = 2003;
          var RGBA_S3TC_DXT5_Format = 2004;
          var RGB_PVRTC_4BPPV1_Format = 2100;
          var RGB_PVRTC_2BPPV1_Format = 2101;
          var RGBA_PVRTC_4BPPV1_Format = 2102;
          var RGBA_PVRTC_2BPPV1_Format = 2103;
          var RGB_ETC1_Format = 2151;
          var LoopOnce = 2200;
          var LoopRepeat = 2201;
          var LoopPingPong = 2202;
          var InterpolateDiscrete = 2300;
          var InterpolateLinear = 2301;
          var InterpolateSmooth = 2302;
          var ZeroCurvatureEnding = 2400;
          var ZeroSlopeEnding = 2401;
          var WrapAroundEnding = 2402;
          var TrianglesDrawMode = 0;
          var TriangleStripDrawMode = 1;
          var TriangleFanDrawMode = 2;
          var LinearEncoding = 3e3;
          var sRGBEncoding = 3001;
          var GammaEncoding = 3007;
          var RGBEEncoding = 3002;
          var LogLuvEncoding = 3003;
          var RGBM7Encoding = 3004;
          var RGBM16Encoding = 3005;
          var RGBDEncoding = 3006;
          var BasicDepthPacking = 3200;
          var RGBADepthPacking = 3201;
          var _Math = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
              var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
              var uuid = new Array(36);
              var rnd = 0, r;
              return function generateUUID() {
                for (var i = 0; i < 36; i++) {
                  if (i === 8 || i === 13 || i === 18 || i === 23) {
                    uuid[i] = "-";
                  } else if (i === 14) {
                    uuid[i] = "4";
                  } else {
                    if (rnd <= 2)
                      rnd = 33554432 + Math.random() * 16777216 | 0;
                    r = rnd & 15;
                    rnd = rnd >> 4;
                    uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
                  }
                }
                return uuid.join("");
              };
            }(),
            clamp: function(value, min, max) {
              return Math.max(min, Math.min(max, value));
            },
            // compute euclidian modulo of m % n
            // https://en.wikipedia.org/wiki/Modulo_operation
            euclideanModulo: function(n, m) {
              return (n % m + m) % m;
            },
            // Linear mapping from range <a1, a2> to range <b1, b2>
            mapLinear: function(x, a1, a2, b1, b2) {
              return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
            },
            // https://en.wikipedia.org/wiki/Linear_interpolation
            lerp: function(x, y, t) {
              return (1 - t) * x + t * y;
            },
            // http://en.wikipedia.org/wiki/Smoothstep
            smoothstep: function(x, min, max) {
              if (x <= min)
                return 0;
              if (x >= max)
                return 1;
              x = (x - min) / (max - min);
              return x * x * (3 - 2 * x);
            },
            smootherstep: function(x, min, max) {
              if (x <= min)
                return 0;
              if (x >= max)
                return 1;
              x = (x - min) / (max - min);
              return x * x * x * (x * (x * 6 - 15) + 10);
            },
            random16: function() {
              console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
              return Math.random();
            },
            // Random integer from <low, high> interval
            randInt: function(low, high) {
              return low + Math.floor(Math.random() * (high - low + 1));
            },
            // Random float from <low, high> interval
            randFloat: function(low, high) {
              return low + Math.random() * (high - low);
            },
            // Random float from <-range/2, range/2> interval
            randFloatSpread: function(range) {
              return range * (0.5 - Math.random());
            },
            degToRad: function(degrees) {
              return degrees * _Math.DEG2RAD;
            },
            radToDeg: function(radians) {
              return radians * _Math.RAD2DEG;
            },
            isPowerOfTwo: function(value) {
              return (value & value - 1) === 0 && value !== 0;
            },
            nearestPowerOfTwo: function(value) {
              return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
            },
            nextPowerOfTwo: function(value) {
              value--;
              value |= value >> 1;
              value |= value >> 2;
              value |= value >> 4;
              value |= value >> 8;
              value |= value >> 16;
              value++;
              return value;
            }
          };
          function Vector2(x, y) {
            this.x = x || 0;
            this.y = y || 0;
          }
          Vector2.prototype = {
            constructor: Vector2,
            isVector2: true,
            get width() {
              return this.x;
            },
            set width(value) {
              this.x = value;
            },
            get height() {
              return this.y;
            },
            set height(value) {
              this.y = value;
            },
            //
            set: function(x, y) {
              this.x = x;
              this.y = y;
              return this;
            },
            setScalar: function(scalar) {
              this.x = scalar;
              this.y = scalar;
              return this;
            },
            setX: function(x) {
              this.x = x;
              return this;
            },
            setY: function(y) {
              this.y = y;
              return this;
            },
            setComponent: function(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            },
            getComponent: function(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                default:
                  throw new Error("index is out of range: " + index);
              }
            },
            clone: function() {
              return new this.constructor(this.x, this.y);
            },
            copy: function(v) {
              this.x = v.x;
              this.y = v.y;
              return this;
            },
            add: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
              }
              this.x += v.x;
              this.y += v.y;
              return this;
            },
            addScalar: function(s) {
              this.x += s;
              this.y += s;
              return this;
            },
            addVectors: function(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              return this;
            },
            addScaledVector: function(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              return this;
            },
            sub: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
              }
              this.x -= v.x;
              this.y -= v.y;
              return this;
            },
            subScalar: function(s) {
              this.x -= s;
              this.y -= s;
              return this;
            },
            subVectors: function(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              return this;
            },
            multiply: function(v) {
              this.x *= v.x;
              this.y *= v.y;
              return this;
            },
            multiplyScalar: function(scalar) {
              if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
              } else {
                this.x = 0;
                this.y = 0;
              }
              return this;
            },
            divide: function(v) {
              this.x /= v.x;
              this.y /= v.y;
              return this;
            },
            divideScalar: function(scalar) {
              return this.multiplyScalar(1 / scalar);
            },
            min: function(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              return this;
            },
            max: function(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              return this;
            },
            clamp: function(min, max) {
              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              return this;
            },
            clampScalar: /* @__PURE__ */ function() {
              var min, max;
              return function clampScalar(minVal, maxVal) {
                if (min === void 0) {
                  min = new Vector2();
                  max = new Vector2();
                }
                min.set(minVal, minVal);
                max.set(maxVal, maxVal);
                return this.clamp(min, max);
              };
            }(),
            clampLength: function(min, max) {
              var length = this.length();
              return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
            },
            floor: function() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              return this;
            },
            ceil: function() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              return this;
            },
            round: function() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              return this;
            },
            roundToZero: function() {
              this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
              return this;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y;
            },
            lengthSq: function() {
              return this.x * this.x + this.y * this.y;
            },
            length: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            lengthManhattan: function() {
              return Math.abs(this.x) + Math.abs(this.y);
            },
            normalize: function() {
              return this.divideScalar(this.length());
            },
            angle: function() {
              var angle = Math.atan2(this.y, this.x);
              if (angle < 0)
                angle += 2 * Math.PI;
              return angle;
            },
            distanceTo: function(v) {
              return Math.sqrt(this.distanceToSquared(v));
            },
            distanceToSquared: function(v) {
              var dx = this.x - v.x, dy = this.y - v.y;
              return dx * dx + dy * dy;
            },
            distanceToManhattan: function(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
            },
            setLength: function(length) {
              return this.multiplyScalar(length / this.length());
            },
            lerp: function(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              return this;
            },
            lerpVectors: function(v1, v2, alpha) {
              return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            equals: function(v) {
              return v.x === this.x && v.y === this.y;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              return array;
            },
            fromAttribute: function(attribute, index, offset) {
              if (offset === void 0)
                offset = 0;
              index = index * attribute.itemSize + offset;
              this.x = attribute.array[index];
              this.y = attribute.array[index + 1];
              return this;
            },
            rotateAround: function(center, angle) {
              var c = Math.cos(angle), s = Math.sin(angle);
              var x = this.x - center.x;
              var y = this.y - center.y;
              this.x = x * c - y * s + center.x;
              this.y = x * s + y * c + center.y;
              return this;
            }
          };
          function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            Object.defineProperty(this, "id", { value: TextureIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.sourceFile = "";
            this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
            this.mipmaps = [];
            this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
            this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
            this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
            this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
            this.minFilter = minFilter !== void 0 ? minFilter : LinearMipMapLinearFilter;
            this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
            this.format = format !== void 0 ? format : RGBAFormat;
            this.type = type !== void 0 ? type : UnsignedByteType;
            this.offset = new Vector2(0, 0);
            this.repeat = new Vector2(1, 1);
            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4;
            this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
            this.version = 0;
            this.onUpdate = null;
          }
          Texture.DEFAULT_IMAGE = void 0;
          Texture.DEFAULT_MAPPING = UVMapping;
          Texture.prototype = {
            constructor: Texture,
            isTexture: true,
            set needsUpdate(value) {
              if (value === true)
                this.version++;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(source) {
              this.image = source.image;
              this.mipmaps = source.mipmaps.slice(0);
              this.mapping = source.mapping;
              this.wrapS = source.wrapS;
              this.wrapT = source.wrapT;
              this.magFilter = source.magFilter;
              this.minFilter = source.minFilter;
              this.anisotropy = source.anisotropy;
              this.format = source.format;
              this.type = source.type;
              this.offset.copy(source.offset);
              this.repeat.copy(source.repeat);
              this.generateMipmaps = source.generateMipmaps;
              this.premultiplyAlpha = source.premultiplyAlpha;
              this.flipY = source.flipY;
              this.unpackAlignment = source.unpackAlignment;
              this.encoding = source.encoding;
              return this;
            },
            toJSON: function(meta) {
              if (meta.textures[this.uuid] !== void 0) {
                return meta.textures[this.uuid];
              }
              function getDataURL(image2) {
                var canvas;
                if (image2.toDataURL !== void 0) {
                  canvas = image2;
                } else {
                  canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                  canvas.width = image2.width;
                  canvas.height = image2.height;
                  canvas.getContext("2d").drawImage(image2, 0, 0, image2.width, image2.height);
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                  return canvas.toDataURL("image/jpeg", 0.6);
                } else {
                  return canvas.toDataURL("image/png");
                }
              }
              var output = {
                metadata: {
                  version: 4.4,
                  type: "Texture",
                  generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
              };
              if (this.image !== void 0) {
                var image = this.image;
                if (image.uuid === void 0) {
                  image.uuid = _Math.generateUUID();
                }
                if (meta.images[image.uuid] === void 0) {
                  meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: getDataURL(image)
                  };
                }
                output.image = image.uuid;
              }
              meta.textures[this.uuid] = output;
              return output;
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            },
            transformUv: function(uv) {
              if (this.mapping !== UVMapping)
                return;
              uv.multiply(this.repeat);
              uv.add(this.offset);
              if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                      uv.x = Math.ceil(uv.x) - uv.x;
                    } else {
                      uv.x = uv.x - Math.floor(uv.x);
                    }
                    break;
                }
              }
              if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                      uv.y = Math.ceil(uv.y) - uv.y;
                    } else {
                      uv.y = uv.y - Math.floor(uv.y);
                    }
                    break;
                }
              }
              if (this.flipY) {
                uv.y = 1 - uv.y;
              }
            }
          };
          Object.assign(Texture.prototype, EventDispatcher.prototype);
          var count = 0;
          function TextureIdCount() {
            return count++;
          }
          function Vector4(x, y, z, w) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== void 0 ? w : 1;
          }
          Vector4.prototype = {
            constructor: Vector4,
            isVector4: true,
            set: function(x, y, z, w) {
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            },
            setScalar: function(scalar) {
              this.x = scalar;
              this.y = scalar;
              this.z = scalar;
              this.w = scalar;
              return this;
            },
            setX: function(x) {
              this.x = x;
              return this;
            },
            setY: function(y) {
              this.y = y;
              return this;
            },
            setZ: function(z) {
              this.z = z;
              return this;
            },
            setW: function(w) {
              this.w = w;
              return this;
            },
            setComponent: function(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                case 3:
                  this.w = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            },
            getComponent: function(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                case 3:
                  return this.w;
                default:
                  throw new Error("index is out of range: " + index);
              }
            },
            clone: function() {
              return new this.constructor(this.x, this.y, this.z, this.w);
            },
            copy: function(v) {
              this.x = v.x;
              this.y = v.y;
              this.z = v.z;
              this.w = v.w !== void 0 ? v.w : 1;
              return this;
            },
            add: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
              }
              this.x += v.x;
              this.y += v.y;
              this.z += v.z;
              this.w += v.w;
              return this;
            },
            addScalar: function(s) {
              this.x += s;
              this.y += s;
              this.z += s;
              this.w += s;
              return this;
            },
            addVectors: function(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              this.w = a.w + b.w;
              return this;
            },
            addScaledVector: function(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              this.z += v.z * s;
              this.w += v.w * s;
              return this;
            },
            sub: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
              }
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z;
              this.w -= v.w;
              return this;
            },
            subScalar: function(s) {
              this.x -= s;
              this.y -= s;
              this.z -= s;
              this.w -= s;
              return this;
            },
            subVectors: function(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              this.z = a.z - b.z;
              this.w = a.w - b.w;
              return this;
            },
            multiplyScalar: function(scalar) {
              if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
              } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
              }
              return this;
            },
            applyMatrix4: function(m) {
              var x = this.x, y = this.y, z = this.z, w = this.w;
              var e2 = m.elements;
              this.x = e2[0] * x + e2[4] * y + e2[8] * z + e2[12] * w;
              this.y = e2[1] * x + e2[5] * y + e2[9] * z + e2[13] * w;
              this.z = e2[2] * x + e2[6] * y + e2[10] * z + e2[14] * w;
              this.w = e2[3] * x + e2[7] * y + e2[11] * z + e2[15] * w;
              return this;
            },
            divideScalar: function(scalar) {
              return this.multiplyScalar(1 / scalar);
            },
            setAxisAngleFromQuaternion: function(q) {
              this.w = 2 * Math.acos(q.w);
              var s = Math.sqrt(1 - q.w * q.w);
              if (s < 1e-4) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
              } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
              }
              return this;
            },
            setAxisAngleFromRotationMatrix: function(m) {
              var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
              if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                  this.set(1, 0, 0, 0);
                  return this;
                }
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if (xx > yy && xx > zz) {
                  if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                  } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                  }
                } else if (yy > zz) {
                  if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                  } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                  }
                } else {
                  if (zz < epsilon) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                  } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                  }
                }
                this.set(x, y, z, angle);
                return this;
              }
              var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
              if (Math.abs(s) < 1e-3)
                s = 1;
              this.x = (m32 - m23) / s;
              this.y = (m13 - m31) / s;
              this.z = (m21 - m12) / s;
              this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
              return this;
            },
            min: function(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              this.w = Math.min(this.w, v.w);
              return this;
            },
            max: function(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              this.w = Math.max(this.w, v.w);
              return this;
            },
            clamp: function(min, max) {
              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              this.z = Math.max(min.z, Math.min(max.z, this.z));
              this.w = Math.max(min.w, Math.min(max.w, this.w));
              return this;
            },
            clampScalar: /* @__PURE__ */ function() {
              var min, max;
              return function clampScalar(minVal, maxVal) {
                if (min === void 0) {
                  min = new Vector4();
                  max = new Vector4();
                }
                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);
                return this.clamp(min, max);
              };
            }(),
            floor: function() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              this.z = Math.floor(this.z);
              this.w = Math.floor(this.w);
              return this;
            },
            ceil: function() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              this.z = Math.ceil(this.z);
              this.w = Math.ceil(this.w);
              return this;
            },
            round: function() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              this.z = Math.round(this.z);
              this.w = Math.round(this.w);
              return this;
            },
            roundToZero: function() {
              this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
              this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
              this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
              return this;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              this.w = -this.w;
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            },
            lengthSq: function() {
              return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            length: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            lengthManhattan: function() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
            },
            normalize: function() {
              return this.divideScalar(this.length());
            },
            setLength: function(length) {
              return this.multiplyScalar(length / this.length());
            },
            lerp: function(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              this.z += (v.z - this.z) * alpha;
              this.w += (v.w - this.w) * alpha;
              return this;
            },
            lerpVectors: function(v1, v2, alpha) {
              return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            equals: function(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              this.w = array[offset + 3];
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              array[offset + 2] = this.z;
              array[offset + 3] = this.w;
              return array;
            },
            fromAttribute: function(attribute, index, offset) {
              if (offset === void 0)
                offset = 0;
              index = index * attribute.itemSize + offset;
              this.x = attribute.array[index];
              this.y = attribute.array[index + 1];
              this.z = attribute.array[index + 2];
              this.w = attribute.array[index + 3];
              return this;
            }
          };
          function WebGLRenderTarget(width, height, options) {
            this.uuid = _Math.generateUUID();
            this.width = width;
            this.height = height;
            this.scissor = new Vector4(0, 0, width, height);
            this.scissorTest = false;
            this.viewport = new Vector4(0, 0, width, height);
            options = options || {};
            if (options.minFilter === void 0)
              options.minFilter = LinearFilter;
            this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
            this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
            this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
          }
          Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
            isWebGLRenderTarget: true,
            setSize: function(width, height) {
              if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
              }
              this.viewport.set(0, 0, width, height);
              this.scissor.set(0, 0, width, height);
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(source) {
              this.width = source.width;
              this.height = source.height;
              this.viewport.copy(source.viewport);
              this.texture = source.texture.clone();
              this.depthBuffer = source.depthBuffer;
              this.stencilBuffer = source.stencilBuffer;
              this.depthTexture = source.depthTexture;
              return this;
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            }
          });
          function WebGLRenderTargetCube(width, height, options) {
            WebGLRenderTarget.call(this, width, height, options);
            this.activeCubeFace = 0;
            this.activeMipMapLevel = 0;
          }
          WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
          WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
          WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
          function Quaternion(x, y, z, w) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = w !== void 0 ? w : 1;
          }
          Quaternion.prototype = {
            constructor: Quaternion,
            get x() {
              return this._x;
            },
            set x(value) {
              this._x = value;
              this.onChangeCallback();
            },
            get y() {
              return this._y;
            },
            set y(value) {
              this._y = value;
              this.onChangeCallback();
            },
            get z() {
              return this._z;
            },
            set z(value) {
              this._z = value;
              this.onChangeCallback();
            },
            get w() {
              return this._w;
            },
            set w(value) {
              this._w = value;
              this.onChangeCallback();
            },
            set: function(x, y, z, w) {
              this._x = x;
              this._y = y;
              this._z = z;
              this._w = w;
              this.onChangeCallback();
              return this;
            },
            clone: function() {
              return new this.constructor(this._x, this._y, this._z, this._w);
            },
            copy: function(quaternion) {
              this._x = quaternion.x;
              this._y = quaternion.y;
              this._z = quaternion.z;
              this._w = quaternion.w;
              this.onChangeCallback();
              return this;
            },
            setFromEuler: function(euler, update) {
              if ((euler && euler.isEuler) === false) {
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
              }
              var c1 = Math.cos(euler._x / 2);
              var c2 = Math.cos(euler._y / 2);
              var c3 = Math.cos(euler._z / 2);
              var s1 = Math.sin(euler._x / 2);
              var s2 = Math.sin(euler._y / 2);
              var s3 = Math.sin(euler._z / 2);
              var order = euler.order;
              if (order === "XYZ") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
              } else if (order === "YXZ") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
              } else if (order === "ZXY") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
              } else if (order === "ZYX") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
              } else if (order === "YZX") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
              } else if (order === "XZY") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
              }
              if (update !== false)
                this.onChangeCallback();
              return this;
            },
            setFromAxisAngle: function(axis, angle) {
              var halfAngle = angle / 2, s = Math.sin(halfAngle);
              this._x = axis.x * s;
              this._y = axis.y * s;
              this._z = axis.z * s;
              this._w = Math.cos(halfAngle);
              this.onChangeCallback();
              return this;
            },
            setFromRotationMatrix: function(m) {
              var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
              if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
              } else if (m11 > m22 && m11 > m33) {
                s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
              } else if (m22 > m33) {
                s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
              } else {
                s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
              }
              this.onChangeCallback();
              return this;
            },
            setFromUnitVectors: /* @__PURE__ */ function() {
              var v1, r;
              var EPS = 1e-6;
              return function setFromUnitVectors(vFrom, vTo) {
                if (v1 === void 0)
                  v1 = new Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                  r = 0;
                  if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    v1.set(-vFrom.y, vFrom.x, 0);
                  } else {
                    v1.set(0, -vFrom.z, vFrom.y);
                  }
                } else {
                  v1.crossVectors(vFrom, vTo);
                }
                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;
                return this.normalize();
              };
            }(),
            inverse: function() {
              return this.conjugate().normalize();
            },
            conjugate: function() {
              this._x *= -1;
              this._y *= -1;
              this._z *= -1;
              this.onChangeCallback();
              return this;
            },
            dot: function(v) {
              return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
            },
            lengthSq: function() {
              return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            },
            length: function() {
              return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
            },
            normalize: function() {
              var l = this.length();
              if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
              } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
              }
              this.onChangeCallback();
              return this;
            },
            multiply: function(q, p) {
              if (p !== void 0) {
                console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
                return this.multiplyQuaternions(q, p);
              }
              return this.multiplyQuaternions(this, q);
            },
            premultiply: function(q) {
              return this.multiplyQuaternions(q, this);
            },
            multiplyQuaternions: function(a, b) {
              var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
              var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
              this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
              this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
              this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
              this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
              this.onChangeCallback();
              return this;
            },
            slerp: function(qb, t) {
              if (t === 0)
                return this;
              if (t === 1)
                return this.copy(qb);
              var x = this._x, y = this._y, z = this._z, w = this._w;
              var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
              if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
              } else {
                this.copy(qb);
              }
              if (cosHalfTheta >= 1) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
              }
              var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
              if (Math.abs(sinHalfTheta) < 1e-3) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
              }
              var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
              var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
              this._w = w * ratioA + this._w * ratioB;
              this._x = x * ratioA + this._x * ratioB;
              this._y = y * ratioA + this._y * ratioB;
              this._z = z * ratioA + this._z * ratioB;
              this.onChangeCallback();
              return this;
            },
            equals: function(quaternion) {
              return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              this._x = array[offset];
              this._y = array[offset + 1];
              this._z = array[offset + 2];
              this._w = array[offset + 3];
              this.onChangeCallback();
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this._x;
              array[offset + 1] = this._y;
              array[offset + 2] = this._z;
              array[offset + 3] = this._w;
              return array;
            },
            onChange: function(callback) {
              this.onChangeCallback = callback;
              return this;
            },
            onChangeCallback: function() {
            }
          };
          Object.assign(Quaternion, {
            slerp: function(qa, qb, qm, t) {
              return qm.copy(qa).slerp(qb, t);
            },
            slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
              var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
              if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                  var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                  s = Math.sin(s * len) / sin;
                  t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                if (s === 1 - t) {
                  var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                  x0 *= f;
                  y0 *= f;
                  z0 *= f;
                  w0 *= f;
                }
              }
              dst[dstOffset] = x0;
              dst[dstOffset + 1] = y0;
              dst[dstOffset + 2] = z0;
              dst[dstOffset + 3] = w0;
            }
          });
          function Vector3(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
          Vector3.prototype = {
            constructor: Vector3,
            isVector3: true,
            set: function(x, y, z) {
              this.x = x;
              this.y = y;
              this.z = z;
              return this;
            },
            setScalar: function(scalar) {
              this.x = scalar;
              this.y = scalar;
              this.z = scalar;
              return this;
            },
            setX: function(x) {
              this.x = x;
              return this;
            },
            setY: function(y) {
              this.y = y;
              return this;
            },
            setZ: function(z) {
              this.z = z;
              return this;
            },
            setComponent: function(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            },
            getComponent: function(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                default:
                  throw new Error("index is out of range: " + index);
              }
            },
            clone: function() {
              return new this.constructor(this.x, this.y, this.z);
            },
            copy: function(v) {
              this.x = v.x;
              this.y = v.y;
              this.z = v.z;
              return this;
            },
            add: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
              }
              this.x += v.x;
              this.y += v.y;
              this.z += v.z;
              return this;
            },
            addScalar: function(s) {
              this.x += s;
              this.y += s;
              this.z += s;
              return this;
            },
            addVectors: function(a, b) {
              this.x = a.x + b.x;
              this.y = a.y + b.y;
              this.z = a.z + b.z;
              return this;
            },
            addScaledVector: function(v, s) {
              this.x += v.x * s;
              this.y += v.y * s;
              this.z += v.z * s;
              return this;
            },
            sub: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
              }
              this.x -= v.x;
              this.y -= v.y;
              this.z -= v.z;
              return this;
            },
            subScalar: function(s) {
              this.x -= s;
              this.y -= s;
              this.z -= s;
              return this;
            },
            subVectors: function(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              this.z = a.z - b.z;
              return this;
            },
            multiply: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
                return this.multiplyVectors(v, w);
              }
              this.x *= v.x;
              this.y *= v.y;
              this.z *= v.z;
              return this;
            },
            multiplyScalar: function(scalar) {
              if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
              } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
              }
              return this;
            },
            multiplyVectors: function(a, b) {
              this.x = a.x * b.x;
              this.y = a.y * b.y;
              this.z = a.z * b.z;
              return this;
            },
            applyEuler: /* @__PURE__ */ function() {
              var quaternion;
              return function applyEuler(euler) {
                if ((euler && euler.isEuler) === false) {
                  console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
                }
                if (quaternion === void 0)
                  quaternion = new Quaternion();
                return this.applyQuaternion(quaternion.setFromEuler(euler));
              };
            }(),
            applyAxisAngle: /* @__PURE__ */ function() {
              var quaternion;
              return function applyAxisAngle(axis, angle) {
                if (quaternion === void 0)
                  quaternion = new Quaternion();
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
              };
            }(),
            applyMatrix3: function(m) {
              var x = this.x, y = this.y, z = this.z;
              var e2 = m.elements;
              this.x = e2[0] * x + e2[3] * y + e2[6] * z;
              this.y = e2[1] * x + e2[4] * y + e2[7] * z;
              this.z = e2[2] * x + e2[5] * y + e2[8] * z;
              return this;
            },
            applyMatrix4: function(m) {
              var x = this.x, y = this.y, z = this.z;
              var e2 = m.elements;
              this.x = e2[0] * x + e2[4] * y + e2[8] * z + e2[12];
              this.y = e2[1] * x + e2[5] * y + e2[9] * z + e2[13];
              this.z = e2[2] * x + e2[6] * y + e2[10] * z + e2[14];
              return this;
            },
            applyProjection: function(m) {
              var x = this.x, y = this.y, z = this.z;
              var e2 = m.elements;
              var d = 1 / (e2[3] * x + e2[7] * y + e2[11] * z + e2[15]);
              this.x = (e2[0] * x + e2[4] * y + e2[8] * z + e2[12]) * d;
              this.y = (e2[1] * x + e2[5] * y + e2[9] * z + e2[13]) * d;
              this.z = (e2[2] * x + e2[6] * y + e2[10] * z + e2[14]) * d;
              return this;
            },
            applyQuaternion: function(q) {
              var x = this.x, y = this.y, z = this.z;
              var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            project: /* @__PURE__ */ function() {
              var matrix;
              return function project(camera) {
                if (matrix === void 0)
                  matrix = new Matrix4();
                matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                return this.applyProjection(matrix);
              };
            }(),
            unproject: /* @__PURE__ */ function() {
              var matrix;
              return function unproject(camera) {
                if (matrix === void 0)
                  matrix = new Matrix4();
                matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                return this.applyProjection(matrix);
              };
            }(),
            transformDirection: function(m) {
              var x = this.x, y = this.y, z = this.z;
              var e2 = m.elements;
              this.x = e2[0] * x + e2[4] * y + e2[8] * z;
              this.y = e2[1] * x + e2[5] * y + e2[9] * z;
              this.z = e2[2] * x + e2[6] * y + e2[10] * z;
              return this.normalize();
            },
            divide: function(v) {
              this.x /= v.x;
              this.y /= v.y;
              this.z /= v.z;
              return this;
            },
            divideScalar: function(scalar) {
              return this.multiplyScalar(1 / scalar);
            },
            min: function(v) {
              this.x = Math.min(this.x, v.x);
              this.y = Math.min(this.y, v.y);
              this.z = Math.min(this.z, v.z);
              return this;
            },
            max: function(v) {
              this.x = Math.max(this.x, v.x);
              this.y = Math.max(this.y, v.y);
              this.z = Math.max(this.z, v.z);
              return this;
            },
            clamp: function(min, max) {
              this.x = Math.max(min.x, Math.min(max.x, this.x));
              this.y = Math.max(min.y, Math.min(max.y, this.y));
              this.z = Math.max(min.z, Math.min(max.z, this.z));
              return this;
            },
            clampScalar: /* @__PURE__ */ function() {
              var min, max;
              return function clampScalar(minVal, maxVal) {
                if (min === void 0) {
                  min = new Vector3();
                  max = new Vector3();
                }
                min.set(minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal);
                return this.clamp(min, max);
              };
            }(),
            clampLength: function(min, max) {
              var length = this.length();
              return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
            },
            floor: function() {
              this.x = Math.floor(this.x);
              this.y = Math.floor(this.y);
              this.z = Math.floor(this.z);
              return this;
            },
            ceil: function() {
              this.x = Math.ceil(this.x);
              this.y = Math.ceil(this.y);
              this.z = Math.ceil(this.z);
              return this;
            },
            round: function() {
              this.x = Math.round(this.x);
              this.y = Math.round(this.y);
              this.z = Math.round(this.z);
              return this;
            },
            roundToZero: function() {
              this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
              this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
              return this;
            },
            negate: function() {
              this.x = -this.x;
              this.y = -this.y;
              this.z = -this.z;
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            },
            lengthSq: function() {
              return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            length: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            lengthManhattan: function() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            },
            normalize: function() {
              return this.divideScalar(this.length());
            },
            setLength: function(length) {
              return this.multiplyScalar(length / this.length());
            },
            lerp: function(v, alpha) {
              this.x += (v.x - this.x) * alpha;
              this.y += (v.y - this.y) * alpha;
              this.z += (v.z - this.z) * alpha;
              return this;
            },
            lerpVectors: function(v1, v2, alpha) {
              return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
            },
            cross: function(v, w) {
              if (w !== void 0) {
                console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
                return this.crossVectors(v, w);
              }
              var x = this.x, y = this.y, z = this.z;
              this.x = y * v.z - z * v.y;
              this.y = z * v.x - x * v.z;
              this.z = x * v.y - y * v.x;
              return this;
            },
            crossVectors: function(a, b) {
              var ax = a.x, ay = a.y, az = a.z;
              var bx = b.x, by = b.y, bz = b.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            },
            projectOnVector: function(vector) {
              var scalar = vector.dot(this) / vector.lengthSq();
              return this.copy(vector).multiplyScalar(scalar);
            },
            projectOnPlane: /* @__PURE__ */ function() {
              var v1;
              return function projectOnPlane(planeNormal) {
                if (v1 === void 0)
                  v1 = new Vector3();
                v1.copy(this).projectOnVector(planeNormal);
                return this.sub(v1);
              };
            }(),
            reflect: /* @__PURE__ */ function() {
              var v1;
              return function reflect(normal) {
                if (v1 === void 0)
                  v1 = new Vector3();
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
              };
            }(),
            angleTo: function(v) {
              var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
              return Math.acos(_Math.clamp(theta, -1, 1));
            },
            distanceTo: function(v) {
              return Math.sqrt(this.distanceToSquared(v));
            },
            distanceToSquared: function(v) {
              var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
              return dx * dx + dy * dy + dz * dz;
            },
            distanceToManhattan: function(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
            },
            setFromSpherical: function(s) {
              var sinPhiRadius = Math.sin(s.phi) * s.radius;
              this.x = sinPhiRadius * Math.sin(s.theta);
              this.y = Math.cos(s.phi) * s.radius;
              this.z = sinPhiRadius * Math.cos(s.theta);
              return this;
            },
            setFromMatrixPosition: function(m) {
              return this.setFromMatrixColumn(m, 3);
            },
            setFromMatrixScale: function(m) {
              var sx = this.setFromMatrixColumn(m, 0).length();
              var sy = this.setFromMatrixColumn(m, 1).length();
              var sz = this.setFromMatrixColumn(m, 2).length();
              this.x = sx;
              this.y = sy;
              this.z = sz;
              return this;
            },
            setFromMatrixColumn: function(m, index) {
              if (typeof m === "number") {
                console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                var temp = m;
                m = index;
                index = temp;
              }
              return this.fromArray(m.elements, index * 4);
            },
            equals: function(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              this.x = array[offset];
              this.y = array[offset + 1];
              this.z = array[offset + 2];
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this.x;
              array[offset + 1] = this.y;
              array[offset + 2] = this.z;
              return array;
            },
            fromAttribute: function(attribute, index, offset) {
              if (offset === void 0)
                offset = 0;
              index = index * attribute.itemSize + offset;
              this.x = attribute.array[index];
              this.y = attribute.array[index + 1];
              this.z = attribute.array[index + 2];
              return this;
            }
          };
          function Matrix4() {
            this.elements = new Float32Array([
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              1
            ]);
            if (arguments.length > 0) {
              console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
            }
          }
          Matrix4.prototype = {
            constructor: Matrix4,
            isMatrix4: true,
            set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
              var te = this.elements;
              te[0] = n11;
              te[4] = n12;
              te[8] = n13;
              te[12] = n14;
              te[1] = n21;
              te[5] = n22;
              te[9] = n23;
              te[13] = n24;
              te[2] = n31;
              te[6] = n32;
              te[10] = n33;
              te[14] = n34;
              te[3] = n41;
              te[7] = n42;
              te[11] = n43;
              te[15] = n44;
              return this;
            },
            identity: function() {
              this.set(
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            clone: function() {
              return new Matrix4().fromArray(this.elements);
            },
            copy: function(m) {
              this.elements.set(m.elements);
              return this;
            },
            copyPosition: function(m) {
              var te = this.elements;
              var me = m.elements;
              te[12] = me[12];
              te[13] = me[13];
              te[14] = me[14];
              return this;
            },
            extractBasis: function(xAxis, yAxis, zAxis) {
              xAxis.setFromMatrixColumn(this, 0);
              yAxis.setFromMatrixColumn(this, 1);
              zAxis.setFromMatrixColumn(this, 2);
              return this;
            },
            makeBasis: function(xAxis, yAxis, zAxis) {
              this.set(
                xAxis.x,
                yAxis.x,
                zAxis.x,
                0,
                xAxis.y,
                yAxis.y,
                zAxis.y,
                0,
                xAxis.z,
                yAxis.z,
                zAxis.z,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            extractRotation: /* @__PURE__ */ function() {
              var v1;
              return function extractRotation(m) {
                if (v1 === void 0)
                  v1 = new Vector3();
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                return this;
              };
            }(),
            makeRotationFromEuler: function(euler) {
              if ((euler && euler.isEuler) === false) {
                console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
              }
              var te = this.elements;
              var x = euler.x, y = euler.y, z = euler.z;
              var a = Math.cos(x), b = Math.sin(x);
              var c = Math.cos(y), d = Math.sin(y);
              var e2 = Math.cos(z), f = Math.sin(z);
              if (euler.order === "XYZ") {
                var ae = a * e2, af = a * f, be = b * e2, bf = b * f;
                te[0] = c * e2;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
              } else if (euler.order === "YXZ") {
                var ce = c * e2, cf = c * f, de = d * e2, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e2;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
              } else if (euler.order === "ZXY") {
                var ce = c * e2, cf = c * f, de = d * e2, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e2;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
              } else if (euler.order === "ZYX") {
                var ae = a * e2, af = a * f, be = b * e2, bf = b * f;
                te[0] = c * e2;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
              } else if (euler.order === "YZX") {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e2;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e2;
                te[9] = -b * e2;
                te[2] = -d * e2;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
              } else if (euler.order === "XZY") {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e2;
                te[4] = -f;
                te[8] = d * e2;
                te[1] = ac * f + bd;
                te[5] = a * e2;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e2;
                te[10] = bd * f + ac;
              }
              te[3] = 0;
              te[7] = 0;
              te[11] = 0;
              te[12] = 0;
              te[13] = 0;
              te[14] = 0;
              te[15] = 1;
              return this;
            },
            makeRotationFromQuaternion: function(q) {
              var te = this.elements;
              var x = q.x, y = q.y, z = q.z, w = q.w;
              var x2 = x + x, y2 = y + y, z2 = z + z;
              var xx = x * x2, xy = x * y2, xz = x * z2;
              var yy = y * y2, yz = y * z2, zz = z * z2;
              var wx = w * x2, wy = w * y2, wz = w * z2;
              te[0] = 1 - (yy + zz);
              te[4] = xy - wz;
              te[8] = xz + wy;
              te[1] = xy + wz;
              te[5] = 1 - (xx + zz);
              te[9] = yz - wx;
              te[2] = xz - wy;
              te[6] = yz + wx;
              te[10] = 1 - (xx + yy);
              te[3] = 0;
              te[7] = 0;
              te[11] = 0;
              te[12] = 0;
              te[13] = 0;
              te[14] = 0;
              te[15] = 1;
              return this;
            },
            lookAt: /* @__PURE__ */ function() {
              var x, y, z;
              return function lookAt(eye, target, up) {
                if (x === void 0) {
                  x = new Vector3();
                  y = new Vector3();
                  z = new Vector3();
                }
                var te = this.elements;
                z.subVectors(eye, target).normalize();
                if (z.lengthSq() === 0) {
                  z.z = 1;
                }
                x.crossVectors(up, z).normalize();
                if (x.lengthSq() === 0) {
                  z.z += 1e-4;
                  x.crossVectors(up, z).normalize();
                }
                y.crossVectors(z, x);
                te[0] = x.x;
                te[4] = y.x;
                te[8] = z.x;
                te[1] = x.y;
                te[5] = y.y;
                te[9] = z.y;
                te[2] = x.z;
                te[6] = y.z;
                te[10] = z.z;
                return this;
              };
            }(),
            multiply: function(m, n) {
              if (n !== void 0) {
                console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
                return this.multiplyMatrices(m, n);
              }
              return this.multiplyMatrices(this, m);
            },
            premultiply: function(m) {
              return this.multiplyMatrices(m, this);
            },
            multiplyMatrices: function(a, b) {
              var ae = a.elements;
              var be = b.elements;
              var te = this.elements;
              var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
              var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
              var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
              var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
              var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
              var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
              var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
              var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
              te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
              te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
              te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
              te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
              te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
              te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
              te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
              te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
              te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
              te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
              te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
              te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
              te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
              te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
              te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
              te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
              return this;
            },
            multiplyToArray: function(a, b, r) {
              var te = this.elements;
              this.multiplyMatrices(a, b);
              r[0] = te[0];
              r[1] = te[1];
              r[2] = te[2];
              r[3] = te[3];
              r[4] = te[4];
              r[5] = te[5];
              r[6] = te[6];
              r[7] = te[7];
              r[8] = te[8];
              r[9] = te[9];
              r[10] = te[10];
              r[11] = te[11];
              r[12] = te[12];
              r[13] = te[13];
              r[14] = te[14];
              r[15] = te[15];
              return this;
            },
            multiplyScalar: function(s) {
              var te = this.elements;
              te[0] *= s;
              te[4] *= s;
              te[8] *= s;
              te[12] *= s;
              te[1] *= s;
              te[5] *= s;
              te[9] *= s;
              te[13] *= s;
              te[2] *= s;
              te[6] *= s;
              te[10] *= s;
              te[14] *= s;
              te[3] *= s;
              te[7] *= s;
              te[11] *= s;
              te[15] *= s;
              return this;
            },
            applyToVector3Array: /* @__PURE__ */ function() {
              var v1;
              return function applyToVector3Array(array, offset, length) {
                if (v1 === void 0)
                  v1 = new Vector3();
                if (offset === void 0)
                  offset = 0;
                if (length === void 0)
                  length = array.length;
                for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                  v1.fromArray(array, j);
                  v1.applyMatrix4(this);
                  v1.toArray(array, j);
                }
                return array;
              };
            }(),
            applyToBuffer: /* @__PURE__ */ function() {
              var v1;
              return function applyToBuffer(buffer, offset, length) {
                if (v1 === void 0)
                  v1 = new Vector3();
                if (offset === void 0)
                  offset = 0;
                if (length === void 0)
                  length = buffer.length / buffer.itemSize;
                for (var i = 0, j = offset; i < length; i++, j++) {
                  v1.x = buffer.getX(j);
                  v1.y = buffer.getY(j);
                  v1.z = buffer.getZ(j);
                  v1.applyMatrix4(this);
                  buffer.setXYZ(j, v1.x, v1.y, v1.z);
                }
                return buffer;
              };
            }(),
            determinant: function() {
              var te = this.elements;
              var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
              var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
              var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
              var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
              return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
            },
            transpose: function() {
              var te = this.elements;
              var tmp;
              tmp = te[1];
              te[1] = te[4];
              te[4] = tmp;
              tmp = te[2];
              te[2] = te[8];
              te[8] = tmp;
              tmp = te[6];
              te[6] = te[9];
              te[9] = tmp;
              tmp = te[3];
              te[3] = te[12];
              te[12] = tmp;
              tmp = te[7];
              te[7] = te[13];
              te[13] = tmp;
              tmp = te[11];
              te[11] = te[14];
              te[14] = tmp;
              return this;
            },
            flattenToArrayOffset: function(array, offset) {
              console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");
              return this.toArray(array, offset);
            },
            getPosition: /* @__PURE__ */ function() {
              var v1;
              return function getPosition() {
                if (v1 === void 0)
                  v1 = new Vector3();
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                return v1.setFromMatrixColumn(this, 3);
              };
            }(),
            setPosition: function(v) {
              var te = this.elements;
              te[12] = v.x;
              te[13] = v.y;
              te[14] = v.z;
              return this;
            },
            getInverse: function(m, throwOnDegenerate) {
              var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
              var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
              if (det === 0) {
                var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                  throw new Error(msg);
                } else {
                  console.warn(msg);
                }
                return this.identity();
              }
              var detInv = 1 / det;
              te[0] = t11 * detInv;
              te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
              te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
              te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
              te[4] = t12 * detInv;
              te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
              te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
              te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
              te[8] = t13 * detInv;
              te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
              te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
              te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
              te[12] = t14 * detInv;
              te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
              te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
              te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
              return this;
            },
            scale: function(v) {
              var te = this.elements;
              var x = v.x, y = v.y, z = v.z;
              te[0] *= x;
              te[4] *= y;
              te[8] *= z;
              te[1] *= x;
              te[5] *= y;
              te[9] *= z;
              te[2] *= x;
              te[6] *= y;
              te[10] *= z;
              te[3] *= x;
              te[7] *= y;
              te[11] *= z;
              return this;
            },
            getMaxScaleOnAxis: function() {
              var te = this.elements;
              var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
              var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
              var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
              return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            },
            makeTranslation: function(x, y, z) {
              this.set(
                1,
                0,
                0,
                x,
                0,
                1,
                0,
                y,
                0,
                0,
                1,
                z,
                0,
                0,
                0,
                1
              );
              return this;
            },
            makeRotationX: function(theta) {
              var c = Math.cos(theta), s = Math.sin(theta);
              this.set(
                1,
                0,
                0,
                0,
                0,
                c,
                -s,
                0,
                0,
                s,
                c,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            makeRotationY: function(theta) {
              var c = Math.cos(theta), s = Math.sin(theta);
              this.set(
                c,
                0,
                s,
                0,
                0,
                1,
                0,
                0,
                -s,
                0,
                c,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            makeRotationZ: function(theta) {
              var c = Math.cos(theta), s = Math.sin(theta);
              this.set(
                c,
                -s,
                0,
                0,
                s,
                c,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            makeRotationAxis: function(axis, angle) {
              var c = Math.cos(angle);
              var s = Math.sin(angle);
              var t = 1 - c;
              var x = axis.x, y = axis.y, z = axis.z;
              var tx = t * x, ty = t * y;
              this.set(
                tx * x + c,
                tx * y - s * z,
                tx * z + s * y,
                0,
                tx * y + s * z,
                ty * y + c,
                ty * z - s * x,
                0,
                tx * z - s * y,
                ty * z + s * x,
                t * z * z + c,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            makeScale: function(x, y, z) {
              this.set(
                x,
                0,
                0,
                0,
                0,
                y,
                0,
                0,
                0,
                0,
                z,
                0,
                0,
                0,
                0,
                1
              );
              return this;
            },
            compose: function(position, quaternion, scale) {
              this.makeRotationFromQuaternion(quaternion);
              this.scale(scale);
              this.setPosition(position);
              return this;
            },
            decompose: /* @__PURE__ */ function() {
              var vector, matrix;
              return function decompose(position, quaternion, scale) {
                if (vector === void 0) {
                  vector = new Vector3();
                  matrix = new Matrix4();
                }
                var te = this.elements;
                var sx = vector.set(te[0], te[1], te[2]).length();
                var sy = vector.set(te[4], te[5], te[6]).length();
                var sz = vector.set(te[8], te[9], te[10]).length();
                var det = this.determinant();
                if (det < 0) {
                  sx = -sx;
                }
                position.x = te[12];
                position.y = te[13];
                position.z = te[14];
                matrix.elements.set(this.elements);
                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;
                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;
                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;
                quaternion.setFromRotationMatrix(matrix);
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
              };
            }(),
            makeFrustum: function(left, right, bottom, top, near, far) {
              var te = this.elements;
              var x = 2 * near / (right - left);
              var y = 2 * near / (top - bottom);
              var a = (right + left) / (right - left);
              var b = (top + bottom) / (top - bottom);
              var c = -(far + near) / (far - near);
              var d = -2 * far * near / (far - near);
              te[0] = x;
              te[4] = 0;
              te[8] = a;
              te[12] = 0;
              te[1] = 0;
              te[5] = y;
              te[9] = b;
              te[13] = 0;
              te[2] = 0;
              te[6] = 0;
              te[10] = c;
              te[14] = d;
              te[3] = 0;
              te[7] = 0;
              te[11] = -1;
              te[15] = 0;
              return this;
            },
            makePerspective: function(fov, aspect, near, far) {
              var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5);
              var ymin = -ymax;
              var xmin = ymin * aspect;
              var xmax = ymax * aspect;
              return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
            },
            makeOrthographic: function(left, right, top, bottom, near, far) {
              var te = this.elements;
              var w = 1 / (right - left);
              var h = 1 / (top - bottom);
              var p = 1 / (far - near);
              var x = (right + left) * w;
              var y = (top + bottom) * h;
              var z = (far + near) * p;
              te[0] = 2 * w;
              te[4] = 0;
              te[8] = 0;
              te[12] = -x;
              te[1] = 0;
              te[5] = 2 * h;
              te[9] = 0;
              te[13] = -y;
              te[2] = 0;
              te[6] = 0;
              te[10] = -2 * p;
              te[14] = -z;
              te[3] = 0;
              te[7] = 0;
              te[11] = 0;
              te[15] = 1;
              return this;
            },
            equals: function(matrix) {
              var te = this.elements;
              var me = matrix.elements;
              for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i])
                  return false;
              }
              return true;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
              }
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              var te = this.elements;
              array[offset] = te[0];
              array[offset + 1] = te[1];
              array[offset + 2] = te[2];
              array[offset + 3] = te[3];
              array[offset + 4] = te[4];
              array[offset + 5] = te[5];
              array[offset + 6] = te[6];
              array[offset + 7] = te[7];
              array[offset + 8] = te[8];
              array[offset + 9] = te[9];
              array[offset + 10] = te[10];
              array[offset + 11] = te[11];
              array[offset + 12] = te[12];
              array[offset + 13] = te[13];
              array[offset + 14] = te[14];
              array[offset + 15] = te[15];
              return array;
            }
          };
          function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            images = images !== void 0 ? images : [];
            mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
            Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.flipY = false;
          }
          CubeTexture.prototype = Object.create(Texture.prototype);
          CubeTexture.prototype.constructor = CubeTexture;
          CubeTexture.prototype.isCubeTexture = true;
          Object.defineProperty(CubeTexture.prototype, "images", {
            get: function() {
              return this.image;
            },
            set: function(value) {
              this.image = value;
            }
          });
          var emptyTexture = new Texture();
          var emptyCubeTexture = new CubeTexture();
          function UniformContainer() {
            this.seq = [];
            this.map = {};
          }
          var arrayCacheF32 = [];
          var arrayCacheI32 = [];
          function flatten(array, nBlocks, blockSize) {
            var firstElem = array[0];
            if (firstElem <= 0 || firstElem > 0)
              return array;
            var n = nBlocks * blockSize, r = arrayCacheF32[n];
            if (r === void 0) {
              r = new Float32Array(n);
              arrayCacheF32[n] = r;
            }
            if (nBlocks !== 0) {
              firstElem.toArray(r, 0);
              for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
              }
            }
            return r;
          }
          function allocTexUnits(renderer, n) {
            var r = arrayCacheI32[n];
            if (r === void 0) {
              r = new Int32Array(n);
              arrayCacheI32[n] = r;
            }
            for (var i = 0; i !== n; ++i)
              r[i] = renderer.allocTextureUnit();
            return r;
          }
          function setValue1f(gl, v) {
            gl.uniform1f(this.addr, v);
          }
          function setValue1i(gl, v) {
            gl.uniform1i(this.addr, v);
          }
          function setValue2fv(gl, v) {
            if (v.x === void 0)
              gl.uniform2fv(this.addr, v);
            else
              gl.uniform2f(this.addr, v.x, v.y);
          }
          function setValue3fv(gl, v) {
            if (v.x !== void 0)
              gl.uniform3f(this.addr, v.x, v.y, v.z);
            else if (v.r !== void 0)
              gl.uniform3f(this.addr, v.r, v.g, v.b);
            else
              gl.uniform3fv(this.addr, v);
          }
          function setValue4fv(gl, v) {
            if (v.x === void 0)
              gl.uniform4fv(this.addr, v);
            else
              gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
          }
          function setValue2fm(gl, v) {
            gl.uniformMatrix2fv(this.addr, false, v.elements || v);
          }
          function setValue3fm(gl, v) {
            gl.uniformMatrix3fv(this.addr, false, v.elements || v);
          }
          function setValue4fm(gl, v) {
            gl.uniformMatrix4fv(this.addr, false, v.elements || v);
          }
          function setValueT1(gl, v, renderer) {
            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTexture2D(v || emptyTexture, unit);
          }
          function setValueT6(gl, v, renderer) {
            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTextureCube(v || emptyCubeTexture, unit);
          }
          function setValue2iv(gl, v) {
            gl.uniform2iv(this.addr, v);
          }
          function setValue3iv(gl, v) {
            gl.uniform3iv(this.addr, v);
          }
          function setValue4iv(gl, v) {
            gl.uniform4iv(this.addr, v);
          }
          function getSingularSetter(type) {
            switch (type) {
              case 5126:
                return setValue1f;
              case 35664:
                return setValue2fv;
              case 35665:
                return setValue3fv;
              case 35666:
                return setValue4fv;
              case 35674:
                return setValue2fm;
              case 35675:
                return setValue3fm;
              case 35676:
                return setValue4fm;
              case 35678:
                return setValueT1;
              case 35680:
                return setValueT6;
              case 5124:
              case 35670:
                return setValue1i;
              case 35667:
              case 35671:
                return setValue2iv;
              case 35668:
              case 35672:
                return setValue3iv;
              case 35669:
              case 35673:
                return setValue4iv;
            }
          }
          function setValue1fv(gl, v) {
            gl.uniform1fv(this.addr, v);
          }
          function setValue1iv(gl, v) {
            gl.uniform1iv(this.addr, v);
          }
          function setValueV2a(gl, v) {
            gl.uniform2fv(this.addr, flatten(v, this.size, 2));
          }
          function setValueV3a(gl, v) {
            gl.uniform3fv(this.addr, flatten(v, this.size, 3));
          }
          function setValueV4a(gl, v) {
            gl.uniform4fv(this.addr, flatten(v, this.size, 4));
          }
          function setValueM2a(gl, v) {
            gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
          }
          function setValueM3a(gl, v) {
            gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
          }
          function setValueM4a(gl, v) {
            gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
          }
          function setValueT1a(gl, v, renderer) {
            var n = v.length, units = allocTexUnits(renderer, n);
            gl.uniform1iv(this.addr, units);
            for (var i = 0; i !== n; ++i) {
              renderer.setTexture2D(v[i] || emptyTexture, units[i]);
            }
          }
          function setValueT6a(gl, v, renderer) {
            var n = v.length, units = allocTexUnits(renderer, n);
            gl.uniform1iv(this.addr, units);
            for (var i = 0; i !== n; ++i) {
              renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
            }
          }
          function getPureArraySetter(type) {
            switch (type) {
              case 5126:
                return setValue1fv;
              case 35664:
                return setValueV2a;
              case 35665:
                return setValueV3a;
              case 35666:
                return setValueV4a;
              case 35674:
                return setValueM2a;
              case 35675:
                return setValueM3a;
              case 35676:
                return setValueM4a;
              case 35678:
                return setValueT1a;
              case 35680:
                return setValueT6a;
              case 5124:
              case 35670:
                return setValue1iv;
              case 35667:
              case 35671:
                return setValue2iv;
              case 35668:
              case 35672:
                return setValue3iv;
              case 35669:
              case 35673:
                return setValue4iv;
            }
          }
          function SingleUniform(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.setValue = getSingularSetter(activeInfo.type);
          }
          function PureArrayUniform(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.size = activeInfo.size;
            this.setValue = getPureArraySetter(activeInfo.type);
          }
          function StructuredUniform(id) {
            this.id = id;
            UniformContainer.call(this);
          }
          StructuredUniform.prototype.setValue = function(gl, value) {
            var seq = this.seq;
            for (var i = 0, n = seq.length; i !== n; ++i) {
              var u = seq[i];
              u.setValue(gl, value[u.id]);
            }
          };
          var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
          function addUniform(container, uniformObject) {
            container.seq.push(uniformObject);
            container.map[uniformObject.id] = uniformObject;
          }
          function parseUniform(activeInfo, addr, container) {
            var path = activeInfo.name, pathLength = path.length;
            RePathPart.lastIndex = 0;
            for (; ; ) {
              var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
              if (idIsIndex)
                id = id | 0;
              if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
                addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
              } else {
                var map = container.map, next = map[id];
                if (next === void 0) {
                  next = new StructuredUniform(id);
                  addUniform(container, next);
                }
                container = next;
              }
            }
          }
          function WebGLUniforms(gl, program, renderer) {
            UniformContainer.call(this);
            this.renderer = renderer;
            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            for (var i = 0; i !== n; ++i) {
              var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
              parseUniform(info, addr, this);
            }
          }
          WebGLUniforms.prototype.setValue = function(gl, name, value) {
            var u = this.map[name];
            if (u !== void 0)
              u.setValue(gl, value, this.renderer);
          };
          WebGLUniforms.prototype.set = function(gl, object, name) {
            var u = this.map[name];
            if (u !== void 0)
              u.setValue(gl, object[name], this.renderer);
          };
          WebGLUniforms.prototype.setOptional = function(gl, object, name) {
            var v = object[name];
            if (v !== void 0)
              this.setValue(gl, name, v);
          };
          WebGLUniforms.upload = function(gl, seq, values, renderer) {
            for (var i = 0, n = seq.length; i !== n; ++i) {
              var u = seq[i], v = values[u.id];
              if (v.needsUpdate !== false) {
                u.setValue(gl, v.value, renderer);
              }
            }
          };
          WebGLUniforms.seqWithValue = function(seq, values) {
            var r = [];
            for (var i = 0, n = seq.length; i !== n; ++i) {
              var u = seq[i];
              if (u.id in values)
                r.push(u);
            }
            return r;
          };
          var UniformsUtils = {
            merge: function(uniforms) {
              var merged = {};
              for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                  merged[p] = tmp[p];
                }
              }
              return merged;
            },
            clone: function(uniforms_src) {
              var uniforms_dst = {};
              for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                  var parameter_src = uniforms_src[u][p];
                  if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
                    uniforms_dst[u][p] = parameter_src.clone();
                  } else if (Array.isArray(parameter_src)) {
                    uniforms_dst[u][p] = parameter_src.slice();
                  } else {
                    uniforms_dst[u][p] = parameter_src;
                  }
                }
              }
              return uniforms_dst;
            }
          };
          var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
          var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
          var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
          var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";
          var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
          var begin_vertex = "\nvec3 transformed = vec3( position );\n";
          var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
          var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
          var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
          var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n		\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n			vec4 plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	\n	#endif\n#endif\n";
          var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
          var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";
          var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";
          var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
          var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
          var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
          var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
          var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
          var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";
          var defaultnormal_vertex = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
          var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
          var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
          var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
          var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
          var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
          var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
          var envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
          var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
          var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";
          var envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";
          var fog_fragment = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
          var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
          var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
          var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
          var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
          var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#include <normal_flip>\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#include <normal_flip>\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
          var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
          var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
          var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
          var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
          var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n		\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
          var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
          var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
          var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
          var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
          var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";
          var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";
          var map_particle_fragment = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
          var map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
          var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";
          var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
          var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
          var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
          var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
          var normal_flip = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n";
          var normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
          var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
          var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
          var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
          var project_vertex = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
          var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";
          var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
          var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";
          var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
          var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
          var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
          var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
          var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
          var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";
          var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
          var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
          var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
          var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
          var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
          var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
          var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
          var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
          var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
          var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
          var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
          var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";
          var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n";
          var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
          var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";
          var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
          var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
          var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";
          var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
          var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n";
          var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
          var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";
          var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";
          var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";
          var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
          var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";
          var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
          var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
          var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
          var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";
          var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
          var ShaderChunk = {
            alphamap_fragment,
            alphamap_pars_fragment,
            alphatest_fragment,
            aomap_fragment,
            aomap_pars_fragment,
            begin_vertex,
            beginnormal_vertex,
            bsdfs,
            bumpmap_pars_fragment,
            clipping_planes_fragment,
            clipping_planes_pars_fragment,
            clipping_planes_pars_vertex,
            clipping_planes_vertex,
            color_fragment,
            color_pars_fragment,
            color_pars_vertex,
            color_vertex,
            common,
            cube_uv_reflection_fragment,
            defaultnormal_vertex,
            displacementmap_pars_vertex,
            displacementmap_vertex,
            emissivemap_fragment,
            emissivemap_pars_fragment,
            encodings_fragment,
            encodings_pars_fragment,
            envmap_fragment,
            envmap_pars_fragment,
            envmap_pars_vertex,
            envmap_vertex,
            fog_fragment,
            fog_pars_fragment,
            lightmap_fragment,
            lightmap_pars_fragment,
            lights_lambert_vertex,
            lights_pars,
            lights_phong_fragment,
            lights_phong_pars_fragment,
            lights_physical_fragment,
            lights_physical_pars_fragment,
            lights_template,
            logdepthbuf_fragment,
            logdepthbuf_pars_fragment,
            logdepthbuf_pars_vertex,
            logdepthbuf_vertex,
            map_fragment,
            map_pars_fragment,
            map_particle_fragment,
            map_particle_pars_fragment,
            metalnessmap_fragment,
            metalnessmap_pars_fragment,
            morphnormal_vertex,
            morphtarget_pars_vertex,
            morphtarget_vertex,
            normal_flip,
            normal_fragment,
            normalmap_pars_fragment,
            packing,
            premultiplied_alpha_fragment,
            project_vertex,
            roughnessmap_fragment,
            roughnessmap_pars_fragment,
            shadowmap_pars_fragment,
            shadowmap_pars_vertex,
            shadowmap_vertex,
            shadowmask_pars_fragment,
            skinbase_vertex,
            skinning_pars_vertex,
            skinning_vertex,
            skinnormal_vertex,
            specularmap_fragment,
            specularmap_pars_fragment,
            tonemapping_fragment,
            tonemapping_pars_fragment,
            uv_pars_fragment,
            uv_pars_vertex,
            uv_vertex,
            uv2_pars_fragment,
            uv2_pars_vertex,
            uv2_vertex,
            worldpos_vertex,
            cube_frag,
            cube_vert,
            depth_frag,
            depth_vert,
            distanceRGBA_frag,
            distanceRGBA_vert,
            equirect_frag,
            equirect_vert,
            linedashed_frag,
            linedashed_vert,
            meshbasic_frag,
            meshbasic_vert,
            meshlambert_frag,
            meshlambert_vert,
            meshphong_frag,
            meshphong_vert,
            meshphysical_frag,
            meshphysical_vert,
            normal_frag,
            normal_vert,
            points_frag,
            points_vert,
            shadow_frag,
            shadow_vert
          };
          function Color(r, g, b) {
            if (g === void 0 && b === void 0) {
              return this.set(r);
            }
            return this.setRGB(r, g, b);
          }
          Color.prototype = {
            constructor: Color,
            isColor: true,
            r: 1,
            g: 1,
            b: 1,
            set: function(value) {
              if (value && value.isColor) {
                this.copy(value);
              } else if (typeof value === "number") {
                this.setHex(value);
              } else if (typeof value === "string") {
                this.setStyle(value);
              }
              return this;
            },
            setScalar: function(scalar) {
              this.r = scalar;
              this.g = scalar;
              this.b = scalar;
              return this;
            },
            setHex: function(hex) {
              hex = Math.floor(hex);
              this.r = (hex >> 16 & 255) / 255;
              this.g = (hex >> 8 & 255) / 255;
              this.b = (hex & 255) / 255;
              return this;
            },
            setRGB: function(r, g, b) {
              this.r = r;
              this.g = g;
              this.b = b;
              return this;
            },
            setHSL: /* @__PURE__ */ function() {
              function hue2rgb(p, q, t) {
                if (t < 0)
                  t += 1;
                if (t > 1)
                  t -= 1;
                if (t < 1 / 6)
                  return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                  return q;
                if (t < 2 / 3)
                  return p + (q - p) * 6 * (2 / 3 - t);
                return p;
              }
              return function setHSL(h, s, l) {
                h = _Math.euclideanModulo(h, 1);
                s = _Math.clamp(s, 0, 1);
                l = _Math.clamp(l, 0, 1);
                if (s === 0) {
                  this.r = this.g = this.b = l;
                } else {
                  var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                  var q = 2 * l - p;
                  this.r = hue2rgb(q, p, h + 1 / 3);
                  this.g = hue2rgb(q, p, h);
                  this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
              };
            }(),
            setStyle: function(style) {
              function handleAlpha(string) {
                if (string === void 0)
                  return;
                if (parseFloat(string) < 1) {
                  console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
                }
              }
              var m;
              if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                      this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                      this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                      this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                      handleAlpha(color[5]);
                      return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                      this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                      this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                      this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                      handleAlpha(color[5]);
                      return this;
                    }
                    break;
                  case "hsl":
                  case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                      var h = parseFloat(color[1]) / 360;
                      var s = parseInt(color[2], 10) / 100;
                      var l = parseInt(color[3], 10) / 100;
                      handleAlpha(color[5]);
                      return this.setHSL(h, s, l);
                    }
                    break;
                }
              } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                  this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                  this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                  this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                  return this;
                } else if (size === 6) {
                  this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                  this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                  this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                  return this;
                }
              }
              if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                if (hex !== void 0) {
                  this.setHex(hex);
                } else {
                  console.warn("THREE.Color: Unknown color " + style);
                }
              }
              return this;
            },
            clone: function() {
              return new this.constructor(this.r, this.g, this.b);
            },
            copy: function(color) {
              this.r = color.r;
              this.g = color.g;
              this.b = color.b;
              return this;
            },
            copyGammaToLinear: function(color, gammaFactor) {
              if (gammaFactor === void 0)
                gammaFactor = 2;
              this.r = Math.pow(color.r, gammaFactor);
              this.g = Math.pow(color.g, gammaFactor);
              this.b = Math.pow(color.b, gammaFactor);
              return this;
            },
            copyLinearToGamma: function(color, gammaFactor) {
              if (gammaFactor === void 0)
                gammaFactor = 2;
              var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
              this.r = Math.pow(color.r, safeInverse);
              this.g = Math.pow(color.g, safeInverse);
              this.b = Math.pow(color.b, safeInverse);
              return this;
            },
            convertGammaToLinear: function() {
              var r = this.r, g = this.g, b = this.b;
              this.r = r * r;
              this.g = g * g;
              this.b = b * b;
              return this;
            },
            convertLinearToGamma: function() {
              this.r = Math.sqrt(this.r);
              this.g = Math.sqrt(this.g);
              this.b = Math.sqrt(this.b);
              return this;
            },
            getHex: function() {
              return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
            },
            getHexString: function() {
              return ("000000" + this.getHex().toString(16)).slice(-6);
            },
            getHSL: function(optionalTarget) {
              var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
              var r = this.r, g = this.g, b = this.b;
              var max = Math.max(r, g, b);
              var min = Math.min(r, g, b);
              var hue, saturation;
              var lightness = (min + max) / 2;
              if (min === max) {
                hue = 0;
                saturation = 0;
              } else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                  case g:
                    hue = (b - r) / delta + 2;
                    break;
                  case b:
                    hue = (r - g) / delta + 4;
                    break;
                }
                hue /= 6;
              }
              hsl.h = hue;
              hsl.s = saturation;
              hsl.l = lightness;
              return hsl;
            },
            getStyle: function() {
              return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
            },
            offsetHSL: function(h, s, l) {
              var hsl = this.getHSL();
              hsl.h += h;
              hsl.s += s;
              hsl.l += l;
              this.setHSL(hsl.h, hsl.s, hsl.l);
              return this;
            },
            add: function(color) {
              this.r += color.r;
              this.g += color.g;
              this.b += color.b;
              return this;
            },
            addColors: function(color1, color2) {
              this.r = color1.r + color2.r;
              this.g = color1.g + color2.g;
              this.b = color1.b + color2.b;
              return this;
            },
            addScalar: function(s) {
              this.r += s;
              this.g += s;
              this.b += s;
              return this;
            },
            sub: function(color) {
              this.r = Math.max(0, this.r - color.r);
              this.g = Math.max(0, this.g - color.g);
              this.b = Math.max(0, this.b - color.b);
              return this;
            },
            multiply: function(color) {
              this.r *= color.r;
              this.g *= color.g;
              this.b *= color.b;
              return this;
            },
            multiplyScalar: function(s) {
              this.r *= s;
              this.g *= s;
              this.b *= s;
              return this;
            },
            lerp: function(color, alpha) {
              this.r += (color.r - this.r) * alpha;
              this.g += (color.g - this.g) * alpha;
              this.b += (color.b - this.b) * alpha;
              return this;
            },
            equals: function(c) {
              return c.r === this.r && c.g === this.g && c.b === this.b;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              this.r = array[offset];
              this.g = array[offset + 1];
              this.b = array[offset + 2];
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this.r;
              array[offset + 1] = this.g;
              array[offset + 2] = this.b;
              return array;
            },
            toJSON: function() {
              return this.getHex();
            }
          };
          var ColorKeywords = {
            "aliceblue": 15792383,
            "antiquewhite": 16444375,
            "aqua": 65535,
            "aquamarine": 8388564,
            "azure": 15794175,
            "beige": 16119260,
            "bisque": 16770244,
            "black": 0,
            "blanchedalmond": 16772045,
            "blue": 255,
            "blueviolet": 9055202,
            "brown": 10824234,
            "burlywood": 14596231,
            "cadetblue": 6266528,
            "chartreuse": 8388352,
            "chocolate": 13789470,
            "coral": 16744272,
            "cornflowerblue": 6591981,
            "cornsilk": 16775388,
            "crimson": 14423100,
            "cyan": 65535,
            "darkblue": 139,
            "darkcyan": 35723,
            "darkgoldenrod": 12092939,
            "darkgray": 11119017,
            "darkgreen": 25600,
            "darkgrey": 11119017,
            "darkkhaki": 12433259,
            "darkmagenta": 9109643,
            "darkolivegreen": 5597999,
            "darkorange": 16747520,
            "darkorchid": 10040012,
            "darkred": 9109504,
            "darksalmon": 15308410,
            "darkseagreen": 9419919,
            "darkslateblue": 4734347,
            "darkslategray": 3100495,
            "darkslategrey": 3100495,
            "darkturquoise": 52945,
            "darkviolet": 9699539,
            "deeppink": 16716947,
            "deepskyblue": 49151,
            "dimgray": 6908265,
            "dimgrey": 6908265,
            "dodgerblue": 2003199,
            "firebrick": 11674146,
            "floralwhite": 16775920,
            "forestgreen": 2263842,
            "fuchsia": 16711935,
            "gainsboro": 14474460,
            "ghostwhite": 16316671,
            "gold": 16766720,
            "goldenrod": 14329120,
            "gray": 8421504,
            "green": 32768,
            "greenyellow": 11403055,
            "grey": 8421504,
            "honeydew": 15794160,
            "hotpink": 16738740,
            "indianred": 13458524,
            "indigo": 4915330,
            "ivory": 16777200,
            "khaki": 15787660,
            "lavender": 15132410,
            "lavenderblush": 16773365,
            "lawngreen": 8190976,
            "lemonchiffon": 16775885,
            "lightblue": 11393254,
            "lightcoral": 15761536,
            "lightcyan": 14745599,
            "lightgoldenrodyellow": 16448210,
            "lightgray": 13882323,
            "lightgreen": 9498256,
            "lightgrey": 13882323,
            "lightpink": 16758465,
            "lightsalmon": 16752762,
            "lightseagreen": 2142890,
            "lightskyblue": 8900346,
            "lightslategray": 7833753,
            "lightslategrey": 7833753,
            "lightsteelblue": 11584734,
            "lightyellow": 16777184,
            "lime": 65280,
            "limegreen": 3329330,
            "linen": 16445670,
            "magenta": 16711935,
            "maroon": 8388608,
            "mediumaquamarine": 6737322,
            "mediumblue": 205,
            "mediumorchid": 12211667,
            "mediumpurple": 9662683,
            "mediumseagreen": 3978097,
            "mediumslateblue": 8087790,
            "mediumspringgreen": 64154,
            "mediumturquoise": 4772300,
            "mediumvioletred": 13047173,
            "midnightblue": 1644912,
            "mintcream": 16121850,
            "mistyrose": 16770273,
            "moccasin": 16770229,
            "navajowhite": 16768685,
            "navy": 128,
            "oldlace": 16643558,
            "olive": 8421376,
            "olivedrab": 7048739,
            "orange": 16753920,
            "orangered": 16729344,
            "orchid": 14315734,
            "palegoldenrod": 15657130,
            "palegreen": 10025880,
            "paleturquoise": 11529966,
            "palevioletred": 14381203,
            "papayawhip": 16773077,
            "peachpuff": 16767673,
            "peru": 13468991,
            "pink": 16761035,
            "plum": 14524637,
            "powderblue": 11591910,
            "purple": 8388736,
            "red": 16711680,
            "rosybrown": 12357519,
            "royalblue": 4286945,
            "saddlebrown": 9127187,
            "salmon": 16416882,
            "sandybrown": 16032864,
            "seagreen": 3050327,
            "seashell": 16774638,
            "sienna": 10506797,
            "silver": 12632256,
            "skyblue": 8900331,
            "slateblue": 6970061,
            "slategray": 7372944,
            "slategrey": 7372944,
            "snow": 16775930,
            "springgreen": 65407,
            "steelblue": 4620980,
            "tan": 13808780,
            "teal": 32896,
            "thistle": 14204888,
            "tomato": 16737095,
            "turquoise": 4251856,
            "violet": 15631086,
            "wheat": 16113331,
            "white": 16777215,
            "whitesmoke": 16119285,
            "yellow": 16776960,
            "yellowgreen": 10145074
          };
          var UniformsLib = {
            common: {
              diffuse: { value: new Color(15658734) },
              opacity: { value: 1 },
              map: { value: null },
              offsetRepeat: { value: new Vector4(0, 0, 1, 1) },
              specularMap: { value: null },
              alphaMap: { value: null },
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              refractionRatio: { value: 0.98 }
            },
            aomap: {
              aoMap: { value: null },
              aoMapIntensity: { value: 1 }
            },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 }
            },
            emissivemap: {
              emissiveMap: { value: null }
            },
            bumpmap: {
              bumpMap: { value: null },
              bumpScale: { value: 1 }
            },
            normalmap: {
              normalMap: { value: null },
              normalScale: { value: new Vector2(1, 1) }
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 }
            },
            roughnessmap: {
              roughnessMap: { value: null }
            },
            metalnessmap: {
              metalnessMap: { value: null }
            },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new Color(16777215) }
            },
            lights: {
              ambientLightColor: { value: [] },
              directionalLights: { value: [], properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              } },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: { value: [], properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              } },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: { value: [], properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              } },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: { value: [], properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
              } }
            },
            points: {
              diffuse: { value: new Color(15658734) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              offsetRepeat: { value: new Vector4(0, 0, 1, 1) }
            }
          };
          var ShaderLib = {
            basic: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.aomap,
                UniformsLib.fog
              ]),
              vertexShader: ShaderChunk.meshbasic_vert,
              fragmentShader: ShaderChunk.meshbasic_frag
            },
            lambert: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                  emissive: { value: new Color(0) }
                }
              ]),
              vertexShader: ShaderChunk.meshlambert_vert,
              fragmentShader: ShaderChunk.meshlambert_frag
            },
            phong: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                  emissive: { value: new Color(0) },
                  specular: { value: new Color(1118481) },
                  shininess: { value: 30 }
                }
              ]),
              vertexShader: ShaderChunk.meshphong_vert,
              fragmentShader: ShaderChunk.meshphong_frag
            },
            standard: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.roughnessmap,
                UniformsLib.metalnessmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                  emissive: { value: new Color(0) },
                  roughness: { value: 0.5 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 }
                  // temporary
                }
              ]),
              vertexShader: ShaderChunk.meshphysical_vert,
              fragmentShader: ShaderChunk.meshphysical_frag
            },
            points: {
              uniforms: UniformsUtils.merge([
                UniformsLib.points,
                UniformsLib.fog
              ]),
              vertexShader: ShaderChunk.points_vert,
              fragmentShader: ShaderChunk.points_frag
            },
            dashed: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.fog,
                {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 }
                }
              ]),
              vertexShader: ShaderChunk.linedashed_vert,
              fragmentShader: ShaderChunk.linedashed_frag
            },
            depth: {
              uniforms: UniformsUtils.merge([
                UniformsLib.common,
                UniformsLib.displacementmap
              ]),
              vertexShader: ShaderChunk.depth_vert,
              fragmentShader: ShaderChunk.depth_frag
            },
            normal: {
              uniforms: {
                opacity: { value: 1 }
              },
              vertexShader: ShaderChunk.normal_vert,
              fragmentShader: ShaderChunk.normal_frag
            },
            /* -------------------------------------------------------------------------
            //	Cube map shader
             ------------------------------------------------------------------------- */
            cube: {
              uniforms: {
                tCube: { value: null },
                tFlip: { value: -1 },
                opacity: { value: 1 }
              },
              vertexShader: ShaderChunk.cube_vert,
              fragmentShader: ShaderChunk.cube_frag
            },
            /* -------------------------------------------------------------------------
            //	Cube map shader
             ------------------------------------------------------------------------- */
            equirect: {
              uniforms: {
                tEquirect: { value: null },
                tFlip: { value: -1 }
              },
              vertexShader: ShaderChunk.equirect_vert,
              fragmentShader: ShaderChunk.equirect_frag
            },
            distanceRGBA: {
              uniforms: {
                lightPos: { value: new Vector3() }
              },
              vertexShader: ShaderChunk.distanceRGBA_vert,
              fragmentShader: ShaderChunk.distanceRGBA_frag
            }
          };
          ShaderLib.physical = {
            uniforms: UniformsUtils.merge([
              ShaderLib.standard.uniforms,
              {
                clearCoat: { value: 0 },
                clearCoatRoughness: { value: 0 }
              }
            ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
          };
          function Box2(min, max) {
            this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
            this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
          }
          Box2.prototype = {
            constructor: Box2,
            set: function(min, max) {
              this.min.copy(min);
              this.max.copy(max);
              return this;
            },
            setFromPoints: function(points) {
              this.makeEmpty();
              for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
              }
              return this;
            },
            setFromCenterAndSize: function() {
              var v1 = new Vector2();
              return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
              };
            }(),
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(box) {
              this.min.copy(box.min);
              this.max.copy(box.max);
              return this;
            },
            makeEmpty: function() {
              this.min.x = this.min.y = Infinity;
              this.max.x = this.max.y = -Infinity;
              return this;
            },
            isEmpty: function() {
              return this.max.x < this.min.x || this.max.y < this.min.y;
            },
            getCenter: function(optionalTarget) {
              var result = optionalTarget || new Vector2();
              return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function(optionalTarget) {
              var result = optionalTarget || new Vector2();
              return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
            },
            expandByPoint: function(point) {
              this.min.min(point);
              this.max.max(point);
              return this;
            },
            expandByVector: function(vector) {
              this.min.sub(vector);
              this.max.add(vector);
              return this;
            },
            expandByScalar: function(scalar) {
              this.min.addScalar(-scalar);
              this.max.addScalar(scalar);
              return this;
            },
            containsPoint: function(point) {
              if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
                return false;
              }
              return true;
            },
            containsBox: function(box) {
              if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
                return true;
              }
              return false;
            },
            getParameter: function(point, optionalTarget) {
              var result = optionalTarget || new Vector2();
              return result.set(
                (point.x - this.min.x) / (this.max.x - this.min.x),
                (point.y - this.min.y) / (this.max.y - this.min.y)
              );
            },
            intersectsBox: function(box) {
              if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
                return false;
              }
              return true;
            },
            clampPoint: function(point, optionalTarget) {
              var result = optionalTarget || new Vector2();
              return result.copy(point).clamp(this.min, this.max);
            },
            distanceToPoint: function() {
              var v1 = new Vector2();
              return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
              };
            }(),
            intersect: function(box) {
              this.min.max(box.min);
              this.max.min(box.max);
              return this;
            },
            union: function(box) {
              this.min.min(box.min);
              this.max.max(box.max);
              return this;
            },
            translate: function(offset) {
              this.min.add(offset);
              this.max.add(offset);
              return this;
            },
            equals: function(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          };
          function LensFlarePlugin(renderer, flares) {
            var gl = renderer.context;
            var state = renderer.state;
            var vertexBuffer, elementBuffer;
            var shader, program, attributes, uniforms;
            var tempTexture, occlusionTexture;
            function init() {
              var vertices = new Float32Array([
                -1,
                -1,
                0,
                0,
                1,
                -1,
                1,
                0,
                1,
                1,
                1,
                1,
                -1,
                1,
                0,
                1
              ]);
              var faces = new Uint16Array([
                0,
                1,
                2,
                0,
                2,
                3
              ]);
              vertexBuffer = gl.createBuffer();
              elementBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
              tempTexture = gl.createTexture();
              occlusionTexture = gl.createTexture();
              state.bindTexture(gl.TEXTURE_2D, tempTexture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              shader = {
                vertexShader: [
                  "uniform lowp int renderType;",
                  "uniform vec3 screenPosition;",
                  "uniform vec2 scale;",
                  "uniform float rotation;",
                  "uniform sampler2D occlusionMap;",
                  "attribute vec2 position;",
                  "attribute vec2 uv;",
                  "varying vec2 vUV;",
                  "varying float vVisibility;",
                  "void main() {",
                  "vUV = uv;",
                  "vec2 pos = position;",
                  "if ( renderType == 2 ) {",
                  "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                  "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
                  "vVisibility =        visibility.r / 9.0;",
                  "vVisibility *= 1.0 - visibility.g / 9.0;",
                  "vVisibility *=       visibility.b / 9.0;",
                  "vVisibility *= 1.0 - visibility.a / 9.0;",
                  "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                  "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
                  "}",
                  "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
                  "}"
                ].join("\n"),
                fragmentShader: [
                  "uniform lowp int renderType;",
                  "uniform sampler2D map;",
                  "uniform float opacity;",
                  "uniform vec3 color;",
                  "varying vec2 vUV;",
                  "varying float vVisibility;",
                  "void main() {",
                  // pink square
                  "if ( renderType == 0 ) {",
                  "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
                  // restore
                  "} else if ( renderType == 1 ) {",
                  "gl_FragColor = texture2D( map, vUV );",
                  // flare
                  "} else {",
                  "vec4 texture = texture2D( map, vUV );",
                  "texture.a *= opacity * vVisibility;",
                  "gl_FragColor = texture;",
                  "gl_FragColor.rgb *= color;",
                  "}",
                  "}"
                ].join("\n")
              };
              program = createProgram(shader);
              attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
              };
              uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
              };
            }
            this.render = function(scene, camera, viewport) {
              if (flares.length === 0)
                return;
              var tempPosition = new Vector3();
              var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
              var size = 16 / viewport.w, scale = new Vector2(size * invAspect, size);
              var screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1);
              var validArea = new Box2();
              validArea.min.set(viewport.x, viewport.y);
              validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
              if (program === void 0) {
                init();
              }
              gl.useProgram(program);
              state.initAttributes();
              state.enableAttribute(attributes.vertex);
              state.enableAttribute(attributes.uv);
              state.disableUnusedAttributes();
              gl.uniform1i(uniforms.occlusionMap, 0);
              gl.uniform1i(uniforms.map, 1);
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
              gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
              state.disable(gl.CULL_FACE);
              state.setDepthWrite(false);
              for (var i = 0, l = flares.length; i < l; i++) {
                size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                var flare = flares[i];
                tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
                tempPosition.applyMatrix4(camera.matrixWorldInverse);
                tempPosition.applyProjection(camera.projectionMatrix);
                screenPosition.copy(tempPosition);
                screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;
                if (validArea.containsPoint(screenPositionPixels) === true) {
                  state.activeTexture(gl.TEXTURE0);
                  state.bindTexture(gl.TEXTURE_2D, null);
                  state.activeTexture(gl.TEXTURE1);
                  state.bindTexture(gl.TEXTURE_2D, tempTexture);
                  gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                  gl.uniform1i(uniforms.renderType, 0);
                  gl.uniform2f(uniforms.scale, scale.x, scale.y);
                  gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                  state.disable(gl.BLEND);
                  state.enable(gl.DEPTH_TEST);
                  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                  state.activeTexture(gl.TEXTURE0);
                  state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                  gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                  gl.uniform1i(uniforms.renderType, 1);
                  state.disable(gl.DEPTH_TEST);
                  state.activeTexture(gl.TEXTURE1);
                  state.bindTexture(gl.TEXTURE_2D, tempTexture);
                  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                  flare.positionScreen.copy(screenPosition);
                  if (flare.customUpdateCallback) {
                    flare.customUpdateCallback(flare);
                  } else {
                    flare.updateLensFlares();
                  }
                  gl.uniform1i(uniforms.renderType, 2);
                  state.enable(gl.BLEND);
                  for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                    var sprite = flare.lensFlares[j];
                    if (sprite.opacity > 1e-3 && sprite.scale > 1e-3) {
                      screenPosition.x = sprite.x;
                      screenPosition.y = sprite.y;
                      screenPosition.z = sprite.z;
                      size = sprite.size * sprite.scale / viewport.w;
                      scale.x = size * invAspect;
                      scale.y = size;
                      gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                      gl.uniform2f(uniforms.scale, scale.x, scale.y);
                      gl.uniform1f(uniforms.rotation, sprite.rotation);
                      gl.uniform1f(uniforms.opacity, sprite.opacity);
                      gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                      state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                      renderer.setTexture2D(sprite.texture, 1);
                      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    }
                  }
                }
              }
              state.enable(gl.CULL_FACE);
              state.enable(gl.DEPTH_TEST);
              state.setDepthWrite(true);
              renderer.resetGLState();
            };
            function createProgram(shader2) {
              var program2 = gl.createProgram();
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              var vertexShader = gl.createShader(gl.VERTEX_SHADER);
              var prefix = "precision " + renderer.getPrecision() + " float;\n";
              gl.shaderSource(fragmentShader, prefix + shader2.fragmentShader);
              gl.shaderSource(vertexShader, prefix + shader2.vertexShader);
              gl.compileShader(fragmentShader);
              gl.compileShader(vertexShader);
              gl.attachShader(program2, fragmentShader);
              gl.attachShader(program2, vertexShader);
              gl.linkProgram(program2);
              return program2;
            }
          }
          function SpritePlugin(renderer, sprites) {
            var gl = renderer.context;
            var state = renderer.state;
            var vertexBuffer, elementBuffer;
            var program, attributes, uniforms;
            var texture;
            var spritePosition = new Vector3();
            var spriteRotation = new Quaternion();
            var spriteScale = new Vector3();
            function init() {
              var vertices = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0.5,
                -0.5,
                1,
                0,
                0.5,
                0.5,
                1,
                1,
                -0.5,
                0.5,
                0,
                1
              ]);
              var faces = new Uint16Array([
                0,
                1,
                2,
                0,
                2,
                3
              ]);
              vertexBuffer = gl.createBuffer();
              elementBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
              program = createProgram();
              attributes = {
                position: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
              };
              uniforms = {
                uvOffset: gl.getUniformLocation(program, "uvOffset"),
                uvScale: gl.getUniformLocation(program, "uvScale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                scale: gl.getUniformLocation(program, "scale"),
                color: gl.getUniformLocation(program, "color"),
                map: gl.getUniformLocation(program, "map"),
                opacity: gl.getUniformLocation(program, "opacity"),
                modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                fogType: gl.getUniformLocation(program, "fogType"),
                fogDensity: gl.getUniformLocation(program, "fogDensity"),
                fogNear: gl.getUniformLocation(program, "fogNear"),
                fogFar: gl.getUniformLocation(program, "fogFar"),
                fogColor: gl.getUniformLocation(program, "fogColor"),
                alphaTest: gl.getUniformLocation(program, "alphaTest")
              };
              var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
              canvas.width = 8;
              canvas.height = 8;
              var context2 = canvas.getContext("2d");
              context2.fillStyle = "white";
              context2.fillRect(0, 0, 8, 8);
              texture = new Texture(canvas);
              texture.needsUpdate = true;
            }
            this.render = function(scene, camera) {
              if (sprites.length === 0)
                return;
              if (program === void 0) {
                init();
              }
              gl.useProgram(program);
              state.initAttributes();
              state.enableAttribute(attributes.position);
              state.enableAttribute(attributes.uv);
              state.disableUnusedAttributes();
              state.disable(gl.CULL_FACE);
              state.enable(gl.BLEND);
              gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
              gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
              gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
              gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
              state.activeTexture(gl.TEXTURE0);
              gl.uniform1i(uniforms.map, 0);
              var oldFogType = 0;
              var sceneFogType = 0;
              var fog = scene.fog;
              if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog && fog.isFog) {
                  gl.uniform1f(uniforms.fogNear, fog.near);
                  gl.uniform1f(uniforms.fogFar, fog.far);
                  gl.uniform1i(uniforms.fogType, 1);
                  oldFogType = 1;
                  sceneFogType = 1;
                } else if (fog && fog.isFogExp2) {
                  gl.uniform1f(uniforms.fogDensity, fog.density);
                  gl.uniform1i(uniforms.fogType, 2);
                  oldFogType = 2;
                  sceneFogType = 2;
                }
              } else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
              }
              for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
              }
              sprites.sort(painterSortStable);
              var scale = [];
              for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false)
                  continue;
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;
                var fogType = 0;
                if (scene.fog && material.fog) {
                  fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                  gl.uniform1i(uniforms.fogType, fogType);
                  oldFogType = fogType;
                }
                if (material.map !== null) {
                  gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                  gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                } else {
                  gl.uniform2f(uniforms.uvOffset, 0, 0);
                  gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
                state.setDepthTest(material.depthTest);
                state.setDepthWrite(material.depthWrite);
                if (material.map) {
                  renderer.setTexture2D(material.map, 0);
                } else {
                  renderer.setTexture2D(texture, 0);
                }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              }
              state.enable(gl.CULL_FACE);
              renderer.resetGLState();
            };
            function createProgram() {
              var program2 = gl.createProgram();
              var vertexShader = gl.createShader(gl.VERTEX_SHADER);
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(vertexShader, [
                "precision " + renderer.getPrecision() + " float;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform float rotation;",
                "uniform vec2 scale;",
                "uniform vec2 uvOffset;",
                "uniform vec2 uvScale;",
                "attribute vec2 position;",
                "attribute vec2 uv;",
                "varying vec2 vUV;",
                "void main() {",
                "vUV = uvOffset + uv * uvScale;",
                "vec2 alignedPosition = position * scale;",
                "vec2 rotatedPosition;",
                "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
                "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
                "vec4 finalPosition;",
                "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
                "finalPosition.xy += rotatedPosition;",
                "finalPosition = projectionMatrix * finalPosition;",
                "gl_Position = finalPosition;",
                "}"
              ].join("\n"));
              gl.shaderSource(fragmentShader, [
                "precision " + renderer.getPrecision() + " float;",
                "uniform vec3 color;",
                "uniform sampler2D map;",
                "uniform float opacity;",
                "uniform int fogType;",
                "uniform vec3 fogColor;",
                "uniform float fogDensity;",
                "uniform float fogNear;",
                "uniform float fogFar;",
                "uniform float alphaTest;",
                "varying vec2 vUV;",
                "void main() {",
                "vec4 texture = texture2D( map, vUV );",
                "if ( texture.a < alphaTest ) discard;",
                "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
                "if ( fogType > 0 ) {",
                "float depth = gl_FragCoord.z / gl_FragCoord.w;",
                "float fogFactor = 0.0;",
                "if ( fogType == 1 ) {",
                "fogFactor = smoothstep( fogNear, fogFar, depth );",
                "} else {",
                "const float LOG2 = 1.442695;",
                "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
                "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                "}",
                "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
                "}",
                "}"
              ].join("\n"));
              gl.compileShader(vertexShader);
              gl.compileShader(fragmentShader);
              gl.attachShader(program2, vertexShader);
              gl.attachShader(program2, fragmentShader);
              gl.linkProgram(program2);
              return program2;
            }
            function painterSortStable(a, b) {
              if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
              } else if (a.z !== b.z) {
                return b.z - a.z;
              } else {
                return b.id - a.id;
              }
            }
          }
          function Material() {
            Object.defineProperty(this, "id", { value: MaterialIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.type = "Material";
            this.fog = true;
            this.lights = true;
            this.blending = NormalBlending;
            this.side = FrontSide;
            this.shading = SmoothShading;
            this.vertexColors = NoColors;
            this.opacity = 1;
            this.transparent = false;
            this.blendSrc = SrcAlphaFactor;
            this.blendDst = OneMinusSrcAlphaFactor;
            this.blendEquation = AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;
            this.depthFunc = LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;
            this.clippingPlanes = null;
            this.clipIntersection = false;
            this.clipShadows = false;
            this.colorWrite = true;
            this.precision = null;
            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;
            this.alphaTest = 0;
            this.premultipliedAlpha = false;
            this.overdraw = 0;
            this.visible = true;
            this._needsUpdate = true;
          }
          Material.prototype = {
            constructor: Material,
            isMaterial: true,
            get needsUpdate() {
              return this._needsUpdate;
            },
            set needsUpdate(value) {
              if (value === true)
                this.update();
              this._needsUpdate = value;
            },
            setValues: function(values) {
              if (values === void 0)
                return;
              for (var key in values) {
                var newValue = values[key];
                if (newValue === void 0) {
                  console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                  continue;
                }
                var currentValue = this[key];
                if (currentValue === void 0) {
                  console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                  continue;
                }
                if (currentValue && currentValue.isColor) {
                  currentValue.set(newValue);
                } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
                  currentValue.copy(newValue);
                } else if (key === "overdraw") {
                  this[key] = Number(newValue);
                } else {
                  this[key] = newValue;
                }
              }
            },
            toJSON: function(meta) {
              var isRoot = meta === void 0;
              if (isRoot) {
                meta = {
                  textures: {},
                  images: {}
                };
              }
              var data = {
                metadata: {
                  version: 4.4,
                  type: "Material",
                  generator: "Material.toJSON"
                }
              };
              data.uuid = this.uuid;
              data.type = this.type;
              if (this.name !== "")
                data.name = this.name;
              if (this.color && this.color.isColor)
                data.color = this.color.getHex();
              if (this.roughness !== void 0)
                data.roughness = this.roughness;
              if (this.metalness !== void 0)
                data.metalness = this.metalness;
              if (this.emissive && this.emissive.isColor)
                data.emissive = this.emissive.getHex();
              if (this.specular && this.specular.isColor)
                data.specular = this.specular.getHex();
              if (this.shininess !== void 0)
                data.shininess = this.shininess;
              if (this.map && this.map.isTexture)
                data.map = this.map.toJSON(meta).uuid;
              if (this.alphaMap && this.alphaMap.isTexture)
                data.alphaMap = this.alphaMap.toJSON(meta).uuid;
              if (this.lightMap && this.lightMap.isTexture)
                data.lightMap = this.lightMap.toJSON(meta).uuid;
              if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
              }
              if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
              }
              if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
              }
              if (this.roughnessMap && this.roughnessMap.isTexture)
                data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
              if (this.metalnessMap && this.metalnessMap.isTexture)
                data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
              if (this.emissiveMap && this.emissiveMap.isTexture)
                data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
              if (this.specularMap && this.specularMap.isTexture)
                data.specularMap = this.specularMap.toJSON(meta).uuid;
              if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
              }
              if (this.size !== void 0)
                data.size = this.size;
              if (this.sizeAttenuation !== void 0)
                data.sizeAttenuation = this.sizeAttenuation;
              if (this.blending !== NormalBlending)
                data.blending = this.blending;
              if (this.shading !== SmoothShading)
                data.shading = this.shading;
              if (this.side !== FrontSide)
                data.side = this.side;
              if (this.vertexColors !== NoColors)
                data.vertexColors = this.vertexColors;
              if (this.opacity < 1)
                data.opacity = this.opacity;
              if (this.transparent === true)
                data.transparent = this.transparent;
              data.depthFunc = this.depthFunc;
              data.depthTest = this.depthTest;
              data.depthWrite = this.depthWrite;
              if (this.alphaTest > 0)
                data.alphaTest = this.alphaTest;
              if (this.premultipliedAlpha === true)
                data.premultipliedAlpha = this.premultipliedAlpha;
              if (this.wireframe === true)
                data.wireframe = this.wireframe;
              if (this.wireframeLinewidth > 1)
                data.wireframeLinewidth = this.wireframeLinewidth;
              if (this.wireframeLinecap !== "round")
                data.wireframeLinecap = this.wireframeLinecap;
              if (this.wireframeLinejoin !== "round")
                data.wireframeLinejoin = this.wireframeLinejoin;
              data.skinning = this.skinning;
              data.morphTargets = this.morphTargets;
              function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                  var data2 = cache[key];
                  delete data2.metadata;
                  values.push(data2);
                }
                return values;
              }
              if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0)
                  data.textures = textures;
                if (images.length > 0)
                  data.images = images;
              }
              return data;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(source) {
              this.name = source.name;
              this.fog = source.fog;
              this.lights = source.lights;
              this.blending = source.blending;
              this.side = source.side;
              this.shading = source.shading;
              this.vertexColors = source.vertexColors;
              this.opacity = source.opacity;
              this.transparent = source.transparent;
              this.blendSrc = source.blendSrc;
              this.blendDst = source.blendDst;
              this.blendEquation = source.blendEquation;
              this.blendSrcAlpha = source.blendSrcAlpha;
              this.blendDstAlpha = source.blendDstAlpha;
              this.blendEquationAlpha = source.blendEquationAlpha;
              this.depthFunc = source.depthFunc;
              this.depthTest = source.depthTest;
              this.depthWrite = source.depthWrite;
              this.colorWrite = source.colorWrite;
              this.precision = source.precision;
              this.polygonOffset = source.polygonOffset;
              this.polygonOffsetFactor = source.polygonOffsetFactor;
              this.polygonOffsetUnits = source.polygonOffsetUnits;
              this.alphaTest = source.alphaTest;
              this.premultipliedAlpha = source.premultipliedAlpha;
              this.overdraw = source.overdraw;
              this.visible = source.visible;
              this.clipShadows = source.clipShadows;
              this.clipIntersection = source.clipIntersection;
              var srcPlanes = source.clippingPlanes, dstPlanes = null;
              if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i)
                  dstPlanes[i] = srcPlanes[i].clone();
              }
              this.clippingPlanes = dstPlanes;
              return this;
            },
            update: function() {
              this.dispatchEvent({ type: "update" });
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            }
          };
          Object.assign(Material.prototype, EventDispatcher.prototype);
          var count$1 = 0;
          function MaterialIdCount() {
            return count$1++;
          }
          function ShaderMaterial(parameters) {
            Material.call(this);
            this.type = "ShaderMaterial";
            this.defines = {};
            this.uniforms = {};
            this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
            this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
            this.linewidth = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.clipping = false;
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.extensions = {
              derivatives: false,
              // set to use derivatives
              fragDepth: false,
              // set to use fragment depth values
              drawBuffers: false,
              // set to use draw buffers
              shaderTextureLOD: false
              // set to use shader texture LOD
            };
            this.defaultAttributeValues = {
              "color": [1, 1, 1],
              "uv": [0, 0],
              "uv2": [0, 0]
            };
            this.index0AttributeName = void 0;
            if (parameters !== void 0) {
              if (parameters.attributes !== void 0) {
                console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
              }
              this.setValues(parameters);
            }
          }
          ShaderMaterial.prototype = Object.create(Material.prototype);
          ShaderMaterial.prototype.constructor = ShaderMaterial;
          ShaderMaterial.prototype.isShaderMaterial = true;
          ShaderMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;
            this.uniforms = UniformsUtils.clone(source.uniforms);
            this.defines = source.defines;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.lights = source.lights;
            this.clipping = source.clipping;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            this.extensions = source.extensions;
            return this;
          };
          ShaderMaterial.prototype.toJSON = function(meta) {
            var data = Material.prototype.toJSON.call(this, meta);
            data.uniforms = this.uniforms;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;
            return data;
          };
          function MeshDepthMaterial(parameters) {
            Material.call(this);
            this.type = "MeshDepthMaterial";
            this.depthPacking = BasicDepthPacking;
            this.skinning = false;
            this.morphTargets = false;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
          }
          MeshDepthMaterial.prototype = Object.create(Material.prototype);
          MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
          MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
          MeshDepthMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.depthPacking = source.depthPacking;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
          };
          function Box3(min, max) {
            this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
            this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
          }
          Box3.prototype = {
            constructor: Box3,
            isBox3: true,
            set: function(min, max) {
              this.min.copy(min);
              this.max.copy(max);
              return this;
            },
            setFromArray: function(array) {
              var minX = Infinity;
              var minY = Infinity;
              var minZ = Infinity;
              var maxX = -Infinity;
              var maxY = -Infinity;
              var maxZ = -Infinity;
              for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX)
                  minX = x;
                if (y < minY)
                  minY = y;
                if (z < minZ)
                  minZ = z;
                if (x > maxX)
                  maxX = x;
                if (y > maxY)
                  maxY = y;
                if (z > maxZ)
                  maxZ = z;
              }
              this.min.set(minX, minY, minZ);
              this.max.set(maxX, maxY, maxZ);
            },
            setFromPoints: function(points) {
              this.makeEmpty();
              for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
              }
              return this;
            },
            setFromCenterAndSize: function() {
              var v1 = new Vector3();
              return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
              };
            }(),
            setFromObject: function() {
              var v1 = new Vector3();
              return function setFromObject(object) {
                var scope = this;
                object.updateMatrixWorld(true);
                this.makeEmpty();
                object.traverse(function(node) {
                  var geometry = node.geometry;
                  if (geometry !== void 0) {
                    if (geometry && geometry.isGeometry) {
                      var vertices = geometry.vertices;
                      for (var i = 0, il = vertices.length; i < il; i++) {
                        v1.copy(vertices[i]);
                        v1.applyMatrix4(node.matrixWorld);
                        scope.expandByPoint(v1);
                      }
                    } else if (geometry && geometry.isBufferGeometry) {
                      var attribute = geometry.attributes.position;
                      if (attribute !== void 0) {
                        var array, offset, stride;
                        if (attribute && attribute.isInterleavedBufferAttribute) {
                          array = attribute.data.array;
                          offset = attribute.offset;
                          stride = attribute.data.stride;
                        } else {
                          array = attribute.array;
                          offset = 0;
                          stride = 3;
                        }
                        for (var i = offset, il = array.length; i < il; i += stride) {
                          v1.fromArray(array, i);
                          v1.applyMatrix4(node.matrixWorld);
                          scope.expandByPoint(v1);
                        }
                      }
                    }
                  }
                });
                return this;
              };
            }(),
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(box) {
              this.min.copy(box.min);
              this.max.copy(box.max);
              return this;
            },
            makeEmpty: function() {
              this.min.x = this.min.y = this.min.z = Infinity;
              this.max.x = this.max.y = this.max.z = -Infinity;
              return this;
            },
            isEmpty: function() {
              return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            },
            getCenter: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
            },
            expandByPoint: function(point) {
              this.min.min(point);
              this.max.max(point);
              return this;
            },
            expandByVector: function(vector) {
              this.min.sub(vector);
              this.max.add(vector);
              return this;
            },
            expandByScalar: function(scalar) {
              this.min.addScalar(-scalar);
              this.max.addScalar(scalar);
              return this;
            },
            containsPoint: function(point) {
              if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
                return false;
              }
              return true;
            },
            containsBox: function(box) {
              if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
                return true;
              }
              return false;
            },
            getParameter: function(point, optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.set(
                (point.x - this.min.x) / (this.max.x - this.min.x),
                (point.y - this.min.y) / (this.max.y - this.min.y),
                (point.z - this.min.z) / (this.max.z - this.min.z)
              );
            },
            intersectsBox: function(box) {
              if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
                return false;
              }
              return true;
            },
            intersectsSphere: /* @__PURE__ */ function() {
              var closestPoint;
              return function intersectsSphere(sphere) {
                if (closestPoint === void 0)
                  closestPoint = new Vector3();
                this.clampPoint(sphere.center, closestPoint);
                return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
              };
            }(),
            intersectsPlane: function(plane) {
              var min, max;
              if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
              } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
              }
              if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
              } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
              }
              if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
              } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
              }
              return min <= plane.constant && max >= plane.constant;
            },
            clampPoint: function(point, optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.copy(point).clamp(this.min, this.max);
            },
            distanceToPoint: function() {
              var v1 = new Vector3();
              return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
              };
            }(),
            getBoundingSphere: function() {
              var v1 = new Vector3();
              return function getBoundingSphere(optionalTarget) {
                var result = optionalTarget || new Sphere();
                this.getCenter(result.center);
                result.radius = this.getSize(v1).length() * 0.5;
                return result;
              };
            }(),
            intersect: function(box) {
              this.min.max(box.min);
              this.max.min(box.max);
              if (this.isEmpty())
                this.makeEmpty();
              return this;
            },
            union: function(box) {
              this.min.min(box.min);
              this.max.max(box.max);
              return this;
            },
            applyMatrix4: function() {
              var points = [
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3(),
                new Vector3()
              ];
              return function applyMatrix4(matrix) {
                if (this.isEmpty())
                  return this;
                points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
                points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
                this.setFromPoints(points);
                return this;
              };
            }(),
            translate: function(offset) {
              this.min.add(offset);
              this.max.add(offset);
              return this;
            },
            equals: function(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          };
          function Sphere(center, radius) {
            this.center = center !== void 0 ? center : new Vector3();
            this.radius = radius !== void 0 ? radius : 0;
          }
          Sphere.prototype = {
            constructor: Sphere,
            set: function(center, radius) {
              this.center.copy(center);
              this.radius = radius;
              return this;
            },
            setFromPoints: function() {
              var box = new Box3();
              return function setFromPoints(points, optionalCenter) {
                var center = this.center;
                if (optionalCenter !== void 0) {
                  center.copy(optionalCenter);
                } else {
                  box.setFromPoints(points).getCenter(center);
                }
                var maxRadiusSq = 0;
                for (var i = 0, il = points.length; i < il; i++) {
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }
                this.radius = Math.sqrt(maxRadiusSq);
                return this;
              };
            }(),
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(sphere) {
              this.center.copy(sphere.center);
              this.radius = sphere.radius;
              return this;
            },
            empty: function() {
              return this.radius <= 0;
            },
            containsPoint: function(point) {
              return point.distanceToSquared(this.center) <= this.radius * this.radius;
            },
            distanceToPoint: function(point) {
              return point.distanceTo(this.center) - this.radius;
            },
            intersectsSphere: function(sphere) {
              var radiusSum = this.radius + sphere.radius;
              return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
            },
            intersectsBox: function(box) {
              return box.intersectsSphere(this);
            },
            intersectsPlane: function(plane) {
              return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
            },
            clampPoint: function(point, optionalTarget) {
              var deltaLengthSq = this.center.distanceToSquared(point);
              var result = optionalTarget || new Vector3();
              result.copy(point);
              if (deltaLengthSq > this.radius * this.radius) {
                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
              }
              return result;
            },
            getBoundingBox: function(optionalTarget) {
              var box = optionalTarget || new Box3();
              box.set(this.center, this.center);
              box.expandByScalar(this.radius);
              return box;
            },
            applyMatrix4: function(matrix) {
              this.center.applyMatrix4(matrix);
              this.radius = this.radius * matrix.getMaxScaleOnAxis();
              return this;
            },
            translate: function(offset) {
              this.center.add(offset);
              return this;
            },
            equals: function(sphere) {
              return sphere.center.equals(this.center) && sphere.radius === this.radius;
            }
          };
          function Matrix3() {
            this.elements = new Float32Array([
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1
            ]);
            if (arguments.length > 0) {
              console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
            }
          }
          Matrix3.prototype = {
            constructor: Matrix3,
            isMatrix3: true,
            set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
              var te = this.elements;
              te[0] = n11;
              te[1] = n21;
              te[2] = n31;
              te[3] = n12;
              te[4] = n22;
              te[5] = n32;
              te[6] = n13;
              te[7] = n23;
              te[8] = n33;
              return this;
            },
            identity: function() {
              this.set(
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
              );
              return this;
            },
            clone: function() {
              return new this.constructor().fromArray(this.elements);
            },
            copy: function(m) {
              var me = m.elements;
              this.set(
                me[0],
                me[3],
                me[6],
                me[1],
                me[4],
                me[7],
                me[2],
                me[5],
                me[8]
              );
              return this;
            },
            setFromMatrix4: function(m) {
              var me = m.elements;
              this.set(
                me[0],
                me[4],
                me[8],
                me[1],
                me[5],
                me[9],
                me[2],
                me[6],
                me[10]
              );
              return this;
            },
            applyToVector3Array: /* @__PURE__ */ function() {
              var v1;
              return function applyToVector3Array(array, offset, length) {
                if (v1 === void 0)
                  v1 = new Vector3();
                if (offset === void 0)
                  offset = 0;
                if (length === void 0)
                  length = array.length;
                for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                  v1.fromArray(array, j);
                  v1.applyMatrix3(this);
                  v1.toArray(array, j);
                }
                return array;
              };
            }(),
            applyToBuffer: /* @__PURE__ */ function() {
              var v1;
              return function applyToBuffer(buffer, offset, length) {
                if (v1 === void 0)
                  v1 = new Vector3();
                if (offset === void 0)
                  offset = 0;
                if (length === void 0)
                  length = buffer.length / buffer.itemSize;
                for (var i = 0, j = offset; i < length; i++, j++) {
                  v1.x = buffer.getX(j);
                  v1.y = buffer.getY(j);
                  v1.z = buffer.getZ(j);
                  v1.applyMatrix3(this);
                  buffer.setXYZ(j, v1.x, v1.y, v1.z);
                }
                return buffer;
              };
            }(),
            multiplyScalar: function(s) {
              var te = this.elements;
              te[0] *= s;
              te[3] *= s;
              te[6] *= s;
              te[1] *= s;
              te[4] *= s;
              te[7] *= s;
              te[2] *= s;
              te[5] *= s;
              te[8] *= s;
              return this;
            },
            determinant: function() {
              var te = this.elements;
              var a = te[0], b = te[1], c = te[2], d = te[3], e2 = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
              return a * e2 * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e2 * g;
            },
            getInverse: function(matrix, throwOnDegenerate) {
              if (matrix && matrix.isMatrix4) {
                console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
              }
              var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
              if (det === 0) {
                var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                  throw new Error(msg);
                } else {
                  console.warn(msg);
                }
                return this.identity();
              }
              var detInv = 1 / det;
              te[0] = t11 * detInv;
              te[1] = (n31 * n23 - n33 * n21) * detInv;
              te[2] = (n32 * n21 - n31 * n22) * detInv;
              te[3] = t12 * detInv;
              te[4] = (n33 * n11 - n31 * n13) * detInv;
              te[5] = (n31 * n12 - n32 * n11) * detInv;
              te[6] = t13 * detInv;
              te[7] = (n21 * n13 - n23 * n11) * detInv;
              te[8] = (n22 * n11 - n21 * n12) * detInv;
              return this;
            },
            transpose: function() {
              var tmp, m = this.elements;
              tmp = m[1];
              m[1] = m[3];
              m[3] = tmp;
              tmp = m[2];
              m[2] = m[6];
              m[6] = tmp;
              tmp = m[5];
              m[5] = m[7];
              m[7] = tmp;
              return this;
            },
            flattenToArrayOffset: function(array, offset) {
              console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");
              return this.toArray(array, offset);
            },
            getNormalMatrix: function(matrix4) {
              return this.setFromMatrix4(matrix4).getInverse(this).transpose();
            },
            transposeIntoArray: function(r) {
              var m = this.elements;
              r[0] = m[0];
              r[1] = m[3];
              r[2] = m[6];
              r[3] = m[1];
              r[4] = m[4];
              r[5] = m[7];
              r[6] = m[2];
              r[7] = m[5];
              r[8] = m[8];
              return this;
            },
            fromArray: function(array, offset) {
              if (offset === void 0)
                offset = 0;
              for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
              }
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              var te = this.elements;
              array[offset] = te[0];
              array[offset + 1] = te[1];
              array[offset + 2] = te[2];
              array[offset + 3] = te[3];
              array[offset + 4] = te[4];
              array[offset + 5] = te[5];
              array[offset + 6] = te[6];
              array[offset + 7] = te[7];
              array[offset + 8] = te[8];
              return array;
            }
          };
          function Plane(normal, constant) {
            this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
            this.constant = constant !== void 0 ? constant : 0;
          }
          Plane.prototype = {
            constructor: Plane,
            set: function(normal, constant) {
              this.normal.copy(normal);
              this.constant = constant;
              return this;
            },
            setComponents: function(x, y, z, w) {
              this.normal.set(x, y, z);
              this.constant = w;
              return this;
            },
            setFromNormalAndCoplanarPoint: function(normal, point) {
              this.normal.copy(normal);
              this.constant = -point.dot(this.normal);
              return this;
            },
            setFromCoplanarPoints: function() {
              var v1 = new Vector3();
              var v2 = new Vector3();
              return function setFromCoplanarPoints(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
              };
            }(),
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(plane) {
              this.normal.copy(plane.normal);
              this.constant = plane.constant;
              return this;
            },
            normalize: function() {
              var inverseNormalLength = 1 / this.normal.length();
              this.normal.multiplyScalar(inverseNormalLength);
              this.constant *= inverseNormalLength;
              return this;
            },
            negate: function() {
              this.constant *= -1;
              this.normal.negate();
              return this;
            },
            distanceToPoint: function(point) {
              return this.normal.dot(point) + this.constant;
            },
            distanceToSphere: function(sphere) {
              return this.distanceToPoint(sphere.center) - sphere.radius;
            },
            projectPoint: function(point, optionalTarget) {
              return this.orthoPoint(point, optionalTarget).sub(point).negate();
            },
            orthoPoint: function(point, optionalTarget) {
              var perpendicularMagnitude = this.distanceToPoint(point);
              var result = optionalTarget || new Vector3();
              return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
            },
            intersectLine: function() {
              var v1 = new Vector3();
              return function intersectLine(line, optionalTarget) {
                var result = optionalTarget || new Vector3();
                var direction = line.delta(v1);
                var denominator = this.normal.dot(direction);
                if (denominator === 0) {
                  if (this.distanceToPoint(line.start) === 0) {
                    return result.copy(line.start);
                  }
                  return void 0;
                }
                var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                if (t < 0 || t > 1) {
                  return void 0;
                }
                return result.copy(direction).multiplyScalar(t).add(line.start);
              };
            }(),
            intersectsLine: function(line) {
              var startSign = this.distanceToPoint(line.start);
              var endSign = this.distanceToPoint(line.end);
              return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
            },
            intersectsBox: function(box) {
              return box.intersectsPlane(this);
            },
            intersectsSphere: function(sphere) {
              return sphere.intersectsPlane(this);
            },
            coplanarPoint: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.copy(this.normal).multiplyScalar(-this.constant);
            },
            applyMatrix4: function() {
              var v1 = new Vector3();
              var m1 = new Matrix3();
              return function applyMatrix4(matrix, optionalNormalMatrix) {
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
              };
            }(),
            translate: function(offset) {
              this.constant = this.constant - offset.dot(this.normal);
              return this;
            },
            equals: function(plane) {
              return plane.normal.equals(this.normal) && plane.constant === this.constant;
            }
          };
          function Frustum(p0, p1, p2, p3, p4, p5) {
            this.planes = [
              p0 !== void 0 ? p0 : new Plane(),
              p1 !== void 0 ? p1 : new Plane(),
              p2 !== void 0 ? p2 : new Plane(),
              p3 !== void 0 ? p3 : new Plane(),
              p4 !== void 0 ? p4 : new Plane(),
              p5 !== void 0 ? p5 : new Plane()
            ];
          }
          Frustum.prototype = {
            constructor: Frustum,
            set: function(p0, p1, p2, p3, p4, p5) {
              var planes = this.planes;
              planes[0].copy(p0);
              planes[1].copy(p1);
              planes[2].copy(p2);
              planes[3].copy(p3);
              planes[4].copy(p4);
              planes[5].copy(p5);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(frustum) {
              var planes = this.planes;
              for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
              }
              return this;
            },
            setFromMatrix: function(m) {
              var planes = this.planes;
              var me = m.elements;
              var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
              var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
              var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
              var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
              planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
              planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
              planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
              planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
              planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
              planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
              return this;
            },
            intersectsObject: function() {
              var sphere = new Sphere();
              return function intersectsObject(object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                return this.intersectsSphere(sphere);
              };
            }(),
            intersectsSprite: function() {
              var sphere = new Sphere();
              return function intersectsSprite(sprite) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0.7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);
                return this.intersectsSphere(sphere);
              };
            }(),
            intersectsSphere: function(sphere) {
              var planes = this.planes;
              var center = sphere.center;
              var negRadius = -sphere.radius;
              for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                  return false;
                }
              }
              return true;
            },
            intersectsBox: function() {
              var p1 = new Vector3(), p2 = new Vector3();
              return function intersectsBox(box) {
                var planes = this.planes;
                for (var i = 0; i < 6; i++) {
                  var plane = planes[i];
                  p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                  p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                  p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                  p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                  p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                  p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                  var d1 = plane.distanceToPoint(p1);
                  var d2 = plane.distanceToPoint(p2);
                  if (d1 < 0 && d2 < 0) {
                    return false;
                  }
                }
                return true;
              };
            }(),
            containsPoint: function(point) {
              var planes = this.planes;
              for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                  return false;
                }
              }
              return true;
            }
          };
          function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
            var _gl = _renderer.context, _state = _renderer.state, _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _lightShadows = _lights.shadows, _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _renderList = [], _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
            var cubeDirections = [
              new Vector3(1, 0, 0),
              new Vector3(-1, 0, 0),
              new Vector3(0, 0, 1),
              new Vector3(0, 0, -1),
              new Vector3(0, 1, 0),
              new Vector3(0, -1, 0)
            ];
            var cubeUps = [
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 1, 0),
              new Vector3(0, 0, 1),
              new Vector3(0, 0, -1)
            ];
            var cube2DViewPorts = [
              new Vector4(),
              new Vector4(),
              new Vector4(),
              new Vector4(),
              new Vector4(),
              new Vector4()
            ];
            var depthMaterialTemplate = new MeshDepthMaterial();
            depthMaterialTemplate.depthPacking = RGBADepthPacking;
            depthMaterialTemplate.clipping = true;
            var distanceShader = ShaderLib["distanceRGBA"];
            var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);
            for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
              var useMorphing = (i & _MorphingFlag) !== 0;
              var useSkinning = (i & _SkinningFlag) !== 0;
              var depthMaterial = depthMaterialTemplate.clone();
              depthMaterial.morphTargets = useMorphing;
              depthMaterial.skinning = useSkinning;
              _depthMaterials[i] = depthMaterial;
              var distanceMaterial = new ShaderMaterial({
                defines: {
                  "USE_SHADOWMAP": ""
                },
                uniforms: distanceUniforms,
                vertexShader: distanceShader.vertexShader,
                fragmentShader: distanceShader.fragmentShader,
                morphTargets: useMorphing,
                skinning: useSkinning,
                clipping: true
              });
              _distanceMaterials[i] = distanceMaterial;
            }
            var scope = this;
            this.enabled = false;
            this.autoUpdate = true;
            this.needsUpdate = false;
            this.type = PCFShadowMap;
            this.renderReverseSided = true;
            this.renderSingleSided = true;
            this.render = function(scene, camera) {
              if (scope.enabled === false)
                return;
              if (scope.autoUpdate === false && scope.needsUpdate === false)
                return;
              if (_lightShadows.length === 0)
                return;
              _state.clearColor(1, 1, 1, 1);
              _state.disable(_gl.BLEND);
              _state.setDepthTest(true);
              _state.setScissorTest(false);
              var faceCount, isPointLight;
              for (var i2 = 0, il = _lightShadows.length; i2 < il; i2++) {
                var light = _lightShadows[i2];
                var shadow = light.shadow;
                if (shadow === void 0) {
                  console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                  continue;
                }
                var shadowCamera = shadow.camera;
                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(_maxShadowMapSize);
                if (light && light.isPointLight) {
                  faceCount = 6;
                  isPointLight = true;
                  var vpWidth = _shadowMapSize.x;
                  var vpHeight = _shadowMapSize.y;
                  cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                  cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                  cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                  cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                  cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                  cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                  _shadowMapSize.x *= 4;
                  _shadowMapSize.y *= 2;
                } else {
                  faceCount = 1;
                  isPointLight = false;
                }
                if (shadow.map === null) {
                  var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
                  shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                  shadowCamera.updateProjectionMatrix();
                }
                if (shadow && shadow.isSpotLightShadow) {
                  shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);
                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();
                for (var face = 0; face < faceCount; face++) {
                  if (isPointLight) {
                    _lookTarget.copy(shadowCamera.position);
                    _lookTarget.add(cubeDirections[face]);
                    shadowCamera.up.copy(cubeUps[face]);
                    shadowCamera.lookAt(_lookTarget);
                    var vpDimensions = cube2DViewPorts[face];
                    _state.viewport(vpDimensions);
                  } else {
                    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(_lookTarget);
                  }
                  shadowCamera.updateMatrixWorld();
                  shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
                  shadowMatrix.set(
                    0.5,
                    0,
                    0,
                    0.5,
                    0,
                    0.5,
                    0,
                    0.5,
                    0,
                    0,
                    0.5,
                    0.5,
                    0,
                    0,
                    0,
                    1
                  );
                  shadowMatrix.multiply(shadowCamera.projectionMatrix);
                  shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                  _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                  _frustum.setFromMatrix(_projScreenMatrix);
                  _renderList.length = 0;
                  projectObject(scene, camera, shadowCamera);
                  for (var j = 0, jl = _renderList.length; j < jl; j++) {
                    var object = _renderList[j];
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (material && material.isMultiMaterial) {
                      var groups = geometry.groups;
                      var materials = material.materials;
                      for (var k = 0, kl = groups.length; k < kl; k++) {
                        var group = groups[k];
                        var groupMaterial = materials[group.materialIndex];
                        if (groupMaterial.visible === true) {
                          var depthMaterial2 = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial2, object, group);
                        }
                      }
                    } else {
                      var depthMaterial2 = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                      _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial2, object, null);
                    }
                  }
                }
              }
              var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
              _renderer.setClearColor(clearColor, clearAlpha);
              scope.needsUpdate = false;
            };
            function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
              var geometry = object.geometry;
              var result = null;
              var materialVariants = _depthMaterials;
              var customMaterial = object.customDepthMaterial;
              if (isPointLight) {
                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
              }
              if (!customMaterial) {
                var useMorphing2 = false;
                if (material.morphTargets) {
                  if (geometry && geometry.isBufferGeometry) {
                    useMorphing2 = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                  } else if (geometry && geometry.isGeometry) {
                    useMorphing2 = geometry.morphTargets && geometry.morphTargets.length > 0;
                  }
                }
                var useSkinning2 = object.isSkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing2)
                  variantIndex |= _MorphingFlag;
                if (useSkinning2)
                  variantIndex |= _SkinningFlag;
                result = materialVariants[variantIndex];
              } else {
                result = customMaterial;
              }
              if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === void 0) {
                  materialsForVariant = {};
                  _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === void 0) {
                  cachedMaterial = result.clone();
                  materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
              }
              result.visible = material.visible;
              result.wireframe = material.wireframe;
              var side = material.side;
              if (scope.renderSingleSided && side == DoubleSide) {
                side = FrontSide;
              }
              if (scope.renderReverseSided) {
                if (side === FrontSide)
                  side = BackSide;
                else if (side === BackSide)
                  side = FrontSide;
              }
              result.side = side;
              result.clipShadows = material.clipShadows;
              result.clippingPlanes = material.clippingPlanes;
              result.wireframeLinewidth = material.wireframeLinewidth;
              result.linewidth = material.linewidth;
              if (isPointLight && result.uniforms.lightPos !== void 0) {
                result.uniforms.lightPos.value.copy(lightPositionWorld);
              }
              return result;
            }
            function projectObject(object, camera, shadowCamera) {
              if (object.visible === false)
                return;
              var visible = (object.layers.mask & camera.layers.mask) !== 0;
              if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                  var material = object.material;
                  if (material.visible === true) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    _renderList.push(object);
                  }
                }
              }
              var children = object.children;
              for (var i2 = 0, l = children.length; i2 < l; i2++) {
                projectObject(children[i2], camera, shadowCamera);
              }
            }
          }
          function Ray(origin, direction) {
            this.origin = origin !== void 0 ? origin : new Vector3();
            this.direction = direction !== void 0 ? direction : new Vector3();
          }
          Ray.prototype = {
            constructor: Ray,
            set: function(origin, direction) {
              this.origin.copy(origin);
              this.direction.copy(direction);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(ray) {
              this.origin.copy(ray.origin);
              this.direction.copy(ray.direction);
              return this;
            },
            at: function(t, optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.copy(this.direction).multiplyScalar(t).add(this.origin);
            },
            lookAt: function(v) {
              this.direction.copy(v).sub(this.origin).normalize();
              return this;
            },
            recast: function() {
              var v1 = new Vector3();
              return function recast(t) {
                this.origin.copy(this.at(t, v1));
                return this;
              };
            }(),
            closestPointToPoint: function(point, optionalTarget) {
              var result = optionalTarget || new Vector3();
              result.subVectors(point, this.origin);
              var directionDistance = result.dot(this.direction);
              if (directionDistance < 0) {
                return result.copy(this.origin);
              }
              return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            },
            distanceToPoint: function(point) {
              return Math.sqrt(this.distanceSqToPoint(point));
            },
            distanceSqToPoint: function() {
              var v1 = new Vector3();
              return function distanceSqToPoint(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                if (directionDistance < 0) {
                  return this.origin.distanceToSquared(point);
                }
                v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                return v1.distanceToSquared(point);
              };
            }(),
            distanceSqToSegment: function() {
              var segCenter = new Vector3();
              var segDir = new Vector3();
              var diff = new Vector3();
              return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                segDir.copy(v1).sub(v0).normalize();
                diff.copy(this.origin).sub(segCenter);
                var segExtent = v0.distanceTo(v1) * 0.5;
                var a01 = -this.direction.dot(segDir);
                var b0 = diff.dot(this.direction);
                var b1 = -diff.dot(segDir);
                var c = diff.lengthSq();
                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;
                if (det > 0) {
                  s0 = a01 * b1 - b0;
                  s1 = a01 * b0 - b1;
                  extDet = segExtent * det;
                  if (s0 >= 0) {
                    if (s1 >= -extDet) {
                      if (s1 <= extDet) {
                        var invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                      } else {
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                      }
                    } else {
                      s1 = -segExtent;
                      s0 = Math.max(0, -(a01 * s1 + b0));
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                  } else {
                    if (s1 <= -extDet) {
                      s0 = Math.max(0, -(-a01 * segExtent + b0));
                      s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                      s0 = 0;
                      s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                      s0 = Math.max(0, -(a01 * segExtent + b0));
                      s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                  }
                } else {
                  s1 = a01 > 0 ? -segExtent : segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                if (optionalPointOnRay) {
                  optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }
                if (optionalPointOnSegment) {
                  optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
                }
                return sqrDist;
              };
            }(),
            intersectSphere: function() {
              var v1 = new Vector3();
              return function intersectSphere(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction);
                var d2 = v1.dot(v1) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2)
                  return null;
                var thc = Math.sqrt(radius2 - d2);
                var t0 = tca - thc;
                var t1 = tca + thc;
                if (t0 < 0 && t1 < 0)
                  return null;
                if (t0 < 0)
                  return this.at(t1, optionalTarget);
                return this.at(t0, optionalTarget);
              };
            }(),
            intersectsSphere: function(sphere) {
              return this.distanceToPoint(sphere.center) <= sphere.radius;
            },
            distanceToPlane: function(plane) {
              var denominator = plane.normal.dot(this.direction);
              if (denominator === 0) {
                if (plane.distanceToPoint(this.origin) === 0) {
                  return 0;
                }
                return null;
              }
              var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
              return t >= 0 ? t : null;
            },
            intersectPlane: function(plane, optionalTarget) {
              var t = this.distanceToPlane(plane);
              if (t === null) {
                return null;
              }
              return this.at(t, optionalTarget);
            },
            intersectsPlane: function(plane) {
              var distToPoint = plane.distanceToPoint(this.origin);
              if (distToPoint === 0) {
                return true;
              }
              var denominator = plane.normal.dot(this.direction);
              if (denominator * distToPoint < 0) {
                return true;
              }
              return false;
            },
            intersectBox: function(box, optionalTarget) {
              var tmin, tmax, tymin, tymax, tzmin, tzmax;
              var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
              var origin = this.origin;
              if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
              } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
              }
              if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
              } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
              }
              if (tmin > tymax || tymin > tmax)
                return null;
              if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
              if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
              if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
              } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
              }
              if (tmin > tzmax || tzmin > tmax)
                return null;
              if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
              if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
              if (tmax < 0)
                return null;
              return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
            },
            intersectsBox: function() {
              var v = new Vector3();
              return function intersectsBox(box) {
                return this.intersectBox(box, v) !== null;
              };
            }(),
            intersectTriangle: function() {
              var diff = new Vector3();
              var edge1 = new Vector3();
              var edge2 = new Vector3();
              var normal = new Vector3();
              return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a);
                edge2.subVectors(c, a);
                normal.crossVectors(edge1, edge2);
                var DdN = this.direction.dot(normal);
                var sign;
                if (DdN > 0) {
                  if (backfaceCulling)
                    return null;
                  sign = 1;
                } else if (DdN < 0) {
                  sign = -1;
                  DdN = -DdN;
                } else {
                  return null;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) {
                  return null;
                }
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) {
                  return null;
                }
                if (DdQxE2 + DdE1xQ > DdN) {
                  return null;
                }
                var QdN = -sign * diff.dot(normal);
                if (QdN < 0) {
                  return null;
                }
                return this.at(QdN / DdN, optionalTarget);
              };
            }(),
            applyMatrix4: function(matrix4) {
              this.direction.add(this.origin).applyMatrix4(matrix4);
              this.origin.applyMatrix4(matrix4);
              this.direction.sub(this.origin);
              this.direction.normalize();
              return this;
            },
            equals: function(ray) {
              return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
            }
          };
          function Euler(x, y, z, order) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._order = order || Euler.DefaultOrder;
          }
          Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
          Euler.DefaultOrder = "XYZ";
          Euler.prototype = {
            constructor: Euler,
            isEuler: true,
            get x() {
              return this._x;
            },
            set x(value) {
              this._x = value;
              this.onChangeCallback();
            },
            get y() {
              return this._y;
            },
            set y(value) {
              this._y = value;
              this.onChangeCallback();
            },
            get z() {
              return this._z;
            },
            set z(value) {
              this._z = value;
              this.onChangeCallback();
            },
            get order() {
              return this._order;
            },
            set order(value) {
              this._order = value;
              this.onChangeCallback();
            },
            set: function(x, y, z, order) {
              this._x = x;
              this._y = y;
              this._z = z;
              this._order = order || this._order;
              this.onChangeCallback();
              return this;
            },
            clone: function() {
              return new this.constructor(this._x, this._y, this._z, this._order);
            },
            copy: function(euler) {
              this._x = euler._x;
              this._y = euler._y;
              this._z = euler._z;
              this._order = euler._order;
              this.onChangeCallback();
              return this;
            },
            setFromRotationMatrix: function(m, order, update) {
              var clamp = _Math.clamp;
              var te = m.elements;
              var m11 = te[0], m12 = te[4], m13 = te[8];
              var m21 = te[1], m22 = te[5], m23 = te[9];
              var m31 = te[2], m32 = te[6], m33 = te[10];
              order = order || this._order;
              if (order === "XYZ") {
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.99999) {
                  this._x = Math.atan2(-m23, m33);
                  this._z = Math.atan2(-m12, m11);
                } else {
                  this._x = Math.atan2(m32, m22);
                  this._z = 0;
                }
              } else if (order === "YXZ") {
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.99999) {
                  this._y = Math.atan2(m13, m33);
                  this._z = Math.atan2(m21, m22);
                } else {
                  this._y = Math.atan2(-m31, m11);
                  this._z = 0;
                }
              } else if (order === "ZXY") {
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.99999) {
                  this._y = Math.atan2(-m31, m33);
                  this._z = Math.atan2(-m12, m22);
                } else {
                  this._y = 0;
                  this._z = Math.atan2(m21, m11);
                }
              } else if (order === "ZYX") {
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.99999) {
                  this._x = Math.atan2(m32, m33);
                  this._z = Math.atan2(m21, m11);
                } else {
                  this._x = 0;
                  this._z = Math.atan2(-m12, m22);
                }
              } else if (order === "YZX") {
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.99999) {
                  this._x = Math.atan2(-m23, m22);
                  this._y = Math.atan2(-m31, m11);
                } else {
                  this._x = 0;
                  this._y = Math.atan2(m13, m33);
                }
              } else if (order === "XZY") {
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.99999) {
                  this._x = Math.atan2(m32, m22);
                  this._y = Math.atan2(m13, m11);
                } else {
                  this._x = Math.atan2(-m23, m33);
                  this._y = 0;
                }
              } else {
                console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
              }
              this._order = order;
              if (update !== false)
                this.onChangeCallback();
              return this;
            },
            setFromQuaternion: /* @__PURE__ */ function() {
              var matrix;
              return function setFromQuaternion(q, order, update) {
                if (matrix === void 0)
                  matrix = new Matrix4();
                matrix.makeRotationFromQuaternion(q);
                return this.setFromRotationMatrix(matrix, order, update);
              };
            }(),
            setFromVector3: function(v, order) {
              return this.set(v.x, v.y, v.z, order || this._order);
            },
            reorder: function() {
              var q = new Quaternion();
              return function reorder(newOrder) {
                q.setFromEuler(this);
                return this.setFromQuaternion(q, newOrder);
              };
            }(),
            equals: function(euler) {
              return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
            },
            fromArray: function(array) {
              this._x = array[0];
              this._y = array[1];
              this._z = array[2];
              if (array[3] !== void 0)
                this._order = array[3];
              this.onChangeCallback();
              return this;
            },
            toArray: function(array, offset) {
              if (array === void 0)
                array = [];
              if (offset === void 0)
                offset = 0;
              array[offset] = this._x;
              array[offset + 1] = this._y;
              array[offset + 2] = this._z;
              array[offset + 3] = this._order;
              return array;
            },
            toVector3: function(optionalResult) {
              if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
              } else {
                return new Vector3(this._x, this._y, this._z);
              }
            },
            onChange: function(callback) {
              this.onChangeCallback = callback;
              return this;
            },
            onChangeCallback: function() {
            }
          };
          function Layers() {
            this.mask = 1;
          }
          Layers.prototype = {
            constructor: Layers,
            set: function(channel) {
              this.mask = 1 << channel;
            },
            enable: function(channel) {
              this.mask |= 1 << channel;
            },
            toggle: function(channel) {
              this.mask ^= 1 << channel;
            },
            disable: function(channel) {
              this.mask &= ~(1 << channel);
            },
            test: function(layers) {
              return (this.mask & layers.mask) !== 0;
            }
          };
          function Object3D() {
            Object.defineProperty(this, "id", { value: Object3DIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.type = "Object3D";
            this.parent = null;
            this.children = [];
            this.up = Object3D.DefaultUp.clone();
            var position = new Vector3();
            var rotation = new Euler();
            var quaternion = new Quaternion();
            var scale = new Vector3(1, 1, 1);
            function onRotationChange() {
              quaternion.setFromEuler(rotation, false);
            }
            function onQuaternionChange() {
              rotation.setFromQuaternion(quaternion, void 0, false);
            }
            rotation.onChange(onRotationChange);
            quaternion.onChange(onQuaternionChange);
            Object.defineProperties(this, {
              position: {
                enumerable: true,
                value: position
              },
              rotation: {
                enumerable: true,
                value: rotation
              },
              quaternion: {
                enumerable: true,
                value: quaternion
              },
              scale: {
                enumerable: true,
                value: scale
              },
              modelViewMatrix: {
                value: new Matrix4()
              },
              normalMatrix: {
                value: new Matrix3()
              }
            });
            this.matrix = new Matrix4();
            this.matrixWorld = new Matrix4();
            this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            this.matrixWorldNeedsUpdate = false;
            this.layers = new Layers();
            this.visible = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.frustumCulled = true;
            this.renderOrder = 0;
            this.userData = {};
            this.onBeforeRender = function() {
            };
            this.onAfterRender = function() {
            };
          }
          Object3D.DefaultUp = new Vector3(0, 1, 0);
          Object3D.DefaultMatrixAutoUpdate = true;
          Object.assign(Object3D.prototype, EventDispatcher.prototype, {
            isObject3D: true,
            applyMatrix: function(matrix) {
              this.matrix.multiplyMatrices(matrix, this.matrix);
              this.matrix.decompose(this.position, this.quaternion, this.scale);
            },
            setRotationFromAxisAngle: function(axis, angle) {
              this.quaternion.setFromAxisAngle(axis, angle);
            },
            setRotationFromEuler: function(euler) {
              this.quaternion.setFromEuler(euler, true);
            },
            setRotationFromMatrix: function(m) {
              this.quaternion.setFromRotationMatrix(m);
            },
            setRotationFromQuaternion: function(q) {
              this.quaternion.copy(q);
            },
            rotateOnAxis: function() {
              var q1 = new Quaternion();
              return function rotateOnAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.multiply(q1);
                return this;
              };
            }(),
            rotateX: function() {
              var v1 = new Vector3(1, 0, 0);
              return function rotateX(angle) {
                return this.rotateOnAxis(v1, angle);
              };
            }(),
            rotateY: function() {
              var v1 = new Vector3(0, 1, 0);
              return function rotateY(angle) {
                return this.rotateOnAxis(v1, angle);
              };
            }(),
            rotateZ: function() {
              var v1 = new Vector3(0, 0, 1);
              return function rotateZ(angle) {
                return this.rotateOnAxis(v1, angle);
              };
            }(),
            translateOnAxis: function() {
              var v1 = new Vector3();
              return function translateOnAxis(axis, distance) {
                v1.copy(axis).applyQuaternion(this.quaternion);
                this.position.add(v1.multiplyScalar(distance));
                return this;
              };
            }(),
            translateX: function() {
              var v1 = new Vector3(1, 0, 0);
              return function translateX(distance) {
                return this.translateOnAxis(v1, distance);
              };
            }(),
            translateY: function() {
              var v1 = new Vector3(0, 1, 0);
              return function translateY(distance) {
                return this.translateOnAxis(v1, distance);
              };
            }(),
            translateZ: function() {
              var v1 = new Vector3(0, 0, 1);
              return function translateZ(distance) {
                return this.translateOnAxis(v1, distance);
              };
            }(),
            localToWorld: function(vector) {
              return vector.applyMatrix4(this.matrixWorld);
            },
            worldToLocal: function() {
              var m1 = new Matrix4();
              return function worldToLocal(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
              };
            }(),
            lookAt: function() {
              var m1 = new Matrix4();
              return function lookAt(vector) {
                m1.lookAt(vector, this.position, this.up);
                this.quaternion.setFromRotationMatrix(m1);
              };
            }(),
            add: function(object) {
              if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                  this.add(arguments[i]);
                }
                return this;
              }
              if (object === this) {
                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
              }
              if (object && object.isObject3D) {
                if (object.parent !== null) {
                  object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({ type: "added" });
                this.children.push(object);
              } else {
                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
              }
              return this;
            },
            remove: function(object) {
              if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                  this.remove(arguments[i]);
                }
              }
              var index = this.children.indexOf(object);
              if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({ type: "removed" });
                this.children.splice(index, 1);
              }
            },
            getObjectById: function(id) {
              return this.getObjectByProperty("id", id);
            },
            getObjectByName: function(name) {
              return this.getObjectByProperty("name", name);
            },
            getObjectByProperty: function(name, value) {
              if (this[name] === value)
                return this;
              for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== void 0) {
                  return object;
                }
              }
              return void 0;
            },
            getWorldPosition: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              this.updateMatrixWorld(true);
              return result.setFromMatrixPosition(this.matrixWorld);
            },
            getWorldQuaternion: function() {
              var position = new Vector3();
              var scale = new Vector3();
              return function getWorldQuaternion(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, result, scale);
                return result;
              };
            }(),
            getWorldRotation: function() {
              var quaternion = new Quaternion();
              return function getWorldRotation(optionalTarget) {
                var result = optionalTarget || new Euler();
                this.getWorldQuaternion(quaternion);
                return result.setFromQuaternion(quaternion, this.rotation.order, false);
              };
            }(),
            getWorldScale: function() {
              var position = new Vector3();
              var quaternion = new Quaternion();
              return function getWorldScale(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, quaternion, result);
                return result;
              };
            }(),
            getWorldDirection: function() {
              var quaternion = new Quaternion();
              return function getWorldDirection(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.getWorldQuaternion(quaternion);
                return result.set(0, 0, 1).applyQuaternion(quaternion);
              };
            }(),
            raycast: function() {
            },
            traverse: function(callback) {
              callback(this);
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
              }
            },
            traverseVisible: function(callback) {
              if (this.visible === false)
                return;
              callback(this);
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
              }
            },
            traverseAncestors: function(callback) {
              var parent = this.parent;
              if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
              }
            },
            updateMatrix: function() {
              this.matrix.compose(this.position, this.quaternion, this.scale);
              this.matrixWorldNeedsUpdate = true;
            },
            updateMatrixWorld: function(force) {
              if (this.matrixAutoUpdate === true)
                this.updateMatrix();
              if (this.matrixWorldNeedsUpdate === true || force === true) {
                if (this.parent === null) {
                  this.matrixWorld.copy(this.matrix);
                } else {
                  this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
              }
              var children = this.children;
              for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(force);
              }
            },
            toJSON: function(meta) {
              var isRootObject = meta === void 0 || meta === "";
              var output = {};
              if (isRootObject) {
                meta = {
                  geometries: {},
                  materials: {},
                  textures: {},
                  images: {}
                };
                output.metadata = {
                  version: 4.4,
                  type: "Object",
                  generator: "Object3D.toJSON"
                };
              }
              var object = {};
              object.uuid = this.uuid;
              object.type = this.type;
              if (this.name !== "")
                object.name = this.name;
              if (JSON.stringify(this.userData) !== "{}")
                object.userData = this.userData;
              if (this.castShadow === true)
                object.castShadow = true;
              if (this.receiveShadow === true)
                object.receiveShadow = true;
              if (this.visible === false)
                object.visible = false;
              object.matrix = this.matrix.toArray();
              if (this.geometry !== void 0) {
                if (meta.geometries[this.geometry.uuid] === void 0) {
                  meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
                }
                object.geometry = this.geometry.uuid;
              }
              if (this.material !== void 0) {
                if (meta.materials[this.material.uuid] === void 0) {
                  meta.materials[this.material.uuid] = this.material.toJSON(meta);
                }
                object.material = this.material.uuid;
              }
              if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                  object.children.push(this.children[i].toJSON(meta).object);
                }
              }
              if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (geometries.length > 0)
                  output.geometries = geometries;
                if (materials.length > 0)
                  output.materials = materials;
                if (textures.length > 0)
                  output.textures = textures;
                if (images.length > 0)
                  output.images = images;
              }
              output.object = object;
              return output;
              function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                  var data = cache[key];
                  delete data.metadata;
                  values.push(data);
                }
                return values;
              }
            },
            clone: function(recursive) {
              return new this.constructor().copy(this, recursive);
            },
            copy: function(source, recursive) {
              if (recursive === void 0)
                recursive = true;
              this.name = source.name;
              this.up.copy(source.up);
              this.position.copy(source.position);
              this.quaternion.copy(source.quaternion);
              this.scale.copy(source.scale);
              this.matrix.copy(source.matrix);
              this.matrixWorld.copy(source.matrixWorld);
              this.matrixAutoUpdate = source.matrixAutoUpdate;
              this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
              this.visible = source.visible;
              this.castShadow = source.castShadow;
              this.receiveShadow = source.receiveShadow;
              this.frustumCulled = source.frustumCulled;
              this.renderOrder = source.renderOrder;
              this.userData = JSON.parse(JSON.stringify(source.userData));
              if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                  var child = source.children[i];
                  this.add(child.clone());
                }
              }
              return this;
            }
          });
          var count$2 = 0;
          function Object3DIdCount() {
            return count$2++;
          }
          function Line3(start, end) {
            this.start = start !== void 0 ? start : new Vector3();
            this.end = end !== void 0 ? end : new Vector3();
          }
          Line3.prototype = {
            constructor: Line3,
            set: function(start, end) {
              this.start.copy(start);
              this.end.copy(end);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(line) {
              this.start.copy(line.start);
              this.end.copy(line.end);
              return this;
            },
            getCenter: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.addVectors(this.start, this.end).multiplyScalar(0.5);
            },
            delta: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.subVectors(this.end, this.start);
            },
            distanceSq: function() {
              return this.start.distanceToSquared(this.end);
            },
            distance: function() {
              return this.start.distanceTo(this.end);
            },
            at: function(t, optionalTarget) {
              var result = optionalTarget || new Vector3();
              return this.delta(result).multiplyScalar(t).add(this.start);
            },
            closestPointToPointParameter: function() {
              var startP = new Vector3();
              var startEnd = new Vector3();
              return function closestPointToPointParameter(point, clampToLine) {
                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);
                var t = startEnd_startP / startEnd2;
                if (clampToLine) {
                  t = _Math.clamp(t, 0, 1);
                }
                return t;
              };
            }(),
            closestPointToPoint: function(point, clampToLine, optionalTarget) {
              var t = this.closestPointToPointParameter(point, clampToLine);
              var result = optionalTarget || new Vector3();
              return this.delta(result).multiplyScalar(t).add(this.start);
            },
            applyMatrix4: function(matrix) {
              this.start.applyMatrix4(matrix);
              this.end.applyMatrix4(matrix);
              return this;
            },
            equals: function(line) {
              return line.start.equals(this.start) && line.end.equals(this.end);
            }
          };
          function Triangle(a, b, c) {
            this.a = a !== void 0 ? a : new Vector3();
            this.b = b !== void 0 ? b : new Vector3();
            this.c = c !== void 0 ? c : new Vector3();
          }
          Triangle.normal = function() {
            var v0 = new Vector3();
            return function normal(a, b, c, optionalTarget) {
              var result = optionalTarget || new Vector3();
              result.subVectors(c, b);
              v0.subVectors(a, b);
              result.cross(v0);
              var resultLengthSq = result.lengthSq();
              if (resultLengthSq > 0) {
                return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
              }
              return result.set(0, 0, 0);
            };
          }();
          Triangle.barycoordFromPoint = function() {
            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function barycoordFromPoint(point, a, b, c, optionalTarget) {
              v0.subVectors(c, a);
              v1.subVectors(b, a);
              v2.subVectors(point, a);
              var dot00 = v0.dot(v0);
              var dot01 = v0.dot(v1);
              var dot02 = v0.dot(v2);
              var dot11 = v1.dot(v1);
              var dot12 = v1.dot(v2);
              var denom = dot00 * dot11 - dot01 * dot01;
              var result = optionalTarget || new Vector3();
              if (denom === 0) {
                return result.set(-2, -1, -1);
              }
              var invDenom = 1 / denom;
              var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
              var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
              return result.set(1 - u - v, v, u);
            };
          }();
          Triangle.containsPoint = function() {
            var v1 = new Vector3();
            return function containsPoint(point, a, b, c) {
              var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
              return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
            };
          }();
          Triangle.prototype = {
            constructor: Triangle,
            set: function(a, b, c) {
              this.a.copy(a);
              this.b.copy(b);
              this.c.copy(c);
              return this;
            },
            setFromPointsAndIndices: function(points, i0, i1, i2) {
              this.a.copy(points[i0]);
              this.b.copy(points[i1]);
              this.c.copy(points[i2]);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(triangle) {
              this.a.copy(triangle.a);
              this.b.copy(triangle.b);
              this.c.copy(triangle.c);
              return this;
            },
            area: function() {
              var v0 = new Vector3();
              var v1 = new Vector3();
              return function area() {
                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);
                return v0.cross(v1).length() * 0.5;
              };
            }(),
            midpoint: function(optionalTarget) {
              var result = optionalTarget || new Vector3();
              return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
            },
            normal: function(optionalTarget) {
              return Triangle.normal(this.a, this.b, this.c, optionalTarget);
            },
            plane: function(optionalTarget) {
              var result = optionalTarget || new Plane();
              return result.setFromCoplanarPoints(this.a, this.b, this.c);
            },
            barycoordFromPoint: function(point, optionalTarget) {
              return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
            },
            containsPoint: function(point) {
              return Triangle.containsPoint(point, this.a, this.b, this.c);
            },
            closestPointToPoint: /* @__PURE__ */ function() {
              var plane, edgeList, projectedPoint, closestPoint;
              return function closestPointToPoint(point, optionalTarget) {
                if (plane === void 0) {
                  plane = new Plane();
                  edgeList = [new Line3(), new Line3(), new Line3()];
                  projectedPoint = new Vector3();
                  closestPoint = new Vector3();
                }
                var result = optionalTarget || new Vector3();
                var minDistance = Infinity;
                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);
                if (this.containsPoint(projectedPoint) === true) {
                  result.copy(projectedPoint);
                } else {
                  edgeList[0].set(this.a, this.b);
                  edgeList[1].set(this.b, this.c);
                  edgeList[2].set(this.c, this.a);
                  for (var i = 0; i < edgeList.length; i++) {
                    edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                    var distance = projectedPoint.distanceToSquared(closestPoint);
                    if (distance < minDistance) {
                      minDistance = distance;
                      result.copy(closestPoint);
                    }
                  }
                }
                return result;
              };
            }(),
            equals: function(triangle) {
              return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
            }
          };
          function Face3(a, b, c, normal, color, materialIndex) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal && normal.isVector3 ? normal : new Vector3();
            this.vertexNormals = Array.isArray(normal) ? normal : [];
            this.color = color && color.isColor ? color : new Color();
            this.vertexColors = Array.isArray(color) ? color : [];
            this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
          }
          Face3.prototype = {
            constructor: Face3,
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(source) {
              this.a = source.a;
              this.b = source.b;
              this.c = source.c;
              this.normal.copy(source.normal);
              this.color.copy(source.color);
              this.materialIndex = source.materialIndex;
              for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
              }
              for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
              }
              return this;
            }
          };
          function MeshBasicMaterial(parameters) {
            Material.call(this);
            this.type = "MeshBasicMaterial";
            this.color = new Color(16777215);
            this.map = null;
            this.aoMap = null;
            this.aoMapIntensity = 1;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = "round";
            this.wireframeLinejoin = "round";
            this.skinning = false;
            this.morphTargets = false;
            this.lights = false;
            this.setValues(parameters);
          }
          MeshBasicMaterial.prototype = Object.create(Material.prototype);
          MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
          MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
          MeshBasicMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            return this;
          };
          function BufferAttribute(array, itemSize, normalized) {
            if (Array.isArray(array)) {
              throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            }
            this.uuid = _Math.generateUUID();
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== void 0 ? array.length / itemSize : 0;
            this.normalized = normalized === true;
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
          }
          BufferAttribute.prototype = {
            constructor: BufferAttribute,
            isBufferAttribute: true,
            set needsUpdate(value) {
              if (value === true)
                this.version++;
            },
            setArray: function(array) {
              if (Array.isArray(array)) {
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
              }
              this.count = array !== void 0 ? array.length / this.itemSize : 0;
              this.array = array;
            },
            setDynamic: function(value) {
              this.dynamic = value;
              return this;
            },
            copy: function(source) {
              this.array = new source.array.constructor(source.array);
              this.itemSize = source.itemSize;
              this.count = source.count;
              this.normalized = source.normalized;
              this.dynamic = source.dynamic;
              return this;
            },
            copyAt: function(index1, attribute, index2) {
              index1 *= this.itemSize;
              index2 *= attribute.itemSize;
              for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
              }
              return this;
            },
            copyArray: function(array) {
              this.array.set(array);
              return this;
            },
            copyColorsArray: function(colors) {
              var array = this.array, offset = 0;
              for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                if (color === void 0) {
                  console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
                  color = new Color();
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
              }
              return this;
            },
            copyIndicesArray: function(indices) {
              var array = this.array, offset = 0;
              for (var i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a;
                array[offset++] = index.b;
                array[offset++] = index.c;
              }
              return this;
            },
            copyVector2sArray: function(vectors) {
              var array = this.array, offset = 0;
              for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === void 0) {
                  console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
                  vector = new Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
              }
              return this;
            },
            copyVector3sArray: function(vectors) {
              var array = this.array, offset = 0;
              for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === void 0) {
                  console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
                  vector = new Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
              }
              return this;
            },
            copyVector4sArray: function(vectors) {
              var array = this.array, offset = 0;
              for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === void 0) {
                  console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
                  vector = new Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
              }
              return this;
            },
            set: function(value, offset) {
              if (offset === void 0)
                offset = 0;
              this.array.set(value, offset);
              return this;
            },
            getX: function(index) {
              return this.array[index * this.itemSize];
            },
            setX: function(index, x) {
              this.array[index * this.itemSize] = x;
              return this;
            },
            getY: function(index) {
              return this.array[index * this.itemSize + 1];
            },
            setY: function(index, y) {
              this.array[index * this.itemSize + 1] = y;
              return this;
            },
            getZ: function(index) {
              return this.array[index * this.itemSize + 2];
            },
            setZ: function(index, z) {
              this.array[index * this.itemSize + 2] = z;
              return this;
            },
            getW: function(index) {
              return this.array[index * this.itemSize + 3];
            },
            setW: function(index, w) {
              this.array[index * this.itemSize + 3] = w;
              return this;
            },
            setXY: function(index, x, y) {
              index *= this.itemSize;
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              return this;
            },
            setXYZ: function(index, x, y, z) {
              index *= this.itemSize;
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              this.array[index + 2] = z;
              return this;
            },
            setXYZW: function(index, x, y, z, w) {
              index *= this.itemSize;
              this.array[index + 0] = x;
              this.array[index + 1] = y;
              this.array[index + 2] = z;
              this.array[index + 3] = w;
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            }
          };
          function Int8Attribute(array, itemSize) {
            return new BufferAttribute(new Int8Array(array), itemSize);
          }
          function Uint8Attribute(array, itemSize) {
            return new BufferAttribute(new Uint8Array(array), itemSize);
          }
          function Uint8ClampedAttribute(array, itemSize) {
            return new BufferAttribute(new Uint8ClampedArray(array), itemSize);
          }
          function Int16Attribute(array, itemSize) {
            return new BufferAttribute(new Int16Array(array), itemSize);
          }
          function Uint16Attribute(array, itemSize) {
            return new BufferAttribute(new Uint16Array(array), itemSize);
          }
          function Int32Attribute(array, itemSize) {
            return new BufferAttribute(new Int32Array(array), itemSize);
          }
          function Uint32Attribute(array, itemSize) {
            return new BufferAttribute(new Uint32Array(array), itemSize);
          }
          function Float32Attribute(array, itemSize) {
            return new BufferAttribute(new Float32Array(array), itemSize);
          }
          function Float64Attribute(array, itemSize) {
            return new BufferAttribute(new Float64Array(array), itemSize);
          }
          function DynamicBufferAttribute(array, itemSize) {
            console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
            return new BufferAttribute(array, itemSize).setDynamic(true);
          }
          function Geometry() {
            Object.defineProperty(this, "id", { value: GeometryIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.type = "Geometry";
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
          }
          Object.assign(Geometry.prototype, EventDispatcher.prototype, {
            isGeometry: true,
            applyMatrix: function(matrix) {
              var normalMatrix = new Matrix3().getNormalMatrix(matrix);
              for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
              }
              for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                  face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
              }
              if (this.boundingBox !== null) {
                this.computeBoundingBox();
              }
              if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
              }
              this.verticesNeedUpdate = true;
              this.normalsNeedUpdate = true;
              return this;
            },
            rotateX: /* @__PURE__ */ function() {
              var m1;
              return function rotateX(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            rotateY: /* @__PURE__ */ function() {
              var m1;
              return function rotateY(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            rotateZ: /* @__PURE__ */ function() {
              var m1;
              return function rotateZ(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            translate: /* @__PURE__ */ function() {
              var m1;
              return function translate(x, y, z) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            scale: /* @__PURE__ */ function() {
              var m1;
              return function scale(x, y, z) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            lookAt: /* @__PURE__ */ function() {
              var obj;
              return function lookAt(vector) {
                if (obj === void 0)
                  obj = new Object3D();
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
              };
            }(),
            fromBufferGeometry: function(geometry) {
              var scope = this;
              var indices = geometry.index !== null ? geometry.index.array : void 0;
              var attributes = geometry.attributes;
              var positions = attributes.position.array;
              var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
              var colors = attributes.color !== void 0 ? attributes.color.array : void 0;
              var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
              var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
              if (uvs2 !== void 0)
                this.faceVertexUvs[1] = [];
              var tempNormals = [];
              var tempUVs = [];
              var tempUVs2 = [];
              for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== void 0) {
                  tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== void 0) {
                  scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== void 0) {
                  tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== void 0) {
                  tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
                }
              }
              function addFace(a, b, c, materialIndex) {
                var vertexNormals = normals !== void 0 ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== void 0 ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== void 0) {
                  scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }
                if (uvs2 !== void 0) {
                  scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
              }
              if (indices !== void 0) {
                var groups = geometry.groups;
                if (groups.length > 0) {
                  for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count2 = group.count;
                    for (var j = start, jl = start + count2; j < jl; j += 3) {
                      addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                    }
                  }
                } else {
                  for (var i = 0; i < indices.length; i += 3) {
                    addFace(indices[i], indices[i + 1], indices[i + 2]);
                  }
                }
              } else {
                for (var i = 0; i < positions.length / 3; i += 3) {
                  addFace(i, i + 1, i + 2);
                }
              }
              this.computeFaceNormals();
              if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
              }
              if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
              }
              return this;
            },
            center: function() {
              this.computeBoundingBox();
              var offset = this.boundingBox.getCenter().negate();
              this.translate(offset.x, offset.y, offset.z);
              return offset;
            },
            normalize: function() {
              this.computeBoundingSphere();
              var center = this.boundingSphere.center;
              var radius = this.boundingSphere.radius;
              var s = radius === 0 ? 1 : 1 / radius;
              var matrix = new Matrix4();
              matrix.set(
                s,
                0,
                0,
                -s * center.x,
                0,
                s,
                0,
                -s * center.y,
                0,
                0,
                s,
                -s * center.z,
                0,
                0,
                0,
                1
              );
              this.applyMatrix(matrix);
              return this;
            },
            computeFaceNormals: function() {
              var cb = new Vector3(), ab = new Vector3();
              for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
              }
            },
            computeVertexNormals: function(areaWeighted) {
              if (areaWeighted === void 0)
                areaWeighted = true;
              var v, vl, f, fl, face, vertices;
              vertices = new Array(this.vertices.length);
              for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new Vector3();
              }
              if (areaWeighted) {
                var vA, vB, vC;
                var cb = new Vector3(), ab = new Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                  face = this.faces[f];
                  vA = this.vertices[face.a];
                  vB = this.vertices[face.b];
                  vC = this.vertices[face.c];
                  cb.subVectors(vC, vB);
                  ab.subVectors(vA, vB);
                  cb.cross(ab);
                  vertices[face.a].add(cb);
                  vertices[face.b].add(cb);
                  vertices[face.c].add(cb);
                }
              } else {
                this.computeFaceNormals();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                  face = this.faces[f];
                  vertices[face.a].add(face.normal);
                  vertices[face.b].add(face.normal);
                  vertices[face.c].add(face.normal);
                }
              }
              for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
              }
              for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                  vertexNormals[0].copy(vertices[face.a]);
                  vertexNormals[1].copy(vertices[face.b]);
                  vertexNormals[2].copy(vertices[face.c]);
                } else {
                  vertexNormals[0] = vertices[face.a].clone();
                  vertexNormals[1] = vertices[face.b].clone();
                  vertexNormals[2] = vertices[face.c].clone();
                }
              }
              if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
              }
            },
            computeFlatVertexNormals: function() {
              var f, fl, face;
              this.computeFaceNormals();
              for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                  vertexNormals[0].copy(face.normal);
                  vertexNormals[1].copy(face.normal);
                  vertexNormals[2].copy(face.normal);
                } else {
                  vertexNormals[0] = face.normal.clone();
                  vertexNormals[1] = face.normal.clone();
                  vertexNormals[2] = face.normal.clone();
                }
              }
              if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
              }
            },
            computeMorphNormals: function() {
              var i, il, f, fl, face;
              for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                  face.__originalFaceNormal = face.normal.clone();
                } else {
                  face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals)
                  face.__originalVertexNormals = [];
                for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                  if (!face.__originalVertexNormals[i]) {
                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                  } else {
                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                  }
                }
              }
              var tmpGeo = new Geometry();
              tmpGeo.faces = this.faces;
              for (i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                  this.morphNormals[i] = {};
                  this.morphNormals[i].faceNormals = [];
                  this.morphNormals[i].vertexNormals = [];
                  var dstNormalsFace = this.morphNormals[i].faceNormals;
                  var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                  var faceNormal, vertexNormals;
                  for (f = 0, fl = this.faces.length; f < fl; f++) {
                    faceNormal = new Vector3();
                    vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                  }
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                  face = this.faces[f];
                  faceNormal = morphNormals.faceNormals[f];
                  vertexNormals = morphNormals.vertexNormals[f];
                  faceNormal.copy(face.normal);
                  vertexNormals.a.copy(face.vertexNormals[0]);
                  vertexNormals.b.copy(face.vertexNormals[1]);
                  vertexNormals.c.copy(face.vertexNormals[2]);
                }
              }
              for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
              }
            },
            computeTangents: function() {
              console.warn("THREE.Geometry: .computeTangents() has been removed.");
            },
            computeLineDistances: function() {
              var d = 0;
              var vertices = this.vertices;
              for (var i = 0, il = vertices.length; i < il; i++) {
                if (i > 0) {
                  d += vertices[i].distanceTo(vertices[i - 1]);
                }
                this.lineDistances[i] = d;
              }
            },
            computeBoundingBox: function() {
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              this.boundingBox.setFromPoints(this.vertices);
            },
            computeBoundingSphere: function() {
              if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
              }
              this.boundingSphere.setFromPoints(this.vertices);
            },
            merge: function(geometry, matrix, materialIndexOffset) {
              if ((geometry && geometry.isGeometry) === false) {
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
                return;
              }
              var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
              if (materialIndexOffset === void 0)
                materialIndexOffset = 0;
              if (matrix !== void 0) {
                normalMatrix = new Matrix3().getNormalMatrix(matrix);
              }
              for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== void 0)
                  vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
              }
              for (var i = 0, il = colors2.length; i < il; i++) {
                colors1.push(colors2[i].clone());
              }
              for (i = 0, il = faces2.length; i < il; i++) {
                var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== void 0) {
                  faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                  normal = faceVertexNormals[j].clone();
                  if (normalMatrix !== void 0) {
                    normal.applyMatrix3(normalMatrix).normalize();
                  }
                  faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                  color = faceVertexColors[j];
                  faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
              }
              for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (uv === void 0) {
                  continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                  uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
              }
            },
            mergeMesh: function(mesh) {
              if ((mesh && mesh.isMesh) === false) {
                console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
                return;
              }
              mesh.matrixAutoUpdate && mesh.updateMatrix();
              this.merge(mesh.geometry, mesh.matrix);
            },
            /*
             * Checks for duplicate vertices with hashmap.
             * Duplicated vertices are removed
             * and faces' vertices are updated.
             */
            mergeVertices: function() {
              var verticesMap = {};
              var unique = [], changes = [];
              var v, key;
              var precisionPoints = 4;
              var precision = Math.pow(10, precisionPoints);
              var i, il, face;
              var indices, j, jl;
              for (i = 0, il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
                if (verticesMap[key] === void 0) {
                  verticesMap[key] = i;
                  unique.push(this.vertices[i]);
                  changes[i] = unique.length - 1;
                } else {
                  changes[i] = changes[verticesMap[key]];
                }
              }
              var faceIndicesToRemove = [];
              for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                var dupIndex = -1;
                for (var n = 0; n < 3; n++) {
                  if (indices[n] === indices[(n + 1) % 3]) {
                    dupIndex = n;
                    faceIndicesToRemove.push(i);
                    break;
                  }
                }
              }
              for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                  this.faceVertexUvs[j].splice(idx, 1);
                }
              }
              var diff = this.vertices.length - unique.length;
              this.vertices = unique;
              return diff;
            },
            sortFacesByMaterialIndex: function() {
              var faces = this.faces;
              var length = faces.length;
              for (var i = 0; i < length; i++) {
                faces[i]._id = i;
              }
              function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
              }
              faces.sort(materialIndexSort);
              var uvs1 = this.faceVertexUvs[0];
              var uvs2 = this.faceVertexUvs[1];
              var newUvs1, newUvs2;
              if (uvs1 && uvs1.length === length)
                newUvs1 = [];
              if (uvs2 && uvs2.length === length)
                newUvs2 = [];
              for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1)
                  newUvs1.push(uvs1[id]);
                if (newUvs2)
                  newUvs2.push(uvs2[id]);
              }
              if (newUvs1)
                this.faceVertexUvs[0] = newUvs1;
              if (newUvs2)
                this.faceVertexUvs[1] = newUvs2;
            },
            toJSON: function() {
              var data = {
                metadata: {
                  version: 4.4,
                  type: "Geometry",
                  generator: "Geometry.toJSON"
                }
              };
              data.uuid = this.uuid;
              data.type = this.type;
              if (this.name !== "")
                data.name = this.name;
              if (this.parameters !== void 0) {
                var parameters = this.parameters;
                for (var key in parameters) {
                  if (parameters[key] !== void 0)
                    data[key] = parameters[key];
                }
                return data;
              }
              var vertices = [];
              for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
              }
              var faces = [];
              var normals = [];
              var normalsHash = {};
              var colors = [];
              var colorsHash = {};
              var uvs = [];
              var uvsHash = {};
              for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false;
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, 0);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                  var faceVertexUvs = this.faceVertexUvs[0][i];
                  faces.push(
                    getUvIndex(faceVertexUvs[0]),
                    getUvIndex(faceVertexUvs[1]),
                    getUvIndex(faceVertexUvs[2])
                  );
                }
                if (hasFaceNormal) {
                  faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                  var vertexNormals = face.vertexNormals;
                  faces.push(
                    getNormalIndex(vertexNormals[0]),
                    getNormalIndex(vertexNormals[1]),
                    getNormalIndex(vertexNormals[2])
                  );
                }
                if (hasFaceColor) {
                  faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                  var vertexColors = face.vertexColors;
                  faces.push(
                    getColorIndex(vertexColors[0]),
                    getColorIndex(vertexColors[1]),
                    getColorIndex(vertexColors[2])
                  );
                }
              }
              function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
              }
              function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== void 0) {
                  return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
              }
              function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== void 0) {
                  return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
              }
              function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== void 0) {
                  return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
              }
              data.data = {};
              data.data.vertices = vertices;
              data.data.normals = normals;
              if (colors.length > 0)
                data.data.colors = colors;
              if (uvs.length > 0)
                data.data.uvs = [uvs];
              data.data.faces = faces;
              return data;
            },
            clone: function() {
              return new Geometry().copy(this);
            },
            copy: function(source) {
              this.vertices = [];
              this.faces = [];
              this.faceVertexUvs = [[]];
              this.colors = [];
              var vertices = source.vertices;
              for (var i = 0, il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
              }
              var colors = source.colors;
              for (var i = 0, il = colors.length; i < il; i++) {
                this.colors.push(colors[i].clone());
              }
              var faces = source.faces;
              for (var i = 0, il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
              }
              for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === void 0) {
                  this.faceVertexUvs[i] = [];
                }
                for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                  var uvs = faceVertexUvs[j], uvsCopy = [];
                  for (var k = 0, kl = uvs.length; k < kl; k++) {
                    var uv = uvs[k];
                    uvsCopy.push(uv.clone());
                  }
                  this.faceVertexUvs[i].push(uvsCopy);
                }
              }
              return this;
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            }
          });
          var count$3 = 0;
          function GeometryIdCount() {
            return count$3++;
          }
          function DirectGeometry() {
            Object.defineProperty(this, "id", { value: GeometryIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.type = "DirectGeometry";
            this.indices = [];
            this.vertices = [];
            this.normals = [];
            this.colors = [];
            this.uvs = [];
            this.uvs2 = [];
            this.groups = [];
            this.morphTargets = {};
            this.skinWeights = [];
            this.skinIndices = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.verticesNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.groupsNeedUpdate = false;
          }
          Object.assign(DirectGeometry.prototype, EventDispatcher.prototype, {
            computeBoundingBox: Geometry.prototype.computeBoundingBox,
            computeBoundingSphere: Geometry.prototype.computeBoundingSphere,
            computeFaceNormals: function() {
              console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.");
            },
            computeVertexNormals: function() {
              console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.");
            },
            computeGroups: function(geometry) {
              var group;
              var groups = [];
              var materialIndex;
              var faces = geometry.faces;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.materialIndex !== materialIndex) {
                  materialIndex = face.materialIndex;
                  if (group !== void 0) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                  }
                  group = {
                    start: i * 3,
                    materialIndex
                  };
                }
              }
              if (group !== void 0) {
                group.count = i * 3 - group.start;
                groups.push(group);
              }
              this.groups = groups;
            },
            fromGeometry: function(geometry) {
              var faces = geometry.faces;
              var vertices = geometry.vertices;
              var faceVertexUvs = geometry.faceVertexUvs;
              var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
              var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
              var morphTargets = geometry.morphTargets;
              var morphTargetsLength = morphTargets.length;
              var morphTargetsPosition;
              if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                  morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
              }
              var morphNormals = geometry.morphNormals;
              var morphNormalsLength = morphNormals.length;
              var morphTargetsNormal;
              if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                  morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
              }
              var skinIndices = geometry.skinIndices;
              var skinWeights = geometry.skinWeights;
              var hasSkinIndices = skinIndices.length === vertices.length;
              var hasSkinWeights = skinWeights.length === vertices.length;
              for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                  this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                } else {
                  var normal = face.normal;
                  this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                  this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                } else {
                  var color = face.color;
                  this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                  var vertexUvs = faceVertexUvs[0][i];
                  if (vertexUvs !== void 0) {
                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                  } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                  }
                }
                if (hasFaceVertexUv2 === true) {
                  var vertexUvs = faceVertexUvs[1][i];
                  if (vertexUvs !== void 0) {
                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                  } else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                  }
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                  var morphTarget = morphTargets[j].vertices;
                  morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                  var morphNormal = morphNormals[j].vertexNormals[i];
                  morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                if (hasSkinIndices) {
                  this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                  this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
              }
              this.computeGroups(geometry);
              this.verticesNeedUpdate = geometry.verticesNeedUpdate;
              this.normalsNeedUpdate = geometry.normalsNeedUpdate;
              this.colorsNeedUpdate = geometry.colorsNeedUpdate;
              this.uvsNeedUpdate = geometry.uvsNeedUpdate;
              this.groupsNeedUpdate = geometry.groupsNeedUpdate;
              return this;
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            }
          });
          function BufferGeometry() {
            Object.defineProperty(this, "id", { value: GeometryIdCount() });
            this.uuid = _Math.generateUUID();
            this.name = "";
            this.type = "BufferGeometry";
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.drawRange = { start: 0, count: Infinity };
          }
          Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
            isBufferGeometry: true,
            getIndex: function() {
              return this.index;
            },
            setIndex: function(index) {
              this.index = index;
            },
            addAttribute: function(name, attribute) {
              if ((attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false) {
                console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
                this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                return;
              }
              if (name === "index") {
                console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
                this.setIndex(attribute);
                return;
              }
              this.attributes[name] = attribute;
              return this;
            },
            getAttribute: function(name) {
              return this.attributes[name];
            },
            removeAttribute: function(name) {
              delete this.attributes[name];
              return this;
            },
            addGroup: function(start, count2, materialIndex) {
              this.groups.push({
                start,
                count: count2,
                materialIndex: materialIndex !== void 0 ? materialIndex : 0
              });
            },
            clearGroups: function() {
              this.groups = [];
            },
            setDrawRange: function(start, count2) {
              this.drawRange.start = start;
              this.drawRange.count = count2;
            },
            applyMatrix: function(matrix) {
              var position = this.attributes.position;
              if (position !== void 0) {
                matrix.applyToVector3Array(position.array);
                position.needsUpdate = true;
              }
              var normal = this.attributes.normal;
              if (normal !== void 0) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToVector3Array(normal.array);
                normal.needsUpdate = true;
              }
              if (this.boundingBox !== null) {
                this.computeBoundingBox();
              }
              if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
              }
              return this;
            },
            rotateX: /* @__PURE__ */ function() {
              var m1;
              return function rotateX(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            rotateY: /* @__PURE__ */ function() {
              var m1;
              return function rotateY(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            rotateZ: /* @__PURE__ */ function() {
              var m1;
              return function rotateZ(angle) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            translate: /* @__PURE__ */ function() {
              var m1;
              return function translate(x, y, z) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            scale: /* @__PURE__ */ function() {
              var m1;
              return function scale(x, y, z) {
                if (m1 === void 0)
                  m1 = new Matrix4();
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
              };
            }(),
            lookAt: /* @__PURE__ */ function() {
              var obj;
              return function lookAt(vector) {
                if (obj === void 0)
                  obj = new Object3D();
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
              };
            }(),
            center: function() {
              this.computeBoundingBox();
              var offset = this.boundingBox.getCenter().negate();
              this.translate(offset.x, offset.y, offset.z);
              return offset;
            },
            setFromObject: function(object) {
              var geometry = object.geometry;
              if (object && object.isPoints || object && object.isLine) {
                var positions = new Float32Attribute(geometry.vertices.length * 3, 3);
                var colors = new Float32Attribute(geometry.colors.length * 3, 3);
                this.addAttribute("position", positions.copyVector3sArray(geometry.vertices));
                this.addAttribute("color", colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                  var lineDistances = new Float32Attribute(geometry.lineDistances.length, 1);
                  this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                  this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                  this.boundingBox = geometry.boundingBox.clone();
                }
              } else if (object && object.isMesh) {
                if (geometry && geometry.isGeometry) {
                  this.fromGeometry(geometry);
                }
              }
              return this;
            },
            updateFromObject: function(object) {
              var geometry = object.geometry;
              if (object && object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === true) {
                  direct = void 0;
                  geometry.elementsNeedUpdate = false;
                }
                if (direct === void 0) {
                  return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
              }
              var attribute;
              if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== void 0) {
                  attribute.copyVector3sArray(geometry.vertices);
                  attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
              }
              if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== void 0) {
                  attribute.copyVector3sArray(geometry.normals);
                  attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
              }
              if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== void 0) {
                  attribute.copyColorsArray(geometry.colors);
                  attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
              }
              if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== void 0) {
                  attribute.copyVector2sArray(geometry.uvs);
                  attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
              }
              if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== void 0) {
                  attribute.copyArray(geometry.lineDistances);
                  attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
              }
              if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
              }
              return this;
            },
            fromGeometry: function(geometry) {
              geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
              return this.fromDirectGeometry(geometry.__directGeometry);
            },
            fromDirectGeometry: function(geometry) {
              var positions = new Float32Array(geometry.vertices.length * 3);
              this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
              if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
              }
              if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
              }
              if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
              }
              if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
              }
              if (geometry.indices.length > 0) {
                var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
                var indices = new TypeArray(geometry.indices.length * 3);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
              }
              this.groups = geometry.groups;
              for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                  var morphTarget = morphTargets[i];
                  var attribute = new Float32Attribute(morphTarget.length * 3, 3);
                  array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
              }
              if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32Attribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
              }
              if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32Attribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
              }
              if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
              }
              if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
              }
              return this;
            },
            computeBoundingBox: function() {
              if (this.boundingBox === null) {
                this.boundingBox = new Box3();
              }
              var positions = this.attributes.position.array;
              if (positions !== void 0) {
                this.boundingBox.setFromArray(positions);
              } else {
                this.boundingBox.makeEmpty();
              }
              if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
              }
            },
            computeBoundingSphere: function() {
              var box = new Box3();
              var vector = new Vector3();
              return function computeBoundingSphere() {
                if (this.boundingSphere === null) {
                  this.boundingSphere = new Sphere();
                }
                var positions = this.attributes.position;
                if (positions) {
                  var array = positions.array;
                  var center = this.boundingSphere.center;
                  box.setFromArray(array);
                  box.getCenter(center);
                  var maxRadiusSq = 0;
                  for (var i = 0, il = array.length; i < il; i += 3) {
                    vector.fromArray(array, i);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                  }
                  this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                  if (isNaN(this.boundingSphere.radius)) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                  }
                }
              };
            }(),
            computeFaceNormals: function() {
            },
            computeVertexNormals: function() {
              var index = this.index;
              var attributes = this.attributes;
              var groups = this.groups;
              if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === void 0) {
                  this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
                } else {
                  var array = attributes.normal.array;
                  for (var i = 0, il = array.length; i < il; i++) {
                    array[i] = 0;
                  }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
                if (index) {
                  var indices = index.array;
                  if (groups.length === 0) {
                    this.addGroup(0, indices.length);
                  }
                  for (var j = 0, jl = groups.length; j < jl; ++j) {
                    var group = groups[j];
                    var start = group.start;
                    var count2 = group.count;
                    for (var i = start, il = start + count2; i < il; i += 3) {
                      vA = indices[i + 0] * 3;
                      vB = indices[i + 1] * 3;
                      vC = indices[i + 2] * 3;
                      pA.fromArray(positions, vA);
                      pB.fromArray(positions, vB);
                      pC.fromArray(positions, vC);
                      cb.subVectors(pC, pB);
                      ab.subVectors(pA, pB);
                      cb.cross(ab);
                      normals[vA] += cb.x;
                      normals[vA + 1] += cb.y;
                      normals[vA + 2] += cb.z;
                      normals[vB] += cb.x;
                      normals[vB + 1] += cb.y;
                      normals[vB + 2] += cb.z;
                      normals[vC] += cb.x;
                      normals[vC + 1] += cb.y;
                      normals[vC + 2] += cb.z;
                    }
                  }
                } else {
                  for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;
                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;
                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                  }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
              }
            },
            merge: function(geometry, offset) {
              if ((geometry && geometry.isBufferGeometry) === false) {
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
                return;
              }
              if (offset === void 0)
                offset = 0;
              var attributes = this.attributes;
              for (var key in attributes) {
                if (geometry.attributes[key] === void 0)
                  continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                  attributeArray1[j] = attributeArray2[i];
                }
              }
              return this;
            },
            normalizeNormals: function() {
              var normals = this.attributes.normal.array;
              var x, y, z, n;
              for (var i = 0, il = normals.length; i < il; i += 3) {
                x = normals[i];
                y = normals[i + 1];
                z = normals[i + 2];
                n = 1 / Math.sqrt(x * x + y * y + z * z);
                normals[i] *= n;
                normals[i + 1] *= n;
                normals[i + 2] *= n;
              }
            },
            toNonIndexed: function() {
              if (this.index === null) {
                console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
                return this;
              }
              var geometry2 = new BufferGeometry();
              var indices = this.index.array;
              var attributes = this.attributes;
              for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0, index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                  index = indices[i] * itemSize;
                  for (var j = 0; j < itemSize; j++) {
                    array2[index2++] = array[index++];
                  }
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
              }
              return geometry2;
            },
            toJSON: function() {
              var data = {
                metadata: {
                  version: 4.4,
                  type: "BufferGeometry",
                  generator: "BufferGeometry.toJSON"
                }
              };
              data.uuid = this.uuid;
              data.type = this.type;
              if (this.name !== "")
                data.name = this.name;
              if (this.parameters !== void 0) {
                var parameters = this.parameters;
                for (var key in parameters) {
                  if (parameters[key] !== void 0)
                    data[key] = parameters[key];
                }
                return data;
              }
              data.data = { attributes: {} };
              var index = this.index;
              if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                  type: index.array.constructor.name,
                  array
                };
              }
              var attributes = this.attributes;
              for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                  itemSize: attribute.itemSize,
                  type: attribute.array.constructor.name,
                  array,
                  normalized: attribute.normalized
                };
              }
              var groups = this.groups;
              if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
              }
              var boundingSphere = this.boundingSphere;
              if (boundingSphere !== null) {
                data.data.boundingSphere = {
                  center: boundingSphere.center.toArray(),
                  radius: boundingSphere.radius
                };
              }
              return data;
            },
            clone: function() {
              return new BufferGeometry().copy(this);
            },
            copy: function(source) {
              var index = source.index;
              if (index !== null) {
                this.setIndex(index.clone());
              }
              var attributes = source.attributes;
              for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
              }
              var groups = source.groups;
              for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
              }
              return this;
            },
            dispose: function() {
              this.dispatchEvent({ type: "dispose" });
            }
          });
          BufferGeometry.MaxIndex = 65535;
          function Mesh(geometry, material) {
            Object3D.call(this);
            this.type = "Mesh";
            this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
            this.material = material !== void 0 ? material : new MeshBasicMaterial({ color: Math.random() * 16777215 });
            this.drawMode = TrianglesDrawMode;
            this.updateMorphTargets();
          }
          Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Mesh,
            isMesh: true,
            setDrawMode: function(value) {
              this.drawMode = value;
            },
            copy: function(source) {
              Object3D.prototype.copy.call(this, source);
              this.drawMode = source.drawMode;
              return this;
            },
            updateMorphTargets: function() {
              var morphTargets = this.geometry.morphTargets;
              if (morphTargets !== void 0 && morphTargets.length > 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (var m = 0, ml = morphTargets.length; m < ml; m++) {
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[morphTargets[m].name] = m;
                }
              }
            },
            raycast: function() {
              var inverseMatrix = new Matrix4();
              var ray = new Ray();
              var sphere = new Sphere();
              var vA = new Vector3();
              var vB = new Vector3();
              var vC = new Vector3();
              var tempA = new Vector3();
              var tempB = new Vector3();
              var tempC = new Vector3();
              var uvA = new Vector2();
              var uvB = new Vector2();
              var uvC = new Vector2();
              var barycoord = new Vector3();
              var intersectionPoint = new Vector3();
              var intersectionPointWorld = new Vector3();
              function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);
                uv1.add(uv2).add(uv3);
                return uv1.clone();
              }
              function checkIntersection(object, raycaster, ray2, pA, pB, pC, point) {
                var intersect;
                var material = object.material;
                if (material.side === BackSide) {
                  intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
                } else {
                  intersect = ray2.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                }
                if (intersect === null)
                  return null;
                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                if (distance < raycaster.near || distance > raycaster.far)
                  return null;
                return {
                  distance,
                  point: intersectionPointWorld.clone(),
                  object
                };
              }
              function checkBufferGeometryIntersection(object, raycaster, ray2, positions, uvs, a, b, c) {
                vA.fromArray(positions, a * 3);
                vB.fromArray(positions, b * 3);
                vC.fromArray(positions, c * 3);
                var intersection = checkIntersection(object, raycaster, ray2, vA, vB, vC, intersectionPoint);
                if (intersection) {
                  if (uvs) {
                    uvA.fromArray(uvs, a * 2);
                    uvB.fromArray(uvs, b * 2);
                    uvC.fromArray(uvs, c * 2);
                    intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                  }
                  intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                  intersection.faceIndex = a;
                }
                return intersection;
              }
              return function raycast(raycaster, intersects) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if (material === void 0)
                  return;
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false)
                  return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                if (geometry.boundingBox !== null) {
                  if (ray.intersectsBox(geometry.boundingBox) === false)
                    return;
                }
                var uvs, intersection;
                if (geometry && geometry.isBufferGeometry) {
                  var a, b, c;
                  var index = geometry.index;
                  var attributes = geometry.attributes;
                  var positions = attributes.position.array;
                  if (attributes.uv !== void 0) {
                    uvs = attributes.uv.array;
                  }
                  if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length; i < l; i += 3) {
                      a = indices[i];
                      b = indices[i + 1];
                      c = indices[i + 2];
                      intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                      if (intersection) {
                        intersection.faceIndex = Math.floor(i / 3);
                        intersects.push(intersection);
                      }
                    }
                  } else {
                    for (var i = 0, l = positions.length; i < l; i += 9) {
                      a = i / 3;
                      b = a + 1;
                      c = a + 2;
                      intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                      if (intersection) {
                        intersection.index = a;
                        intersects.push(intersection);
                      }
                    }
                  }
                } else if (geometry && geometry.isGeometry) {
                  var fvA, fvB, fvC;
                  var isFaceMaterial = material && material.isMultiMaterial;
                  var materials = isFaceMaterial === true ? material.materials : null;
                  var vertices = geometry.vertices;
                  var faces = geometry.faces;
                  var faceVertexUvs = geometry.faceVertexUvs[0];
                  if (faceVertexUvs.length > 0)
                    uvs = faceVertexUvs;
                  for (var f = 0, fl = faces.length; f < fl; f++) {
                    var face = faces[f];
                    var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
                    if (faceMaterial === void 0)
                      continue;
                    fvA = vertices[face.a];
                    fvB = vertices[face.b];
                    fvC = vertices[face.c];
                    if (faceMaterial.morphTargets === true) {
                      var morphTargets = geometry.morphTargets;
                      var morphInfluences = this.morphTargetInfluences;
                      vA.set(0, 0, 0);
                      vB.set(0, 0, 0);
                      vC.set(0, 0, 0);
                      for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                        var influence = morphInfluences[t];
                        if (influence === 0)
                          continue;
                        var targets = morphTargets[t].vertices;
                        vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                        vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                        vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                      }
                      vA.add(fvA);
                      vB.add(fvB);
                      vC.add(fvC);
                      fvA = vA;
                      fvB = vB;
                      fvC = vC;
                    }
                    intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                    if (intersection) {
                      if (uvs) {
                        var uvs_f = uvs[f];
                        uvA.copy(uvs_f[0]);
                        uvB.copy(uvs_f[1]);
                        uvC.copy(uvs_f[2]);
                        intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                      }
                      intersection.face = face;
                      intersection.faceIndex = f;
                      intersects.push(intersection);
                    }
                  }
                }
              };
            }(),
            clone: function() {
              return new this.constructor(this.geometry, this.material).copy(this);
            }
          });
          function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
            BufferGeometry.call(this);
            this.type = "BoxBufferGeometry";
            this.parameters = {
              width,
              height,
              depth,
              widthSegments,
              heightSegments,
              depthSegments
            };
            var scope = this;
            widthSegments = Math.floor(widthSegments) || 1;
            heightSegments = Math.floor(heightSegments) || 1;
            depthSegments = Math.floor(depthSegments) || 1;
            var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
            var indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);
            var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
            var vertices = new Float32Array(vertexCount * 3);
            var normals = new Float32Array(vertexCount * 3);
            var uvs = new Float32Array(vertexCount * 2);
            var vertexBufferOffset = 0;
            var uvBufferOffset = 0;
            var indexBufferOffset = 0;
            var numberOfVertices = 0;
            var groupStart = 0;
            buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
            buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
            buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
            buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
            buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
            buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
            this.setIndex(new BufferAttribute(indices, 1));
            this.addAttribute("position", new BufferAttribute(vertices, 3));
            this.addAttribute("normal", new BufferAttribute(normals, 3));
            this.addAttribute("uv", new BufferAttribute(uvs, 2));
            function calculateVertexCount(w, h, d) {
              var vertices2 = 0;
              vertices2 += (w + 1) * (h + 1) * 2;
              vertices2 += (w + 1) * (d + 1) * 2;
              vertices2 += (d + 1) * (h + 1) * 2;
              return vertices2;
            }
            function calculateIndexCount(w, h, d) {
              var index = 0;
              index += w * h * 2;
              index += w * d * 2;
              index += d * h * 2;
              return index * 6;
            }
            function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
              var segmentWidth = width2 / gridX;
              var segmentHeight = height2 / gridY;
              var widthHalf = width2 / 2;
              var heightHalf = height2 / 2;
              var depthHalf = depth2 / 2;
              var gridX1 = gridX + 1;
              var gridY1 = gridY + 1;
              var vertexCounter = 0;
              var groupCount = 0;
              var vector = new Vector3();
              for (var iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (var ix = 0; ix < gridX1; ix++) {
                  var x = ix * segmentWidth - widthHalf;
                  vector[u] = x * udir;
                  vector[v] = y * vdir;
                  vector[w] = depthHalf;
                  vertices[vertexBufferOffset] = vector.x;
                  vertices[vertexBufferOffset + 1] = vector.y;
                  vertices[vertexBufferOffset + 2] = vector.z;
                  vector[u] = 0;
                  vector[v] = 0;
                  vector[w] = depth2 > 0 ? 1 : -1;
                  normals[vertexBufferOffset] = vector.x;
                  normals[vertexBufferOffset + 1] = vector.y;
                  normals[vertexBufferOffset + 2] = vector.z;
                  uvs[uvBufferOffset] = ix / gridX;
                  uvs[uvBufferOffset + 1] = 1 - iy / gridY;
                  vertexBufferOffset += 3;
                  uvBufferOffset += 2;
                  vertexCounter += 1;
                }
              }
              for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                  var a = numberOfVertices + ix + gridX1 * iy;
                  var b = numberOfVertices + ix + gridX1 * (iy + 1);
                  var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                  var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                  indices[indexBufferOffset] = a;
                  indices[indexBufferOffset + 1] = b;
                  indices[indexBufferOffset + 2] = d;
                  indices[indexBufferOffset + 3] = b;
                  indices[indexBufferOffset + 4] = c;
                  indices[indexBufferOffset + 5] = d;
                  indexBufferOffset += 6;
                  groupCount += 6;
                }
              }
              scope.addGroup(groupStart, groupCount, materialIndex);
              groupStart += groupCount;
              numberOfVertices += vertexCounter;
            }
          }
          BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
          function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
            BufferGeometry.call(this);
            this.type = "PlaneBufferGeometry";
            this.parameters = {
              width,
              height,
              widthSegments,
              heightSegments
            };
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor(widthSegments) || 1;
            var gridY = Math.floor(heightSegments) || 1;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY;
            var vertices = new Float32Array(gridX1 * gridY1 * 3);
            var normals = new Float32Array(gridX1 * gridY1 * 3);
            var uvs = new Float32Array(gridX1 * gridY1 * 2);
            var offset = 0;
            var offset2 = 0;
            for (var iy = 0; iy < gridY1; iy++) {
              var y = iy * segment_height - height_half;
              for (var ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices[offset] = x;
                vertices[offset + 1] = -y;
                normals[offset + 2] = 1;
                uvs[offset2] = ix / gridX;
                uvs[offset2 + 1] = 1 - iy / gridY;
                offset += 3;
                offset2 += 2;
              }
            }
            offset = 0;
            var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
            for (var iy = 0; iy < gridY; iy++) {
              for (var ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = ix + 1 + gridX1 * (iy + 1);
                var d = ix + 1 + gridX1 * iy;
                indices[offset] = a;
                indices[offset + 1] = b;
                indices[offset + 2] = d;
                indices[offset + 3] = b;
                indices[offset + 4] = c;
                indices[offset + 5] = d;
                offset += 6;
              }
            }
            this.setIndex(new BufferAttribute(indices, 1));
            this.addAttribute("position", new BufferAttribute(vertices, 3));
            this.addAttribute("normal", new BufferAttribute(normals, 3));
            this.addAttribute("uv", new BufferAttribute(uvs, 2));
          }
          PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
          function Camera() {
            Object3D.call(this);
            this.type = "Camera";
            this.matrixWorldInverse = new Matrix4();
            this.projectionMatrix = new Matrix4();
          }
          Camera.prototype = Object.create(Object3D.prototype);
          Camera.prototype.constructor = Camera;
          Camera.prototype.isCamera = true;
          Camera.prototype.getWorldDirection = function() {
            var quaternion = new Quaternion();
            return function getWorldDirection(optionalTarget) {
              var result = optionalTarget || new Vector3();
              this.getWorldQuaternion(quaternion);
              return result.set(0, 0, -1).applyQuaternion(quaternion);
            };
          }();
          Camera.prototype.lookAt = function() {
            var m1 = new Matrix4();
            return function lookAt(vector) {
              m1.lookAt(this.position, vector, this.up);
              this.quaternion.setFromRotationMatrix(m1);
            };
          }();
          Camera.prototype.clone = function() {
            return new this.constructor().copy(this);
          };
          Camera.prototype.copy = function(source) {
            Object3D.prototype.copy.call(this, source);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            return this;
          };
          function PerspectiveCamera(fov, aspect, near, far) {
            Camera.call(this);
            this.type = "PerspectiveCamera";
            this.fov = fov !== void 0 ? fov : 50;
            this.zoom = 1;
            this.near = near !== void 0 ? near : 0.1;
            this.far = far !== void 0 ? far : 2e3;
            this.focus = 10;
            this.aspect = aspect !== void 0 ? aspect : 1;
            this.view = null;
            this.filmGauge = 35;
            this.filmOffset = 0;
            this.updateProjectionMatrix();
          }
          PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
            constructor: PerspectiveCamera,
            isPerspectiveCamera: true,
            copy: function(source) {
              Camera.prototype.copy.call(this, source);
              this.fov = source.fov;
              this.zoom = source.zoom;
              this.near = source.near;
              this.far = source.far;
              this.focus = source.focus;
              this.aspect = source.aspect;
              this.view = source.view === null ? null : Object.assign({}, source.view);
              this.filmGauge = source.filmGauge;
              this.filmOffset = source.filmOffset;
              return this;
            },
            /**
             * Sets the FOV by focal length in respect to the current .filmGauge.
             *
             * The default film gauge is 35, so that the focal length can be specified for
             * a 35mm (full frame) camera.
             *
             * Values for focal length and film gauge must have the same unit.
             */
            setFocalLength: function(focalLength) {
              var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
              this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
              this.updateProjectionMatrix();
            },
            /**
             * Calculates the focal length from the current .fov and .filmGauge.
             */
            getFocalLength: function() {
              var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
              return 0.5 * this.getFilmHeight() / vExtentSlope;
            },
            getEffectiveFOV: function() {
              return _Math.RAD2DEG * 2 * Math.atan(
                Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom
              );
            },
            getFilmWidth: function() {
              return this.filmGauge * Math.min(this.aspect, 1);
            },
            getFilmHeight: function() {
              return this.filmGauge / Math.max(this.aspect, 1);
            },
            /**
             * Sets an offset in a larger frustum. This is useful for multi-window or
             * multi-monitor/multi-machine setups.
             *
             * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
             * the monitors are in grid like this
             *
             *   +---+---+---+
             *   | A | B | C |
             *   +---+---+---+
             *   | D | E | F |
             *   +---+---+---+
             *
             * then for each monitor you would call it like this
             *
             *   var w = 1920;
             *   var h = 1080;
             *   var fullWidth = w * 3;
             *   var fullHeight = h * 2;
             *
             *   --A--
             *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
             *   --B--
             *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
             *   --C--
             *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
             *   --D--
             *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
             *   --E--
             *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
             *   --F--
             *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
             *
             *   Note there is no reason monitors have to be the same size or in a grid.
             */
            setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
              this.aspect = fullWidth / fullHeight;
              this.view = {
                fullWidth,
                fullHeight,
                offsetX: x,
                offsetY: y,
                width,
                height
              };
              this.updateProjectionMatrix();
            },
            clearViewOffset: function() {
              this.view = null;
              this.updateProjectionMatrix();
            },
            updateProjectionMatrix: function() {
              var near = this.near, top = near * Math.tan(
                _Math.DEG2RAD * 0.5 * this.fov
              ) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
              if (view !== null) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
              }
              var skew = this.filmOffset;
              if (skew !== 0)
                left += near * skew / this.getFilmWidth();
              this.projectionMatrix.makeFrustum(
                left,
                left + width,
                top - height,
                top,
                near,
                this.far
              );
            },
            toJSON: function(meta) {
              var data = Object3D.prototype.toJSON.call(this, meta);
              data.object.fov = this.fov;
              data.object.zoom = this.zoom;
              data.object.near = this.near;
              data.object.far = this.far;
              data.object.focus = this.focus;
              data.object.aspect = this.aspect;
              if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
              data.object.filmGauge = this.filmGauge;
              data.object.filmOffset = this.filmOffset;
              return data;
            }
          });
          function OrthographicCamera(left, right, top, bottom, near, far) {
            Camera.call(this);
            this.type = "OrthographicCamera";
            this.zoom = 1;
            this.view = null;
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
            this.near = near !== void 0 ? near : 0.1;
            this.far = far !== void 0 ? far : 2e3;
            this.updateProjectionMatrix();
          }
          OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
            constructor: OrthographicCamera,
            isOrthographicCamera: true,
            copy: function(source) {
              Camera.prototype.copy.call(this, source);
              this.left = source.left;
              this.right = source.right;
              this.top = source.top;
              this.bottom = source.bottom;
              this.near = source.near;
              this.far = source.far;
              this.zoom = source.zoom;
              this.view = source.view === null ? null : Object.assign({}, source.view);
              return this;
            },
            setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
              this.view = {
                fullWidth,
                fullHeight,
                offsetX: x,
                offsetY: y,
                width,
                height
              };
              this.updateProjectionMatrix();
            },
            clearViewOffset: function() {
              this.view = null;
              this.updateProjectionMatrix();
            },
            updateProjectionMatrix: function() {
              var dx = (this.right - this.left) / (2 * this.zoom);
              var dy = (this.top - this.bottom) / (2 * this.zoom);
              var cx = (this.right + this.left) / 2;
              var cy = (this.top + this.bottom) / 2;
              var left = cx - dx;
              var right = cx + dx;
              var top = cy + dy;
              var bottom = cy - dy;
              if (this.view !== null) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
              }
              this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
            },
            toJSON: function(meta) {
              var data = Object3D.prototype.toJSON.call(this, meta);
              data.object.zoom = this.zoom;
              data.object.left = this.left;
              data.object.right = this.right;
              data.object.top = this.top;
              data.object.bottom = this.bottom;
              data.object.near = this.near;
              data.object.far = this.far;
              if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
              return data;
            }
          });
          function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
            var mode;
            function setMode(value) {
              mode = value;
            }
            var type, size;
            function setIndex(index) {
              if (index.array instanceof Uint32Array && extensions.get("OES_element_index_uint")) {
                type = gl.UNSIGNED_INT;
                size = 4;
              } else {
                type = gl.UNSIGNED_SHORT;
                size = 2;
              }
            }
            function render(start, count2) {
              gl.drawElements(mode, count2, type, start * size);
              infoRender.calls++;
              infoRender.vertices += count2;
              if (mode === gl.TRIANGLES)
                infoRender.faces += count2 / 3;
            }
            function renderInstances(geometry, start, count2) {
              var extension = extensions.get("ANGLE_instanced_arrays");
              if (extension === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
              }
              extension.drawElementsInstancedANGLE(mode, count2, type, start * size, geometry.maxInstancedCount);
              infoRender.calls++;
              infoRender.vertices += count2 * geometry.maxInstancedCount;
              if (mode === gl.TRIANGLES)
                infoRender.faces += geometry.maxInstancedCount * count2 / 3;
            }
            return {
              setMode,
              setIndex,
              render,
              renderInstances
            };
          }
          function WebGLBufferRenderer(gl, extensions, infoRender) {
            var mode;
            function setMode(value) {
              mode = value;
            }
            function render(start, count2) {
              gl.drawArrays(mode, start, count2);
              infoRender.calls++;
              infoRender.vertices += count2;
              if (mode === gl.TRIANGLES)
                infoRender.faces += count2 / 3;
            }
            function renderInstances(geometry) {
              var extension = extensions.get("ANGLE_instanced_arrays");
              if (extension === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
              }
              var position = geometry.attributes.position;
              var count2 = 0;
              if (position && position.isInterleavedBufferAttribute) {
                count2 = position.data.count;
                extension.drawArraysInstancedANGLE(mode, 0, count2, geometry.maxInstancedCount);
              } else {
                count2 = position.count;
                extension.drawArraysInstancedANGLE(mode, 0, count2, geometry.maxInstancedCount);
              }
              infoRender.calls++;
              infoRender.vertices += count2 * geometry.maxInstancedCount;
              if (mode === gl.TRIANGLES)
                infoRender.faces += geometry.maxInstancedCount * count2 / 3;
            }
            return {
              setMode,
              render,
              renderInstances
            };
          }
          function WebGLLights() {
            var lights = {};
            return {
              get: function(light) {
                if (lights[light.id] !== void 0) {
                  return lights[light.id];
                }
                var uniforms;
                switch (light.type) {
                  case "DirectionalLight":
                    uniforms = {
                      direction: new Vector3(),
                      color: new Color(),
                      shadow: false,
                      shadowBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Vector2()
                    };
                    break;
                  case "SpotLight":
                    uniforms = {
                      position: new Vector3(),
                      direction: new Vector3(),
                      color: new Color(),
                      distance: 0,
                      coneCos: 0,
                      penumbraCos: 0,
                      decay: 0,
                      shadow: false,
                      shadowBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Vector2()
                    };
                    break;
                  case "PointLight":
                    uniforms = {
                      position: new Vector3(),
                      color: new Color(),
                      distance: 0,
                      decay: 0,
                      shadow: false,
                      shadowBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Vector2()
                    };
                    break;
                  case "HemisphereLight":
                    uniforms = {
                      direction: new Vector3(),
                      skyColor: new Color(),
                      groundColor: new Color()
                    };
                    break;
                }
                lights[light.id] = uniforms;
                return uniforms;
              }
            };
          }
          function addLineNumbers(string) {
            var lines = string.split("\n");
            for (var i = 0; i < lines.length; i++) {
              lines[i] = i + 1 + ": " + lines[i];
            }
            return lines.join("\n");
          }
          function WebGLShader(gl, type, string) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, string);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
              console.error("THREE.WebGLShader: Shader couldn't compile.");
            }
            if (gl.getShaderInfoLog(shader) !== "") {
              console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
            }
            return shader;
          }
          var programIdCount = 0;
          function getEncodingComponents(encoding) {
            switch (encoding) {
              case LinearEncoding:
                return ["Linear", "( value )"];
              case sRGBEncoding:
                return ["sRGB", "( value )"];
              case RGBEEncoding:
                return ["RGBE", "( value )"];
              case RGBM7Encoding:
                return ["RGBM", "( value, 7.0 )"];
              case RGBM16Encoding:
                return ["RGBM", "( value, 16.0 )"];
              case RGBDEncoding:
                return ["RGBD", "( value, 256.0 )"];
              case GammaEncoding:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
              default:
                throw new Error("unsupported encoding: " + encoding);
            }
          }
          function getTexelDecodingFunction(functionName, encoding) {
            var components = getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
          }
          function getTexelEncodingFunction(functionName, encoding) {
            var components = getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
          }
          function getToneMappingFunction(functionName, toneMapping) {
            var toneMappingName;
            switch (toneMapping) {
              case LinearToneMapping:
                toneMappingName = "Linear";
                break;
              case ReinhardToneMapping:
                toneMappingName = "Reinhard";
                break;
              case Uncharted2ToneMapping:
                toneMappingName = "Uncharted2";
                break;
              case CineonToneMapping:
                toneMappingName = "OptimizedCineon";
                break;
              default:
                throw new Error("unsupported toneMapping: " + toneMapping);
            }
            return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
          }
          function generateExtensions(extensions, parameters, rendererExtensions) {
            extensions = extensions || {};
            var chunks = [
              extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
              (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
              extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
              (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
            ];
            return chunks.filter(filterEmptyLine).join("\n");
          }
          function generateDefines(defines) {
            var chunks = [];
            for (var name in defines) {
              var value = defines[name];
              if (value === false)
                continue;
              chunks.push("#define " + name + " " + value);
            }
            return chunks.join("\n");
          }
          function fetchAttributeLocations(gl, program, identifiers) {
            var attributes = {};
            var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
            for (var i = 0; i < n; i++) {
              var info = gl.getActiveAttrib(program, i);
              var name = info.name;
              attributes[name] = gl.getAttribLocation(program, name);
            }
            return attributes;
          }
          function filterEmptyLine(string) {
            return string !== "";
          }
          function replaceLightNums(string, parameters) {
            return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
          }
          function parseIncludes(string) {
            var pattern = /#include +<([\w\d.]+)>/g;
            function replace(match, include) {
              var replace2 = ShaderChunk[include];
              if (replace2 === void 0) {
                throw new Error("Can not resolve #include <" + include + ">");
              }
              return parseIncludes(replace2);
            }
            return string.replace(pattern, replace);
          }
          function unrollLoops(string) {
            var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            function replace(match, start, end, snippet) {
              var unroll = "";
              for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
              }
              return unroll;
            }
            return string.replace(pattern, replace);
          }
          function WebGLProgram(renderer, code, material, parameters) {
            var gl = renderer.context;
            var extensions = material.extensions;
            var defines = material.defines;
            var vertexShader = material.__webglShader.vertexShader;
            var fragmentShader = material.__webglShader.fragmentShader;
            var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
            if (parameters.shadowMapType === PCFShadowMap) {
              shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
            } else if (parameters.shadowMapType === PCFSoftShadowMap) {
              shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
            }
            var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
            var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
            if (parameters.envMap) {
              switch (material.envMap.mapping) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                  break;
                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                  break;
                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                  break;
                case SphericalReflectionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
                  break;
              }
              switch (material.envMap.mapping) {
                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                  envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                  break;
              }
              switch (material.combine) {
                case MultiplyOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case MixOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                  break;
                case AddOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                  break;
              }
            }
            var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
            var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
            var customDefines = generateDefines(defines);
            var program = gl.createProgram();
            var prefixVertex, prefixFragment;
            if (material.isRawShaderMaterial) {
              prefixVertex = [
                customDefines,
                "\n"
              ].filter(filterEmptyLine).join("\n");
              prefixFragment = [
                customExtensions,
                customDefines,
                "\n"
              ].filter(filterEmptyLine).join("\n");
            } else {
              prefixVertex = [
                "precision " + parameters.precision + " float;",
                "precision " + parameters.precision + " int;",
                "#define SHADER_NAME " + material.__webglShader.name,
                customDefines,
                parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                "#define GAMMA_FACTOR " + gammaFactorDefine,
                "#define MAX_BONES " + parameters.maxBones,
                parameters.map ? "#define USE_MAP" : "",
                parameters.envMap ? "#define USE_ENVMAP" : "",
                parameters.envMap ? "#define " + envMapModeDefine : "",
                parameters.lightMap ? "#define USE_LIGHTMAP" : "",
                parameters.aoMap ? "#define USE_AOMAP" : "",
                parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                parameters.bumpMap ? "#define USE_BUMPMAP" : "",
                parameters.normalMap ? "#define USE_NORMALMAP" : "",
                parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
                parameters.specularMap ? "#define USE_SPECULARMAP" : "",
                parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
                parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
                parameters.vertexColors ? "#define USE_COLOR" : "",
                parameters.flatShading ? "#define FLAT_SHADED" : "",
                parameters.skinning ? "#define USE_SKINNING" : "",
                parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
                parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
                parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
                parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
                parameters.flipSided ? "#define FLIP_SIDED" : "",
                "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes,
                parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
                parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_COLOR",
                "	attribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "	attribute vec3 morphTarget0;",
                "	attribute vec3 morphTarget1;",
                "	attribute vec3 morphTarget2;",
                "	attribute vec3 morphTarget3;",
                "	#ifdef USE_MORPHNORMALS",
                "		attribute vec3 morphNormal0;",
                "		attribute vec3 morphNormal1;",
                "		attribute vec3 morphNormal2;",
                "		attribute vec3 morphNormal3;",
                "	#else",
                "		attribute vec3 morphTarget4;",
                "		attribute vec3 morphTarget5;",
                "		attribute vec3 morphTarget6;",
                "		attribute vec3 morphTarget7;",
                "	#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "	attribute vec4 skinIndex;",
                "	attribute vec4 skinWeight;",
                "#endif",
                "\n"
              ].filter(filterEmptyLine).join("\n");
              prefixFragment = [
                customExtensions,
                "precision " + parameters.precision + " float;",
                "precision " + parameters.precision + " int;",
                "#define SHADER_NAME " + material.__webglShader.name,
                customDefines,
                parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "",
                "#define GAMMA_FACTOR " + gammaFactorDefine,
                parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
                parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
                parameters.map ? "#define USE_MAP" : "",
                parameters.envMap ? "#define USE_ENVMAP" : "",
                parameters.envMap ? "#define " + envMapTypeDefine : "",
                parameters.envMap ? "#define " + envMapModeDefine : "",
                parameters.envMap ? "#define " + envMapBlendingDefine : "",
                parameters.lightMap ? "#define USE_LIGHTMAP" : "",
                parameters.aoMap ? "#define USE_AOMAP" : "",
                parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                parameters.bumpMap ? "#define USE_BUMPMAP" : "",
                parameters.normalMap ? "#define USE_NORMALMAP" : "",
                parameters.specularMap ? "#define USE_SPECULARMAP" : "",
                parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
                parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
                parameters.vertexColors ? "#define USE_COLOR" : "",
                parameters.flatShading ? "#define FLAT_SHADED" : "",
                parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
                parameters.flipSided ? "#define FLIP_SIDED" : "",
                "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes,
                "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection),
                parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
                parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
                parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "",
                parameters.envMap && renderer.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
                parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
                // this code is required here because it is used by the toneMapping() function defined below
                parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
                parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
                // this code is required here because it is used by the various encoding/decoding function defined below
                parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
                parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
                parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
                parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
                parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
                "\n"
              ].filter(filterEmptyLine).join("\n");
            }
            vertexShader = parseIncludes(vertexShader, parameters);
            vertexShader = replaceLightNums(vertexShader, parameters);
            fragmentShader = parseIncludes(fragmentShader, parameters);
            fragmentShader = replaceLightNums(fragmentShader, parameters);
            if (!material.isShaderMaterial) {
              vertexShader = unrollLoops(vertexShader);
              fragmentShader = unrollLoops(fragmentShader);
            }
            var vertexGlsl = prefixVertex + vertexShader;
            var fragmentGlsl = prefixFragment + fragmentShader;
            var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
            var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
            gl.attachShader(program, glVertexShader);
            gl.attachShader(program, glFragmentShader);
            if (material.index0AttributeName !== void 0) {
              gl.bindAttribLocation(program, 0, material.index0AttributeName);
            } else if (parameters.morphTargets === true) {
              gl.bindAttribLocation(program, 0, "position");
            }
            gl.linkProgram(program);
            var programLog = gl.getProgramInfoLog(program);
            var vertexLog = gl.getShaderInfoLog(glVertexShader);
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
            var runnable = true;
            var haveDiagnostics = true;
            if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
              runnable = false;
              console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
            } else if (programLog !== "") {
              console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
            } else if (vertexLog === "" || fragmentLog === "") {
              haveDiagnostics = false;
            }
            if (haveDiagnostics) {
              this.diagnostics = {
                runnable,
                material,
                programLog,
                vertexShader: {
                  log: vertexLog,
                  prefix: prefixVertex
                },
                fragmentShader: {
                  log: fragmentLog,
                  prefix: prefixFragment
                }
              };
            }
            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader);
            var cachedUniforms;
            this.getUniforms = function() {
              if (cachedUniforms === void 0) {
                cachedUniforms = new WebGLUniforms(gl, program, renderer);
              }
              return cachedUniforms;
            };
            var cachedAttributes;
            this.getAttributes = function() {
              if (cachedAttributes === void 0) {
                cachedAttributes = fetchAttributeLocations(gl, program);
              }
              return cachedAttributes;
            };
            this.destroy = function() {
              gl.deleteProgram(program);
              this.program = void 0;
            };
            Object.defineProperties(this, {
              uniforms: {
                get: function() {
                  console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                  return this.getUniforms();
                }
              },
              attributes: {
                get: function() {
                  console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                  return this.getAttributes();
                }
              }
            });
            this.id = programIdCount++;
            this.code = code;
            this.usedTimes = 1;
            this.program = program;
            this.vertexShader = glVertexShader;
            this.fragmentShader = glFragmentShader;
            return this;
          }
          function WebGLPrograms(renderer, capabilities) {
            var programs = [];
            var shaderIDs = {
              MeshDepthMaterial: "depth",
              MeshNormalMaterial: "normal",
              MeshBasicMaterial: "basic",
              MeshLambertMaterial: "lambert",
              MeshPhongMaterial: "phong",
              MeshStandardMaterial: "physical",
              MeshPhysicalMaterial: "physical",
              LineBasicMaterial: "basic",
              LineDashedMaterial: "dashed",
              PointsMaterial: "points"
            };
            var parameterNames = [
              "precision",
              "supportsVertexTextures",
              "map",
              "mapEncoding",
              "envMap",
              "envMapMode",
              "envMapEncoding",
              "lightMap",
              "aoMap",
              "emissiveMap",
              "emissiveMapEncoding",
              "bumpMap",
              "normalMap",
              "displacementMap",
              "specularMap",
              "roughnessMap",
              "metalnessMap",
              "alphaMap",
              "combine",
              "vertexColors",
              "fog",
              "useFog",
              "fogExp",
              "flatShading",
              "sizeAttenuation",
              "logarithmicDepthBuffer",
              "skinning",
              "maxBones",
              "useVertexTexture",
              "morphTargets",
              "morphNormals",
              "maxMorphTargets",
              "maxMorphNormals",
              "premultipliedAlpha",
              "numDirLights",
              "numPointLights",
              "numSpotLights",
              "numHemiLights",
              "shadowMapEnabled",
              "shadowMapType",
              "toneMapping",
              "physicallyCorrectLights",
              "alphaTest",
              "doubleSided",
              "flipSided",
              "numClippingPlanes",
              "numClipIntersection",
              "depthPacking"
            ];
            function allocateBones(object) {
              if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
                return 1024;
              } else {
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = nVertexMatrices;
                if (object !== void 0 && (object && object.isSkinnedMesh)) {
                  maxBones = Math.min(object.skeleton.bones.length, maxBones);
                  if (maxBones < object.skeleton.bones.length) {
                    console.warn("WebGLRenderer: too many bones - " + object.skeleton.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)");
                  }
                }
                return maxBones;
              }
            }
            function getTextureEncodingFromMap(map, gammaOverrideLinear) {
              var encoding;
              if (!map) {
                encoding = LinearEncoding;
              } else if (map && map.isTexture) {
                encoding = map.encoding;
              } else if (map && map.isWebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
              }
              if (encoding === LinearEncoding && gammaOverrideLinear) {
                encoding = GammaEncoding;
              }
              return encoding;
            }
            this.getParameters = function(material, lights, fog, nClipPlanes, nClipIntersection, object) {
              var shaderID = shaderIDs[material.type];
              var maxBones = allocateBones(object);
              var precision = renderer.getPrecision();
              if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                  console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
                }
              }
              var currentRenderTarget = renderer.getCurrentRenderTarget();
              var parameters = {
                shaderID,
                precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,
                flatShading: material.shading === FlatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning,
                maxBones,
                useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false
              };
              return parameters;
            };
            this.getProgramCode = function(material, parameters) {
              var array = [];
              if (parameters.shaderID) {
                array.push(parameters.shaderID);
              } else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
              }
              if (material.defines !== void 0) {
                for (var name in material.defines) {
                  array.push(name);
                  array.push(material.defines[name]);
                }
              }
              for (var i = 0; i < parameterNames.length; i++) {
                array.push(parameters[parameterNames[i]]);
              }
              return array.join();
            };
            this.acquireProgram = function(material, parameters, code) {
              var program;
              for (var p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                  program = programInfo;
                  ++program.usedTimes;
                  break;
                }
              }
              if (program === void 0) {
                program = new WebGLProgram(renderer, code, material, parameters);
                programs.push(program);
              }
              return program;
            };
            this.releaseProgram = function(program) {
              if (--program.usedTimes === 0) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                program.destroy();
              }
            };
            this.programs = programs;
          }
          function WebGLGeometries(gl, properties, info) {
            var geometries = {};
            function onGeometryDispose(event) {
              var geometry = event.target;
              var buffergeometry = geometries[geometry.id];
              if (buffergeometry.index !== null) {
                deleteAttribute(buffergeometry.index);
              }
              deleteAttributes(buffergeometry.attributes);
              geometry.removeEventListener("dispose", onGeometryDispose);
              delete geometries[geometry.id];
              var property = properties.get(geometry);
              if (property.wireframe) {
                deleteAttribute(property.wireframe);
              }
              properties.delete(geometry);
              var bufferproperty = properties.get(buffergeometry);
              if (bufferproperty.wireframe) {
                deleteAttribute(bufferproperty.wireframe);
              }
              properties.delete(buffergeometry);
              info.memory.geometries--;
            }
            function getAttributeBuffer(attribute) {
              if (attribute.isInterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
              }
              return properties.get(attribute).__webglBuffer;
            }
            function deleteAttribute(attribute) {
              var buffer = getAttributeBuffer(attribute);
              if (buffer !== void 0) {
                gl.deleteBuffer(buffer);
                removeAttributeBuffer(attribute);
              }
            }
            function deleteAttributes(attributes) {
              for (var name in attributes) {
                deleteAttribute(attributes[name]);
              }
            }
            function removeAttributeBuffer(attribute) {
              if (attribute.isInterleavedBufferAttribute) {
                properties.delete(attribute.data);
              } else {
                properties.delete(attribute);
              }
            }
            return {
              get: function(object) {
                var geometry = object.geometry;
                if (geometries[geometry.id] !== void 0) {
                  return geometries[geometry.id];
                }
                geometry.addEventListener("dispose", onGeometryDispose);
                var buffergeometry;
                if (geometry.isBufferGeometry) {
                  buffergeometry = geometry;
                } else if (geometry.isGeometry) {
                  if (geometry._bufferGeometry === void 0) {
                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                  }
                  buffergeometry = geometry._bufferGeometry;
                }
                geometries[geometry.id] = buffergeometry;
                info.memory.geometries++;
                return buffergeometry;
              }
            };
          }
          function WebGLObjects(gl, properties, info) {
            var geometries = new WebGLGeometries(gl, properties, info);
            function update(object) {
              var geometry = geometries.get(object);
              if (object.geometry.isGeometry) {
                geometry.updateFromObject(object);
              }
              var index = geometry.index;
              var attributes = geometry.attributes;
              if (index !== null) {
                updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
              }
              for (var name in attributes) {
                updateAttribute(attributes[name], gl.ARRAY_BUFFER);
              }
              var morphAttributes = geometry.morphAttributes;
              for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                  updateAttribute(array[i], gl.ARRAY_BUFFER);
                }
              }
              return geometry;
            }
            function updateAttribute(attribute, bufferType) {
              var data = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
              var attributeProperties = properties.get(data);
              if (attributeProperties.__webglBuffer === void 0) {
                createBuffer(attributeProperties, data, bufferType);
              } else if (attributeProperties.version !== data.version) {
                updateBuffer(attributeProperties, data, bufferType);
              }
            }
            function createBuffer(attributeProperties, data, bufferType) {
              attributeProperties.__webglBuffer = gl.createBuffer();
              gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
              var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
              gl.bufferData(bufferType, data.array, usage);
              attributeProperties.version = data.version;
            }
            function updateBuffer(attributeProperties, data, bufferType) {
              gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
              if (data.dynamic === false) {
                gl.bufferData(bufferType, data.array, gl.STATIC_DRAW);
              } else if (data.updateRange.count === -1) {
                gl.bufferSubData(bufferType, 0, data.array);
              } else if (data.updateRange.count === 0) {
                console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
              } else {
                gl.bufferSubData(
                  bufferType,
                  data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                  data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count)
                );
                data.updateRange.count = 0;
              }
              attributeProperties.version = data.version;
            }
            function getAttributeBuffer(attribute) {
              if (attribute.isInterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
              }
              return properties.get(attribute).__webglBuffer;
            }
            function getWireframeAttribute(geometry) {
              var property = properties.get(geometry);
              if (property.wireframe !== void 0) {
                return property.wireframe;
              }
              var indices = [];
              var index = geometry.index;
              var attributes = geometry.attributes;
              var position = attributes.position;
              if (index !== null) {
                var edges = {};
                var array = index.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                  var a = array[i + 0];
                  var b = array[i + 1];
                  var c = array[i + 2];
                  indices.push(a, b, b, c, c, a);
                }
              } else {
                var array = attributes.position.array;
                for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                  var a = i + 0;
                  var b = i + 1;
                  var c = i + 2;
                  indices.push(a, b, b, c, c, a);
                }
              }
              var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
              var attribute = new BufferAttribute(new TypeArray(indices), 1);
              updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
              property.wireframe = attribute;
              return attribute;
            }
            return {
              getAttributeBuffer,
              getWireframeAttribute,
              update
            };
          }
          function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
            var _infoMemory = info.memory;
            var _isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && _gl instanceof WebGL2RenderingContext;
            function clampToMaxSize(image, maxSize) {
              if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height);
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);
                var context2 = canvas.getContext("2d");
                context2.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
                return canvas;
              }
              return image;
            }
            function isPowerOfTwo(image) {
              return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
            }
            function makePowerOfTwo(image) {
              if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = _Math.nearestPowerOfTwo(image.width);
                canvas.height = _Math.nearestPowerOfTwo(image.height);
                var context2 = canvas.getContext("2d");
                context2.drawImage(image, 0, 0, canvas.width, canvas.height);
                console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
                return canvas;
              }
              return image;
            }
            function textureNeedsPowerOfTwo(texture) {
              if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping)
                return true;
              if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
                return true;
              return false;
            }
            function filterFallback(f) {
              if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
                return _gl.NEAREST;
              }
              return _gl.LINEAR;
            }
            function onTextureDispose(event) {
              var texture = event.target;
              texture.removeEventListener("dispose", onTextureDispose);
              deallocateTexture(texture);
              _infoMemory.textures--;
            }
            function onRenderTargetDispose(event) {
              var renderTarget = event.target;
              renderTarget.removeEventListener("dispose", onRenderTargetDispose);
              deallocateRenderTarget(renderTarget);
              _infoMemory.textures--;
            }
            function deallocateTexture(texture) {
              var textureProperties = properties.get(texture);
              if (texture.image && textureProperties.__image__webglTextureCube) {
                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
              } else {
                if (textureProperties.__webglInit === void 0)
                  return;
                _gl.deleteTexture(textureProperties.__webglTexture);
              }
              properties.delete(texture);
            }
            function deallocateRenderTarget(renderTarget) {
              var renderTargetProperties = properties.get(renderTarget);
              var textureProperties = properties.get(renderTarget.texture);
              if (!renderTarget)
                return;
              if (textureProperties.__webglTexture !== void 0) {
                _gl.deleteTexture(textureProperties.__webglTexture);
              }
              if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
              }
              if (renderTarget && renderTarget.isWebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                  _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                  if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
              } else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer)
                  _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
              }
              properties.delete(renderTarget.texture);
              properties.delete(renderTarget);
            }
            function setTexture2D(texture, slot) {
              var textureProperties = properties.get(texture);
              if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === void 0) {
                  console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture);
                } else if (image.complete === false) {
                  console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture);
                } else {
                  uploadTexture(textureProperties, texture, slot);
                  return;
                }
              }
              state.activeTexture(_gl.TEXTURE0 + slot);
              state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            }
            function setTextureCube(texture, slot) {
              var textureProperties = properties.get(texture);
              if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                  if (!textureProperties.__image__webglTextureCube) {
                    texture.addEventListener("dispose", onTextureDispose);
                    textureProperties.__image__webglTextureCube = _gl.createTexture();
                    _infoMemory.textures++;
                  }
                  state.activeTexture(_gl.TEXTURE0 + slot);
                  state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                  _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                  var isCompressed = texture && texture.isCompressedTexture;
                  var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                  var cubeImage = [];
                  for (var i = 0; i < 6; i++) {
                    if (!isCompressed && !isDataTexture) {
                      cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                    } else {
                      cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                    }
                  }
                  var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
                  setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                  for (var i = 0; i < 6; i++) {
                    if (!isCompressed) {
                      if (isDataTexture) {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                      } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                      }
                    } else {
                      var mipmap, mipmaps = cubeImage[i].mipmaps;
                      for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                        mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                          } else {
                            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                          }
                        } else {
                          state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                        }
                      }
                    }
                  }
                  if (texture.generateMipmaps && isPowerOfTwoImage) {
                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                  }
                  textureProperties.__version = texture.version;
                  if (texture.onUpdate)
                    texture.onUpdate(texture);
                } else {
                  state.activeTexture(_gl.TEXTURE0 + slot);
                  state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
              }
            }
            function setTextureCubeDynamic(texture, slot) {
              state.activeTexture(_gl.TEXTURE0 + slot);
              state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
            }
            function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
              var extension;
              if (isPowerOfTwoImage) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
              } else {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                  console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture);
                }
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                  console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture);
                }
              }
              extension = extensions.get("EXT_texture_filter_anisotropic");
              if (extension) {
                if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
                  return;
                if (texture.type === HalfFloatType && extensions.get("OES_texture_half_float_linear") === null)
                  return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                  _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                  properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
              }
            }
            function uploadTexture(textureProperties, texture, slot) {
              if (textureProperties.__webglInit === void 0) {
                textureProperties.__webglInit = true;
                texture.addEventListener("dispose", onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                _infoMemory.textures++;
              }
              state.activeTexture(_gl.TEXTURE0 + slot);
              state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
              _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
              _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
              _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
              var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
              if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
                image = makePowerOfTwo(image);
              }
              var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
              setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
              var mipmap, mipmaps = texture.mipmaps;
              if (texture && texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                  if (!_isWebGL2)
                    throw new Error("Float Depth Texture only supported in WebGL2.0");
                  internalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (_isWebGL2) {
                  internalFormat = _gl.DEPTH_COMPONENT16;
                }
                if (texture.format === DepthStencilFormat) {
                  internalFormat = _gl.DEPTH_STENCIL;
                }
                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
              } else if (texture && texture.isDataTexture) {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                  for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                  texture.generateMipmaps = false;
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
              } else if (texture && texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                  mipmap = mipmaps[i];
                  if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                      state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                      console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    }
                  } else {
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              } else {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                  for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                  }
                  texture.generateMipmaps = false;
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                }
              }
              if (texture.generateMipmaps && isPowerOfTwoImage)
                _gl.generateMipmap(_gl.TEXTURE_2D);
              textureProperties.__version = texture.version;
              if (texture.onUpdate)
                texture.onUpdate(texture);
            }
            function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
              var glFormat = paramThreeToGL(renderTarget.texture.format);
              var glType = paramThreeToGL(renderTarget.texture.type);
              state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            }
            function setupRenderBufferStorage(renderbuffer, renderTarget) {
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
              if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
              } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
              }
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            }
            function setupDepthTexture(framebuffer, renderTarget) {
              var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
              if (isCube)
                throw new Error("Depth Texture with cube render targets is not supported!");
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              }
              if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
              }
              setTexture2D(renderTarget.depthTexture, 0);
              var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
              if (renderTarget.depthTexture.format === DepthFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              } else {
                throw new Error("Unknown depthTexture format");
              }
            }
            function setupDepthRenderbuffer(renderTarget) {
              var renderTargetProperties = properties.get(renderTarget);
              var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
              if (renderTarget.depthTexture) {
                if (isCube)
                  throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
              } else {
                if (isCube) {
                  renderTargetProperties.__webglDepthbuffer = [];
                  for (var i = 0; i < 6; i++) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                  }
                } else {
                  _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                  renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
              }
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            }
            function setupRenderTarget(renderTarget) {
              var renderTargetProperties = properties.get(renderTarget);
              var textureProperties = properties.get(renderTarget.texture);
              renderTarget.addEventListener("dispose", onRenderTargetDispose);
              textureProperties.__webglTexture = _gl.createTexture();
              _infoMemory.textures++;
              var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
              var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
              if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                  renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
              } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
              }
              if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                  setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                  _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
              } else {
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                  _gl.generateMipmap(_gl.TEXTURE_2D);
                state.bindTexture(_gl.TEXTURE_2D, null);
              }
              if (renderTarget.depthBuffer) {
                setupDepthRenderbuffer(renderTarget);
              }
            }
            function updateRenderTargetMipmap(renderTarget) {
              var texture = renderTarget.texture;
              if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                _gl.generateMipmap(target);
                state.bindTexture(target, null);
              }
            }
            this.setTexture2D = setTexture2D;
            this.setTextureCube = setTextureCube;
            this.setTextureCubeDynamic = setTextureCubeDynamic;
            this.setupRenderTarget = setupRenderTarget;
            this.updateRenderTargetMipmap = updateRenderTargetMipmap;
          }
          function WebGLProperties() {
            var properties = {};
            return {
              get: function(object) {
                var uuid = object.uuid;
                var map = properties[uuid];
                if (map === void 0) {
                  map = {};
                  properties[uuid] = map;
                }
                return map;
              },
              delete: function(object) {
                delete properties[object.uuid];
              },
              clear: function() {
                properties = {};
              }
            };
          }
          function WebGLState(gl, extensions, paramThreeToGL) {
            function ColorBuffer() {
              var locked = false;
              var color = new Vector4();
              var currentColorMask = null;
              var currentColorClear = new Vector4();
              return {
                setMask: function(colorMask) {
                  if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                  }
                },
                setLocked: function(lock) {
                  locked = lock;
                },
                setClear: function(r, g, b, a) {
                  color.set(r, g, b, a);
                  if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                  }
                },
                reset: function() {
                  locked = false;
                  currentColorMask = null;
                  currentColorClear.set(0, 0, 0, 1);
                }
              };
            }
            function DepthBuffer() {
              var locked = false;
              var currentDepthMask = null;
              var currentDepthFunc = null;
              var currentDepthClear = null;
              return {
                setTest: function(depthTest) {
                  if (depthTest) {
                    enable(gl.DEPTH_TEST);
                  } else {
                    disable(gl.DEPTH_TEST);
                  }
                },
                setMask: function(depthMask) {
                  if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                  }
                },
                setFunc: function(depthFunc) {
                  if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) {
                      switch (depthFunc) {
                        case NeverDepth:
                          gl.depthFunc(gl.NEVER);
                          break;
                        case AlwaysDepth:
                          gl.depthFunc(gl.ALWAYS);
                          break;
                        case LessDepth:
                          gl.depthFunc(gl.LESS);
                          break;
                        case LessEqualDepth:
                          gl.depthFunc(gl.LEQUAL);
                          break;
                        case EqualDepth:
                          gl.depthFunc(gl.EQUAL);
                          break;
                        case GreaterEqualDepth:
                          gl.depthFunc(gl.GEQUAL);
                          break;
                        case GreaterDepth:
                          gl.depthFunc(gl.GREATER);
                          break;
                        case NotEqualDepth:
                          gl.depthFunc(gl.NOTEQUAL);
                          break;
                        default:
                          gl.depthFunc(gl.LEQUAL);
                      }
                    } else {
                      gl.depthFunc(gl.LEQUAL);
                    }
                    currentDepthFunc = depthFunc;
                  }
                },
                setLocked: function(lock) {
                  locked = lock;
                },
                setClear: function(depth) {
                  if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                  }
                },
                reset: function() {
                  locked = false;
                  currentDepthMask = null;
                  currentDepthFunc = null;
                  currentDepthClear = null;
                }
              };
            }
            function StencilBuffer() {
              var locked = false;
              var currentStencilMask = null;
              var currentStencilFunc = null;
              var currentStencilRef = null;
              var currentStencilFuncMask = null;
              var currentStencilFail = null;
              var currentStencilZFail = null;
              var currentStencilZPass = null;
              var currentStencilClear = null;
              return {
                setTest: function(stencilTest) {
                  if (stencilTest) {
                    enable(gl.STENCIL_TEST);
                  } else {
                    disable(gl.STENCIL_TEST);
                  }
                },
                setMask: function(stencilMask) {
                  if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                  }
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                  if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                  }
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                  if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                  }
                },
                setLocked: function(lock) {
                  locked = lock;
                },
                setClear: function(stencil) {
                  if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                  }
                },
                reset: function() {
                  locked = false;
                  currentStencilMask = null;
                  currentStencilFunc = null;
                  currentStencilRef = null;
                  currentStencilFuncMask = null;
                  currentStencilFail = null;
                  currentStencilZFail = null;
                  currentStencilZPass = null;
                  currentStencilClear = null;
                }
              };
            }
            var colorBuffer = new ColorBuffer();
            var depthBuffer = new DepthBuffer();
            var stencilBuffer = new StencilBuffer();
            var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var newAttributes = new Uint8Array(maxVertexAttributes);
            var enabledAttributes = new Uint8Array(maxVertexAttributes);
            var attributeDivisors = new Uint8Array(maxVertexAttributes);
            var capabilities = {};
            var compressedTextureFormats = null;
            var currentBlending = null;
            var currentBlendEquation = null;
            var currentBlendSrc = null;
            var currentBlendDst = null;
            var currentBlendEquationAlpha = null;
            var currentBlendSrcAlpha = null;
            var currentBlendDstAlpha = null;
            var currentPremultipledAlpha = false;
            var currentFlipSided = null;
            var currentCullFace = null;
            var currentLineWidth = null;
            var currentPolygonOffsetFactor = null;
            var currentPolygonOffsetUnits = null;
            var currentScissorTest = null;
            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            var currentTextureSlot = null;
            var currentBoundTextures = {};
            var currentScissor = new Vector4();
            var currentViewport = new Vector4();
            function createTexture(type, target, count2) {
              var data = new Uint8Array(4);
              var texture = gl.createTexture();
              gl.bindTexture(type, texture);
              gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              for (var i = 0; i < count2; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
              }
              return texture;
            }
            var emptyTextures = {};
            emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
            emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
            function init() {
              clearColor(0, 0, 0, 1);
              clearDepth(1);
              clearStencil(0);
              enable(gl.DEPTH_TEST);
              setDepthFunc(LessEqualDepth);
              setFlipSided(false);
              setCullFace(CullFaceBack);
              enable(gl.CULL_FACE);
              enable(gl.BLEND);
              setBlending(NormalBlending);
            }
            function initAttributes() {
              for (var i = 0, l = newAttributes.length; i < l; i++) {
                newAttributes[i] = 0;
              }
            }
            function enableAttribute(attribute) {
              newAttributes[attribute] = 1;
              if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
              }
              if (attributeDivisors[attribute] !== 0) {
                var extension = extensions.get("ANGLE_instanced_arrays");
                extension.vertexAttribDivisorANGLE(attribute, 0);
                attributeDivisors[attribute] = 0;
              }
            }
            function enableAttributeAndDivisor(attribute, meshPerAttribute, extension) {
              newAttributes[attribute] = 1;
              if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
              }
              if (attributeDivisors[attribute] !== meshPerAttribute) {
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
              }
            }
            function disableUnusedAttributes() {
              for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                if (enabledAttributes[i] !== newAttributes[i]) {
                  gl.disableVertexAttribArray(i);
                  enabledAttributes[i] = 0;
                }
              }
            }
            function enable(id) {
              if (capabilities[id] !== true) {
                gl.enable(id);
                capabilities[id] = true;
              }
            }
            function disable(id) {
              if (capabilities[id] !== false) {
                gl.disable(id);
                capabilities[id] = false;
              }
            }
            function getCompressedTextureFormats() {
              if (compressedTextureFormats === null) {
                compressedTextureFormats = [];
                if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1")) {
                  var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                  for (var i = 0; i < formats.length; i++) {
                    compressedTextureFormats.push(formats[i]);
                  }
                }
              }
              return compressedTextureFormats;
            }
            function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
              if (blending !== NoBlending) {
                enable(gl.BLEND);
              } else {
                disable(gl.BLEND);
              }
              if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (blending === AdditiveBlending) {
                  if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                  } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                  }
                } else if (blending === SubtractiveBlending) {
                  if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                  } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                  }
                } else if (blending === MultiplyBlending) {
                  if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                  } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                  }
                } else {
                  if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                  } else {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                  }
                }
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
              }
              if (blending === CustomBlending) {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                  gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
                  currentBlendEquation = blendEquation;
                  currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                  gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
                  currentBlendSrc = blendSrc;
                  currentBlendDst = blendDst;
                  currentBlendSrcAlpha = blendSrcAlpha;
                  currentBlendDstAlpha = blendDstAlpha;
                }
              } else {
                currentBlendEquation = null;
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendEquationAlpha = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
              }
            }
            function setColorWrite(colorWrite) {
              colorBuffer.setMask(colorWrite);
            }
            function setDepthTest(depthTest) {
              depthBuffer.setTest(depthTest);
            }
            function setDepthWrite(depthWrite) {
              depthBuffer.setMask(depthWrite);
            }
            function setDepthFunc(depthFunc) {
              depthBuffer.setFunc(depthFunc);
            }
            function setStencilTest(stencilTest) {
              stencilBuffer.setTest(stencilTest);
            }
            function setStencilWrite(stencilWrite) {
              stencilBuffer.setMask(stencilWrite);
            }
            function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
              stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
            }
            function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
              stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
            }
            function setFlipSided(flipSided) {
              if (currentFlipSided !== flipSided) {
                if (flipSided) {
                  gl.frontFace(gl.CW);
                } else {
                  gl.frontFace(gl.CCW);
                }
                currentFlipSided = flipSided;
              }
            }
            function setCullFace(cullFace) {
              if (cullFace !== CullFaceNone) {
                enable(gl.CULL_FACE);
                if (cullFace !== currentCullFace) {
                  if (cullFace === CullFaceBack) {
                    gl.cullFace(gl.BACK);
                  } else if (cullFace === CullFaceFront) {
                    gl.cullFace(gl.FRONT);
                  } else {
                    gl.cullFace(gl.FRONT_AND_BACK);
                  }
                }
              } else {
                disable(gl.CULL_FACE);
              }
              currentCullFace = cullFace;
            }
            function setLineWidth(width) {
              if (width !== currentLineWidth) {
                gl.lineWidth(width);
                currentLineWidth = width;
              }
            }
            function setPolygonOffset(polygonOffset, factor, units) {
              if (polygonOffset) {
                enable(gl.POLYGON_OFFSET_FILL);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                  gl.polygonOffset(factor, units);
                  currentPolygonOffsetFactor = factor;
                  currentPolygonOffsetUnits = units;
                }
              } else {
                disable(gl.POLYGON_OFFSET_FILL);
              }
            }
            function getScissorTest() {
              return currentScissorTest;
            }
            function setScissorTest(scissorTest) {
              currentScissorTest = scissorTest;
              if (scissorTest) {
                enable(gl.SCISSOR_TEST);
              } else {
                disable(gl.SCISSOR_TEST);
              }
            }
            function activeTexture(webglSlot) {
              if (webglSlot === void 0)
                webglSlot = gl.TEXTURE0 + maxTextures - 1;
              if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
              }
            }
            function bindTexture(webglType, webglTexture) {
              if (currentTextureSlot === null) {
                activeTexture();
              }
              var boundTexture = currentBoundTextures[currentTextureSlot];
              if (boundTexture === void 0) {
                boundTexture = { type: void 0, texture: void 0 };
                currentBoundTextures[currentTextureSlot] = boundTexture;
              }
              if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
              }
            }
            function compressedTexImage2D() {
              try {
                gl.compressedTexImage2D.apply(gl, arguments);
              } catch (error) {
                console.error(error);
              }
            }
            function texImage2D() {
              try {
                gl.texImage2D.apply(gl, arguments);
              } catch (error) {
                console.error(error);
              }
            }
            function clearColor(r, g, b, a) {
              colorBuffer.setClear(r, g, b, a);
            }
            function clearDepth(depth) {
              depthBuffer.setClear(depth);
            }
            function clearStencil(stencil) {
              stencilBuffer.setClear(stencil);
            }
            function scissor(scissor2) {
              if (currentScissor.equals(scissor2) === false) {
                gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
                currentScissor.copy(scissor2);
              }
            }
            function viewport(viewport2) {
              if (currentViewport.equals(viewport2) === false) {
                gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
                currentViewport.copy(viewport2);
              }
            }
            function reset() {
              for (var i = 0; i < enabledAttributes.length; i++) {
                if (enabledAttributes[i] === 1) {
                  gl.disableVertexAttribArray(i);
                  enabledAttributes[i] = 0;
                }
              }
              capabilities = {};
              compressedTextureFormats = null;
              currentTextureSlot = null;
              currentBoundTextures = {};
              currentBlending = null;
              currentFlipSided = null;
              currentCullFace = null;
              colorBuffer.reset();
              depthBuffer.reset();
              stencilBuffer.reset();
            }
            return {
              buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
              },
              init,
              initAttributes,
              enableAttribute,
              enableAttributeAndDivisor,
              disableUnusedAttributes,
              enable,
              disable,
              getCompressedTextureFormats,
              setBlending,
              setColorWrite,
              setDepthTest,
              setDepthWrite,
              setDepthFunc,
              setStencilTest,
              setStencilWrite,
              setStencilFunc,
              setStencilOp,
              setFlipSided,
              setCullFace,
              setLineWidth,
              setPolygonOffset,
              getScissorTest,
              setScissorTest,
              activeTexture,
              bindTexture,
              compressedTexImage2D,
              texImage2D,
              clearColor,
              clearDepth,
              clearStencil,
              scissor,
              viewport,
              reset
            };
          }
          function WebGLCapabilities(gl, extensions, parameters) {
            var maxAnisotropy;
            function getMaxAnisotropy() {
              if (maxAnisotropy !== void 0)
                return maxAnisotropy;
              var extension = extensions.get("EXT_texture_filter_anisotropic");
              if (extension !== null) {
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else {
                maxAnisotropy = 0;
              }
              return maxAnisotropy;
            }
            function getMaxPrecision(precision2) {
              if (precision2 === "highp") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                  return "highp";
                }
                precision2 = "mediump";
              }
              if (precision2 === "mediump") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                  return "mediump";
                }
              }
              return "lowp";
            }
            var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
            var maxPrecision = getMaxPrecision(precision);
            if (maxPrecision !== precision) {
              console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
              precision = maxPrecision;
            }
            var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get("EXT_frag_depth");
            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            var vertexTextures = maxVertexTextures > 0;
            var floatFragmentTextures = !!extensions.get("OES_texture_float");
            var floatVertexTextures = vertexTextures && floatFragmentTextures;
            return {
              getMaxAnisotropy,
              getMaxPrecision,
              precision,
              logarithmicDepthBuffer,
              maxTextures,
              maxVertexTextures,
              maxTextureSize,
              maxCubemapSize,
              maxAttributes,
              maxVertexUniforms,
              maxVaryings,
              maxFragmentUniforms,
              vertexTextures,
              floatFragmentTextures,
              floatVertexTextures
            };
          }
          function WebGLExtensions(gl) {
            var extensions = {};
            return {
              get: function(name) {
                if (extensions[name] !== void 0) {
                  return extensions[name];
                }
                var extension;
                switch (name) {
                  case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                  case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                  case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                  case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                  case "WEBGL_compressed_texture_etc1":
                    extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                    break;
                  default:
                    extension = gl.getExtension(name);
                }
                if (extension === null) {
                  console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
                }
                extensions[name] = extension;
                return extension;
              }
            };
          }
          function WebGLClipping() {
            var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
            this.uniform = uniform;
            this.numPlanes = 0;
            this.numIntersection = 0;
            this.init = function(planes, enableLocalClipping, camera) {
              var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
              // run another frame in order to reset the state:
              numGlobalPlanes !== 0 || localClippingEnabled;
              localClippingEnabled = enableLocalClipping;
              globalState = projectPlanes(planes, camera, 0);
              numGlobalPlanes = planes.length;
              return enabled;
            };
            this.beginShadows = function() {
              renderingShadows = true;
              projectPlanes(null);
            };
            this.endShadows = function() {
              renderingShadows = false;
              resetGlobalState();
            };
            this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
              if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                if (renderingShadows) {
                  projectPlanes(null);
                } else {
                  resetGlobalState();
                }
              } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
                uniform.value = dstArray;
                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                  dstArray[i] = globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
              }
            };
            function resetGlobalState() {
              if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
              }
              scope.numPlanes = numGlobalPlanes;
              scope.numIntersection = 0;
            }
            function projectPlanes(planes, camera, dstOffset, skipTransform) {
              var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
              if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                  var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                  viewNormalMatrix.getNormalMatrix(viewMatrix);
                  if (dstArray === null || dstArray.length < flatSize) {
                    dstArray = new Float32Array(flatSize);
                  }
                  for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                  }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
              }
              scope.numPlanes = nPlanes;
              return dstArray;
            }
          }
          function WebGLRenderer(parameters) {
            console.log("THREE.WebGLRenderer", REVISION);
            parameters = parameters || {};
            var _canvas = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false;
            var lights = [];
            var opaqueObjects = [];
            var opaqueObjectsLastIndex = -1;
            var transparentObjects = [];
            var transparentObjectsLastIndex = -1;
            var morphInfluences = new Float32Array(8);
            var sprites = [];
            var lensFlares = [];
            this.domElement = _canvas;
            this.context = null;
            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            this.sortObjects = true;
            this.clippingPlanes = [];
            this.localClippingEnabled = false;
            this.gammaFactor = 2;
            this.gammaInput = false;
            this.gammaOutput = false;
            this.physicallyCorrectLights = false;
            this.toneMapping = LinearToneMapping;
            this.toneMappingExposure = 1;
            this.toneMappingWhitePoint = 1;
            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4;
            var _this = this, _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentScissor = new Vector4(), _currentScissorTest = null, _currentViewport = new Vector4(), _usedTextureUnits = 0, _clearColor = new Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _viewport = new Vector4(0, 0, _width, _height), _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _sphere = new Sphere(), _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _lights = {
              hash: "",
              ambient: [0, 0, 0],
              directional: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              point: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
              shadows: []
            }, _infoRender = {
              calls: 0,
              vertices: 0,
              faces: 0,
              points: 0
            };
            this.info = {
              render: _infoRender,
              memory: {
                geometries: 0,
                textures: 0
              },
              programs: null
            };
            var _gl;
            try {
              var attributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
              };
              _gl = _context || _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes);
              if (_gl === null) {
                if (_canvas.getContext("webgl") !== null) {
                  throw "Error creating WebGL context with your selected attributes.";
                } else {
                  throw "Error creating WebGL context.";
                }
              }
              if (_gl.getShaderPrecisionFormat === void 0) {
                _gl.getShaderPrecisionFormat = function() {
                  return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
                };
              }
              _canvas.addEventListener("webglcontextlost", onContextLost, false);
            } catch (error) {
              console.error("THREE.WebGLRenderer: " + error);
            }
            var extensions = new WebGLExtensions(_gl);
            extensions.get("WEBGL_depth_texture");
            extensions.get("OES_texture_float");
            extensions.get("OES_texture_float_linear");
            extensions.get("OES_texture_half_float");
            extensions.get("OES_texture_half_float_linear");
            extensions.get("OES_standard_derivatives");
            extensions.get("ANGLE_instanced_arrays");
            if (extensions.get("OES_element_index_uint")) {
              BufferGeometry.MaxIndex = 4294967296;
            }
            var capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            var state = new WebGLState(_gl, extensions, paramThreeToGL);
            var properties = new WebGLProperties();
            var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info);
            var objects = new WebGLObjects(_gl, properties, this.info);
            var programCache = new WebGLPrograms(this, capabilities);
            var lightCache = new WebGLLights();
            this.info.programs = programCache.programs;
            var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
            var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
            var backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
            var backgroundCamera2 = new PerspectiveCamera();
            var backgroundPlaneMesh = new Mesh(
              new PlaneBufferGeometry(2, 2),
              new MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false })
            );
            var backgroundBoxShader = ShaderLib["cube"];
            var backgroundBoxMesh = new Mesh(
              new BoxBufferGeometry(5, 5, 5),
              new ShaderMaterial({
                uniforms: backgroundBoxShader.uniforms,
                vertexShader: backgroundBoxShader.vertexShader,
                fragmentShader: backgroundBoxShader.fragmentShader,
                side: BackSide,
                depthTest: false,
                depthWrite: false,
                fog: false
              })
            );
            function getTargetPixelRatio() {
              return _currentRenderTarget === null ? _pixelRatio : 1;
            }
            function glClearColor(r, g, b, a) {
              if (_premultipliedAlpha === true) {
                r *= a;
                g *= a;
                b *= a;
              }
              state.clearColor(r, g, b, a);
            }
            function setDefaultGLState() {
              state.init();
              state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
              state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
              glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
            }
            function resetGLState() {
              _currentProgram = null;
              _currentCamera = null;
              _currentGeometryProgram = "";
              _currentMaterialId = -1;
              state.reset();
            }
            setDefaultGLState();
            this.context = _gl;
            this.capabilities = capabilities;
            this.extensions = extensions;
            this.properties = properties;
            this.state = state;
            var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
            this.shadowMap = shadowMap;
            var spritePlugin = new SpritePlugin(this, sprites);
            var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
            this.getContext = function() {
              return _gl;
            };
            this.getContextAttributes = function() {
              return _gl.getContextAttributes();
            };
            this.forceContextLoss = function() {
              extensions.get("WEBGL_lose_context").loseContext();
            };
            this.getMaxAnisotropy = function() {
              return capabilities.getMaxAnisotropy();
            };
            this.getPrecision = function() {
              return capabilities.precision;
            };
            this.getPixelRatio = function() {
              return _pixelRatio;
            };
            this.setPixelRatio = function(value) {
              if (value === void 0)
                return;
              _pixelRatio = value;
              this.setSize(_viewport.z, _viewport.w, false);
            };
            this.getSize = function() {
              return {
                width: _width,
                height: _height
              };
            };
            this.setSize = function(width, height, updateStyle) {
              _width = width;
              _height = height;
              _canvas.width = width * _pixelRatio;
              _canvas.height = height * _pixelRatio;
              if (updateStyle !== false) {
                _canvas.style.width = width + "px";
                _canvas.style.height = height + "px";
              }
              this.setViewport(0, 0, width, height);
            };
            this.setViewport = function(x, y, width, height) {
              state.viewport(_viewport.set(x, y, width, height));
            };
            this.setScissor = function(x, y, width, height) {
              state.scissor(_scissor.set(x, y, width, height));
            };
            this.setScissorTest = function(boolean) {
              state.setScissorTest(_scissorTest = boolean);
            };
            this.getClearColor = function() {
              return _clearColor;
            };
            this.setClearColor = function(color, alpha) {
              _clearColor.set(color);
              _clearAlpha = alpha !== void 0 ? alpha : 1;
              glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
            };
            this.getClearAlpha = function() {
              return _clearAlpha;
            };
            this.setClearAlpha = function(alpha) {
              _clearAlpha = alpha;
              glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
            };
            this.clear = function(color, depth, stencil) {
              var bits = 0;
              if (color === void 0 || color)
                bits |= _gl.COLOR_BUFFER_BIT;
              if (depth === void 0 || depth)
                bits |= _gl.DEPTH_BUFFER_BIT;
              if (stencil === void 0 || stencil)
                bits |= _gl.STENCIL_BUFFER_BIT;
              _gl.clear(bits);
            };
            this.clearColor = function() {
              this.clear(true, false, false);
            };
            this.clearDepth = function() {
              this.clear(false, true, false);
            };
            this.clearStencil = function() {
              this.clear(false, false, true);
            };
            this.clearTarget = function(renderTarget, color, depth, stencil) {
              this.setRenderTarget(renderTarget);
              this.clear(color, depth, stencil);
            };
            this.resetGLState = resetGLState;
            this.dispose = function() {
              transparentObjects = [];
              transparentObjectsLastIndex = -1;
              opaqueObjects = [];
              opaqueObjectsLastIndex = -1;
              _canvas.removeEventListener("webglcontextlost", onContextLost, false);
            };
            function onContextLost(event) {
              event.preventDefault();
              resetGLState();
              setDefaultGLState();
              properties.clear();
            }
            function onMaterialDispose(event) {
              var material = event.target;
              material.removeEventListener("dispose", onMaterialDispose);
              deallocateMaterial(material);
            }
            function deallocateMaterial(material) {
              releaseMaterialProgramReference(material);
              properties.delete(material);
            }
            function releaseMaterialProgramReference(material) {
              var programInfo = properties.get(material).program;
              material.program = void 0;
              if (programInfo !== void 0) {
                programCache.releaseProgram(programInfo);
              }
            }
            this.renderBufferImmediate = function(object, program, material) {
              state.initAttributes();
              var buffers = properties.get(object);
              if (object.hasPositions && !buffers.position)
                buffers.position = _gl.createBuffer();
              if (object.hasNormals && !buffers.normal)
                buffers.normal = _gl.createBuffer();
              if (object.hasUvs && !buffers.uv)
                buffers.uv = _gl.createBuffer();
              if (object.hasColors && !buffers.color)
                buffers.color = _gl.createBuffer();
              var attributes2 = program.getAttributes();
              if (object.hasPositions) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes2.position);
                _gl.vertexAttribPointer(attributes2.position, 3, _gl.FLOAT, false, 0, 0);
              }
              if (object.hasNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && material.shading === FlatShading) {
                  for (var i = 0, l = object.count * 3; i < l; i += 9) {
                    var array = object.normalArray;
                    var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                    var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                    var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx;
                    array[i + 1] = ny;
                    array[i + 2] = nz;
                    array[i + 3] = nx;
                    array[i + 4] = ny;
                    array[i + 5] = nz;
                    array[i + 6] = nx;
                    array[i + 7] = ny;
                    array[i + 8] = nz;
                  }
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes2.normal);
                _gl.vertexAttribPointer(attributes2.normal, 3, _gl.FLOAT, false, 0, 0);
              }
              if (object.hasUvs && material.map) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes2.uv);
                _gl.vertexAttribPointer(attributes2.uv, 2, _gl.FLOAT, false, 0, 0);
              }
              if (object.hasColors && material.vertexColors !== NoColors) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes2.color);
                _gl.vertexAttribPointer(attributes2.color, 3, _gl.FLOAT, false, 0, 0);
              }
              state.disableUnusedAttributes();
              _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
              object.count = 0;
            };
            this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
              setMaterial(material);
              var program = setProgram(camera, fog, material, object);
              var updateBuffers = false;
              var geometryProgram = geometry.id + "_" + program.id + "_" + material.wireframe;
              if (geometryProgram !== _currentGeometryProgram) {
                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
              }
              var morphTargetInfluences = object.morphTargetInfluences;
              if (morphTargetInfluences !== void 0) {
                var activeInfluences = [];
                for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
                  var influence = morphTargetInfluences[i];
                  activeInfluences.push([influence, i]);
                }
                activeInfluences.sort(absNumericalSort);
                if (activeInfluences.length > 8) {
                  activeInfluences.length = 8;
                }
                var morphAttributes = geometry.morphAttributes;
                for (var i = 0, l = activeInfluences.length; i < l; i++) {
                  var influence = activeInfluences[i];
                  morphInfluences[i] = influence[0];
                  if (influence[0] !== 0) {
                    var index = influence[1];
                    if (material.morphTargets === true && morphAttributes.position)
                      geometry.addAttribute("morphTarget" + i, morphAttributes.position[index]);
                    if (material.morphNormals === true && morphAttributes.normal)
                      geometry.addAttribute("morphNormal" + i, morphAttributes.normal[index]);
                  } else {
                    if (material.morphTargets === true)
                      geometry.removeAttribute("morphTarget" + i);
                    if (material.morphNormals === true)
                      geometry.removeAttribute("morphNormal" + i);
                  }
                }
                for (var i = activeInfluences.length, il = morphInfluences.length; i < il; i++) {
                  morphInfluences[i] = 0;
                }
                program.getUniforms().setValue(
                  _gl,
                  "morphTargetInfluences",
                  morphInfluences
                );
                updateBuffers = true;
              }
              var index = geometry.index;
              var position = geometry.attributes.position;
              var rangeFactor = 1;
              if (material.wireframe === true) {
                index = objects.getWireframeAttribute(geometry);
                rangeFactor = 2;
              }
              var renderer;
              if (index !== null) {
                renderer = indexedBufferRenderer;
                renderer.setIndex(index);
              } else {
                renderer = bufferRenderer;
              }
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry);
                if (index !== null) {
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
                }
              }
              var dataCount = 0;
              if (index !== null) {
                dataCount = index.count;
              } else if (position !== void 0) {
                dataCount = position.count;
              }
              var rangeStart = geometry.drawRange.start * rangeFactor;
              var rangeCount = geometry.drawRange.count * rangeFactor;
              var groupStart = group !== null ? group.start * rangeFactor : 0;
              var groupCount = group !== null ? group.count * rangeFactor : Infinity;
              var drawStart = Math.max(rangeStart, groupStart);
              var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
              var drawCount = Math.max(0, drawEnd - drawStart + 1);
              if (drawCount === 0)
                return;
              if (object.isMesh) {
                if (material.wireframe === true) {
                  state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                  renderer.setMode(_gl.LINES);
                } else {
                  switch (object.drawMode) {
                    case TrianglesDrawMode:
                      renderer.setMode(_gl.TRIANGLES);
                      break;
                    case TriangleStripDrawMode:
                      renderer.setMode(_gl.TRIANGLE_STRIP);
                      break;
                    case TriangleFanDrawMode:
                      renderer.setMode(_gl.TRIANGLE_FAN);
                      break;
                  }
                }
              } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === void 0)
                  lineWidth = 1;
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                  renderer.setMode(_gl.LINES);
                } else {
                  renderer.setMode(_gl.LINE_STRIP);
                }
              } else if (object.isPoints) {
                renderer.setMode(_gl.POINTS);
              }
              if (geometry && geometry.isInstancedBufferGeometry) {
                if (geometry.maxInstancedCount > 0) {
                  renderer.renderInstances(geometry, drawStart, drawCount);
                }
              } else {
                renderer.render(drawStart, drawCount);
              }
            };
            function setupVertexAttributes(material, program, geometry, startIndex) {
              var extension;
              if (geometry && geometry.isInstancedBufferGeometry) {
                extension = extensions.get("ANGLE_instanced_arrays");
                if (extension === null) {
                  console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                  return;
                }
              }
              if (startIndex === void 0)
                startIndex = 0;
              state.initAttributes();
              var geometryAttributes = geometry.attributes;
              var programAttributes = program.getAttributes();
              var materialDefaultAttributeValues = material.defaultAttributeValues;
              for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                  var geometryAttribute = geometryAttributes[name];
                  if (geometryAttribute !== void 0) {
                    var type = _gl.FLOAT;
                    var array = geometryAttribute.array;
                    var normalized = geometryAttribute.normalized;
                    if (array instanceof Float32Array) {
                      type = _gl.FLOAT;
                    } else if (array instanceof Float64Array) {
                      console.warn("Unsupported data buffer format: Float64Array");
                    } else if (array instanceof Uint16Array) {
                      type = _gl.UNSIGNED_SHORT;
                    } else if (array instanceof Int16Array) {
                      type = _gl.SHORT;
                    } else if (array instanceof Uint32Array) {
                      type = _gl.UNSIGNED_INT;
                    } else if (array instanceof Int32Array) {
                      type = _gl.INT;
                    } else if (array instanceof Int8Array) {
                      type = _gl.BYTE;
                    } else if (array instanceof Uint8Array) {
                      type = _gl.UNSIGNED_BYTE;
                    }
                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer(geometryAttribute);
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                      var data = geometryAttribute.data;
                      var stride = data.stride;
                      var offset = geometryAttribute.offset;
                      if (data && data.isInstancedInterleavedBuffer) {
                        state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                        if (geometry.maxInstancedCount === void 0) {
                          geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                        }
                      } else {
                        state.enableAttribute(programAttribute);
                      }
                      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                      _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                    } else {
                      if (geometryAttribute.isInstancedBufferAttribute) {
                        state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                        if (geometry.maxInstancedCount === void 0) {
                          geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        }
                      } else {
                        state.enableAttribute(programAttribute);
                      }
                      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                      _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                    }
                  } else if (materialDefaultAttributeValues !== void 0) {
                    var value = materialDefaultAttributeValues[name];
                    if (value !== void 0) {
                      switch (value.length) {
                        case 2:
                          _gl.vertexAttrib2fv(programAttribute, value);
                          break;
                        case 3:
                          _gl.vertexAttrib3fv(programAttribute, value);
                          break;
                        case 4:
                          _gl.vertexAttrib4fv(programAttribute, value);
                          break;
                        default:
                          _gl.vertexAttrib1fv(programAttribute, value);
                      }
                    }
                  }
                }
              }
              state.disableUnusedAttributes();
            }
            function absNumericalSort(a, b) {
              return Math.abs(b[0]) - Math.abs(a[0]);
            }
            function painterSortStable(a, b) {
              if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
              } else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
                return a.material.program.id - b.material.program.id;
              } else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
              } else if (a.z !== b.z) {
                return a.z - b.z;
              } else {
                return a.id - b.id;
              }
            }
            function reversePainterSortStable(a, b) {
              if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
              }
              if (a.z !== b.z) {
                return b.z - a.z;
              } else {
                return a.id - b.id;
              }
            }
            this.render = function(scene, camera, renderTarget, forceClear) {
              if (camera !== void 0 && camera.isCamera !== true) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return;
              }
              _currentGeometryProgram = "";
              _currentMaterialId = -1;
              _currentCamera = null;
              if (scene.autoUpdate === true)
                scene.updateMatrixWorld();
              if (camera.parent === null)
                camera.updateMatrixWorld();
              camera.matrixWorldInverse.getInverse(camera.matrixWorld);
              _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
              _frustum.setFromMatrix(_projScreenMatrix);
              lights.length = 0;
              opaqueObjectsLastIndex = -1;
              transparentObjectsLastIndex = -1;
              sprites.length = 0;
              lensFlares.length = 0;
              _localClippingEnabled = this.localClippingEnabled;
              _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
              projectObject(scene, camera);
              opaqueObjects.length = opaqueObjectsLastIndex + 1;
              transparentObjects.length = transparentObjectsLastIndex + 1;
              if (_this.sortObjects === true) {
                opaqueObjects.sort(painterSortStable);
                transparentObjects.sort(reversePainterSortStable);
              }
              if (_clippingEnabled)
                _clipping.beginShadows();
              setupShadows(lights);
              shadowMap.render(scene, camera);
              setupLights(lights, camera);
              if (_clippingEnabled)
                _clipping.endShadows();
              _infoRender.calls = 0;
              _infoRender.vertices = 0;
              _infoRender.faces = 0;
              _infoRender.points = 0;
              if (renderTarget === void 0) {
                renderTarget = null;
              }
              this.setRenderTarget(renderTarget);
              var background = scene.background;
              if (background === null) {
                glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
              } else if (background && background.isColor) {
                glClearColor(background.r, background.g, background.b, 1);
                forceClear = true;
              }
              if (this.autoClear || forceClear) {
                this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
              }
              if (background && background.isCubeTexture) {
                backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
                backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
                backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld);
                backgroundBoxMesh.material.uniforms["tCube"].value = background;
                backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld);
                objects.update(backgroundBoxMesh);
                _this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);
              } else if (background && background.isTexture) {
                backgroundPlaneMesh.material.map = background;
                objects.update(backgroundPlaneMesh);
                _this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);
              }
              if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                renderObjects(transparentObjects, scene, camera, overrideMaterial);
              } else {
                state.setBlending(NoBlending);
                renderObjects(opaqueObjects, scene, camera);
                renderObjects(transparentObjects, scene, camera);
              }
              spritePlugin.render(scene, camera);
              lensFlarePlugin.render(scene, camera, _currentViewport);
              if (renderTarget) {
                textures.updateRenderTargetMipmap(renderTarget);
              }
              state.setDepthTest(true);
              state.setDepthWrite(true);
              state.setColorWrite(true);
            };
            function pushRenderItem(object, geometry, material, z, group) {
              var array, index;
              if (material.transparent) {
                array = transparentObjects;
                index = ++transparentObjectsLastIndex;
              } else {
                array = opaqueObjects;
                index = ++opaqueObjectsLastIndex;
              }
              var renderItem = array[index];
              if (renderItem !== void 0) {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.z = _vector3.z;
                renderItem.group = group;
              } else {
                renderItem = {
                  id: object.id,
                  object,
                  geometry,
                  material,
                  z: _vector3.z,
                  group
                };
                array.push(renderItem);
              }
            }
            function isObjectViewable(object) {
              var geometry = object.geometry;
              if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
              _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
              return isSphereViewable(_sphere);
            }
            function isSpriteViewable(sprite) {
              _sphere.center.set(0, 0, 0);
              _sphere.radius = 0.7071067811865476;
              _sphere.applyMatrix4(sprite.matrixWorld);
              return isSphereViewable(_sphere);
            }
            function isSphereViewable(sphere) {
              if (!_frustum.intersectsSphere(sphere))
                return false;
              var numPlanes = _clipping.numPlanes;
              if (numPlanes === 0)
                return true;
              var planes = _this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
              do {
                if (planes[i].distanceToPoint(center) < negRad)
                  return false;
              } while (++i !== numPlanes);
              return true;
            }
            function projectObject(object, camera) {
              if (object.visible === false)
                return;
              var visible = (object.layers.mask & camera.layers.mask) !== 0;
              if (visible) {
                if (object.isLight) {
                  lights.push(object);
                } else if (object.isSprite) {
                  if (object.frustumCulled === false || isSpriteViewable(object) === true) {
                    sprites.push(object);
                  }
                } else if (object.isLensFlare) {
                  lensFlares.push(object);
                } else if (object.isImmediateRenderObject) {
                  if (_this.sortObjects === true) {
                    _vector3.setFromMatrixPosition(object.matrixWorld);
                    _vector3.applyProjection(_projScreenMatrix);
                  }
                  pushRenderItem(object, null, object.material, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {
                  if (object.isSkinnedMesh) {
                    object.skeleton.update();
                  }
                  if (object.frustumCulled === false || isObjectViewable(object) === true) {
                    var material = object.material;
                    if (material.visible === true) {
                      if (_this.sortObjects === true) {
                        _vector3.setFromMatrixPosition(object.matrixWorld);
                        _vector3.applyProjection(_projScreenMatrix);
                      }
                      var geometry = objects.update(object);
                      if (material.isMultiMaterial) {
                        var groups = geometry.groups;
                        var materials = material.materials;
                        for (var i = 0, l = groups.length; i < l; i++) {
                          var group = groups[i];
                          var groupMaterial = materials[group.materialIndex];
                          if (groupMaterial.visible === true) {
                            pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                          }
                        }
                      } else {
                        pushRenderItem(object, geometry, material, _vector3.z, null);
                      }
                    }
                  }
                }
              }
              var children = object.children;
              for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera);
              }
            }
            function renderObjects(renderList, scene, camera, overrideMaterial) {
              for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                object.onBeforeRender(_this, scene, camera, geometry, material, group);
                if (object.isImmediateRenderObject) {
                  setMaterial(material);
                  var program = setProgram(camera, scene.fog, material, object);
                  _currentGeometryProgram = "";
                  object.render(function(object2) {
                    _this.renderBufferImmediate(object2, program, material);
                  });
                } else {
                  _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
                }
                object.onAfterRender(_this, scene, camera, geometry, material, group);
              }
            }
            function initMaterial(material, fog, object) {
              var materialProperties = properties.get(material);
              var parameters2 = programCache.getParameters(
                material,
                _lights,
                fog,
                _clipping.numPlanes,
                _clipping.numIntersection,
                object
              );
              var code = programCache.getProgramCode(material, parameters2);
              var program = materialProperties.program;
              var programChange = true;
              if (program === void 0) {
                material.addEventListener("dispose", onMaterialDispose);
              } else if (program.code !== code) {
                releaseMaterialProgramReference(material);
              } else if (parameters2.shaderID !== void 0) {
                return;
              } else {
                programChange = false;
              }
              if (programChange) {
                if (parameters2.shaderID) {
                  var shader = ShaderLib[parameters2.shaderID];
                  materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: UniformsUtils.clone(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                  };
                } else {
                  materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                  };
                }
                material.__webglShader = materialProperties.__webglShader;
                program = programCache.acquireProgram(material, parameters2, code);
                materialProperties.program = program;
                material.program = program;
              }
              var attributes2 = program.getAttributes();
              if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) {
                  if (attributes2["morphTarget" + i] >= 0) {
                    material.numSupportedMorphTargets++;
                  }
                }
              }
              if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) {
                  if (attributes2["morphNormal" + i] >= 0) {
                    material.numSupportedMorphNormals++;
                  }
                }
              }
              var uniforms = materialProperties.__webglShader.uniforms;
              if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
              }
              materialProperties.fog = fog;
              materialProperties.lightsHash = _lights.hash;
              if (material.lights) {
                uniforms.ambientLightColor.value = _lights.ambient;
                uniforms.directionalLights.value = _lights.directional;
                uniforms.spotLights.value = _lights.spot;
                uniforms.pointLights.value = _lights.point;
                uniforms.hemisphereLights.value = _lights.hemi;
                uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
                uniforms.spotShadowMap.value = _lights.spotShadowMap;
                uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
                uniforms.pointShadowMap.value = _lights.pointShadowMap;
                uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
              }
              var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
              materialProperties.uniformsList = uniformsList;
            }
            function setMaterial(material) {
              material.side === DoubleSide ? state.disable(_gl.CULL_FACE) : state.enable(_gl.CULL_FACE);
              state.setFlipSided(material.side === BackSide);
              material.transparent === true ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(NoBlending);
              state.setDepthFunc(material.depthFunc);
              state.setDepthTest(material.depthTest);
              state.setDepthWrite(material.depthWrite);
              state.setColorWrite(material.colorWrite);
              state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
            }
            function setProgram(camera, fog, material, object) {
              _usedTextureUnits = 0;
              var materialProperties = properties.get(material);
              if (_clippingEnabled) {
                if (_localClippingEnabled || camera !== _currentCamera) {
                  var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                  _clipping.setState(
                    material.clippingPlanes,
                    material.clipIntersection,
                    material.clipShadows,
                    camera,
                    materialProperties,
                    useCache
                  );
                }
              }
              if (material.needsUpdate === false) {
                if (materialProperties.program === void 0) {
                  material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {
                  material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {
                  material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                  material.needsUpdate = true;
                }
              }
              if (material.needsUpdate) {
                initMaterial(material, fog, object);
                material.needsUpdate = false;
              }
              var refreshProgram = false;
              var refreshMaterial = false;
              var refreshLights = false;
              var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
              if (program.id !== _currentProgram) {
                _gl.useProgram(program.program);
                _currentProgram = program.id;
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
              }
              if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
              }
              if (refreshProgram || camera !== _currentCamera) {
                p_uniforms.set(_gl, camera, "projectionMatrix");
                if (capabilities.logarithmicDepthBuffer) {
                  p_uniforms.setValue(
                    _gl,
                    "logDepthBufFC",
                    2 / (Math.log(camera.far + 1) / Math.LN2)
                  );
                }
                if (camera !== _currentCamera) {
                  _currentCamera = camera;
                  refreshMaterial = true;
                  refreshLights = true;
                }
                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                  var uCamPos = p_uniforms.map.cameraPosition;
                  if (uCamPos !== void 0) {
                    uCamPos.setValue(
                      _gl,
                      _vector3.setFromMatrixPosition(camera.matrixWorld)
                    );
                  }
                }
                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                  p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
                }
                p_uniforms.set(_gl, _this, "toneMappingExposure");
                p_uniforms.set(_gl, _this, "toneMappingWhitePoint");
              }
              if (material.skinning) {
                p_uniforms.setOptional(_gl, object, "bindMatrix");
                p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                var skeleton = object.skeleton;
                if (skeleton) {
                  if (capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                    p_uniforms.set(_gl, skeleton, "boneTexture");
                    p_uniforms.set(_gl, skeleton, "boneTextureWidth");
                    p_uniforms.set(_gl, skeleton, "boneTextureHeight");
                  } else {
                    p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
                  }
                }
              }
              if (refreshMaterial) {
                if (material.lights) {
                  markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                if (fog && material.fog) {
                  refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshDepthMaterial) {
                  refreshUniformsCommon(m_uniforms, material);
                }
                if (material.isLineBasicMaterial) {
                  refreshUniformsLine(m_uniforms, material);
                } else if (material.isLineDashedMaterial) {
                  refreshUniformsLine(m_uniforms, material);
                  refreshUniformsDash(m_uniforms, material);
                } else if (material.isPointsMaterial) {
                  refreshUniformsPoints(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {
                  refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {
                  refreshUniformsPhong(m_uniforms, material);
                } else if (material.isMeshPhysicalMaterial) {
                  refreshUniformsPhysical(m_uniforms, material);
                } else if (material.isMeshStandardMaterial) {
                  refreshUniformsStandard(m_uniforms, material);
                } else if (material.isMeshDepthMaterial) {
                  if (material.displacementMap) {
                    m_uniforms.displacementMap.value = material.displacementMap;
                    m_uniforms.displacementScale.value = material.displacementScale;
                    m_uniforms.displacementBias.value = material.displacementBias;
                  }
                } else if (material.isMeshNormalMaterial) {
                  m_uniforms.opacity.value = material.opacity;
                }
                WebGLUniforms.upload(
                  _gl,
                  materialProperties.uniformsList,
                  m_uniforms,
                  _this
                );
              }
              p_uniforms.set(_gl, object, "modelViewMatrix");
              p_uniforms.set(_gl, object, "normalMatrix");
              p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
              return program;
            }
            function refreshUniformsCommon(uniforms, material) {
              uniforms.opacity.value = material.opacity;
              uniforms.diffuse.value = material.color;
              if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
              }
              uniforms.map.value = material.map;
              uniforms.specularMap.value = material.specularMap;
              uniforms.alphaMap.value = material.alphaMap;
              if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
              }
              var uvScaleMap;
              if (material.map) {
                uvScaleMap = material.map;
              } else if (material.specularMap) {
                uvScaleMap = material.specularMap;
              } else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
              } else if (material.normalMap) {
                uvScaleMap = material.normalMap;
              } else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
              } else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
              } else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
              } else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
              } else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
              }
              if (uvScaleMap !== void 0) {
                if (uvScaleMap.isWebGLRenderTarget) {
                  uvScaleMap = uvScaleMap.texture;
                }
                var offset = uvScaleMap.offset;
                var repeat = uvScaleMap.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
              }
              uniforms.envMap.value = material.envMap;
              uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
              uniforms.reflectivity.value = material.reflectivity;
              uniforms.refractionRatio.value = material.refractionRatio;
            }
            function refreshUniformsLine(uniforms, material) {
              uniforms.diffuse.value = material.color;
              uniforms.opacity.value = material.opacity;
            }
            function refreshUniformsDash(uniforms, material) {
              uniforms.dashSize.value = material.dashSize;
              uniforms.totalSize.value = material.dashSize + material.gapSize;
              uniforms.scale.value = material.scale;
            }
            function refreshUniformsPoints(uniforms, material) {
              uniforms.diffuse.value = material.color;
              uniforms.opacity.value = material.opacity;
              uniforms.size.value = material.size * _pixelRatio;
              uniforms.scale.value = _height * 0.5;
              uniforms.map.value = material.map;
              if (material.map !== null) {
                var offset = material.map.offset;
                var repeat = material.map.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
              }
            }
            function refreshUniformsFog(uniforms, fog) {
              uniforms.fogColor.value = fog.color;
              if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
              } else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
              }
            }
            function refreshUniformsLambert(uniforms, material) {
              if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
              }
              if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
              }
            }
            function refreshUniformsPhong(uniforms, material) {
              uniforms.specular.value = material.specular;
              uniforms.shininess.value = Math.max(material.shininess, 1e-4);
              if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
              }
              if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
              }
              if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
              }
              if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
              }
              if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
              }
            }
            function refreshUniformsStandard(uniforms, material) {
              uniforms.roughness.value = material.roughness;
              uniforms.metalness.value = material.metalness;
              if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
              }
              if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
              }
              if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
              }
              if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
              }
              if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
              }
              if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
              }
              if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
              }
              if (material.envMap) {
                uniforms.envMapIntensity.value = material.envMapIntensity;
              }
            }
            function refreshUniformsPhysical(uniforms, material) {
              uniforms.clearCoat.value = material.clearCoat;
              uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
              refreshUniformsStandard(uniforms, material);
            }
            function markUniformsLightsNeedsUpdate(uniforms, value) {
              uniforms.ambientLightColor.needsUpdate = value;
              uniforms.directionalLights.needsUpdate = value;
              uniforms.pointLights.needsUpdate = value;
              uniforms.spotLights.needsUpdate = value;
              uniforms.hemisphereLights.needsUpdate = value;
            }
            function setupShadows(lights2) {
              var lightShadowsLength = 0;
              for (var i = 0, l = lights2.length; i < l; i++) {
                var light = lights2[i];
                if (light.castShadow) {
                  _lights.shadows[lightShadowsLength++] = light;
                }
              }
              _lights.shadows.length = lightShadowsLength;
            }
            function setupLights(lights2, camera) {
              var l, ll, light, r = 0, g = 0, b = 0, color, intensity, distance, shadowMap2, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
              for (l = 0, ll = lights2.length; l < ll; l++) {
                light = lights2[l];
                color = light.color;
                intensity = light.intensity;
                distance = light.distance;
                shadowMap2 = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                  r += color.r * intensity;
                  g += color.g * intensity;
                  b += color.b * intensity;
                } else if (light.isDirectionalLight) {
                  var uniforms = lightCache.get(light);
                  uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  _vector3.setFromMatrixPosition(light.target.matrixWorld);
                  uniforms.direction.sub(_vector3);
                  uniforms.direction.transformDirection(viewMatrix);
                  uniforms.shadow = light.castShadow;
                  if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                  }
                  _lights.directionalShadowMap[directionalLength] = shadowMap2;
                  _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                  _lights.directional[directionalLength++] = uniforms;
                } else if (light.isSpotLight) {
                  var uniforms = lightCache.get(light);
                  uniforms.position.setFromMatrixPosition(light.matrixWorld);
                  uniforms.position.applyMatrix4(viewMatrix);
                  uniforms.color.copy(color).multiplyScalar(intensity);
                  uniforms.distance = distance;
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  _vector3.setFromMatrixPosition(light.target.matrixWorld);
                  uniforms.direction.sub(_vector3);
                  uniforms.direction.transformDirection(viewMatrix);
                  uniforms.coneCos = Math.cos(light.angle);
                  uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                  uniforms.decay = light.distance === 0 ? 0 : light.decay;
                  uniforms.shadow = light.castShadow;
                  if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                  }
                  _lights.spotShadowMap[spotLength] = shadowMap2;
                  _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                  _lights.spot[spotLength++] = uniforms;
                } else if (light.isPointLight) {
                  var uniforms = lightCache.get(light);
                  uniforms.position.setFromMatrixPosition(light.matrixWorld);
                  uniforms.position.applyMatrix4(viewMatrix);
                  uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                  uniforms.distance = light.distance;
                  uniforms.decay = light.distance === 0 ? 0 : light.decay;
                  uniforms.shadow = light.castShadow;
                  if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                  }
                  _lights.pointShadowMap[pointLength] = shadowMap2;
                  if (_lights.pointShadowMatrix[pointLength] === void 0) {
                    _lights.pointShadowMatrix[pointLength] = new Matrix4();
                  }
                  _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                  _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
                  _lights.point[pointLength++] = uniforms;
                } else if (light.isHemisphereLight) {
                  var uniforms = lightCache.get(light);
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                  uniforms.direction.transformDirection(viewMatrix);
                  uniforms.direction.normalize();
                  uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                  uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                  _lights.hemi[hemiLength++] = uniforms;
                }
              }
              _lights.ambient[0] = r;
              _lights.ambient[1] = g;
              _lights.ambient[2] = b;
              _lights.directional.length = directionalLength;
              _lights.spot.length = spotLength;
              _lights.point.length = pointLength;
              _lights.hemi.length = hemiLength;
              _lights.hash = directionalLength + "," + pointLength + "," + spotLength + "," + hemiLength + "," + _lights.shadows.length;
            }
            this.setFaceCulling = function(cullFace, frontFaceDirection) {
              state.setCullFace(cullFace);
              state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
            };
            function allocTextureUnit() {
              var textureUnit = _usedTextureUnits;
              if (textureUnit >= capabilities.maxTextures) {
                console.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
              }
              _usedTextureUnits += 1;
              return textureUnit;
            }
            this.allocTextureUnit = allocTextureUnit;
            this.setTexture2D = /* @__PURE__ */ function() {
              var warned = false;
              return function setTexture2D(texture, slot) {
                if (texture && texture.isWebGLRenderTarget) {
                  if (!warned) {
                    console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                    warned = true;
                  }
                  texture = texture.texture;
                }
                textures.setTexture2D(texture, slot);
              };
            }();
            this.setTexture = /* @__PURE__ */ function() {
              var warned = false;
              return function setTexture(texture, slot) {
                if (!warned) {
                  console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                  warned = true;
                }
                textures.setTexture2D(texture, slot);
              };
            }();
            this.setTextureCube = /* @__PURE__ */ function() {
              var warned = false;
              return function setTextureCube(texture, slot) {
                if (texture && texture.isWebGLRenderTargetCube) {
                  if (!warned) {
                    console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                    warned = true;
                  }
                  texture = texture.texture;
                }
                if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
                  textures.setTextureCube(texture, slot);
                } else {
                  textures.setTextureCubeDynamic(texture, slot);
                }
              };
            }();
            this.getCurrentRenderTarget = function() {
              return _currentRenderTarget;
            };
            this.setRenderTarget = function(renderTarget) {
              _currentRenderTarget = renderTarget;
              if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
                textures.setupRenderTarget(renderTarget);
              }
              var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
              var framebuffer;
              if (renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                if (isCube) {
                  framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
                } else {
                  framebuffer = renderTargetProperties.__webglFramebuffer;
                }
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
                _currentViewport.copy(renderTarget.viewport);
              } else {
                framebuffer = null;
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
              }
              if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
              }
              state.scissor(_currentScissor);
              state.setScissorTest(_currentScissorTest);
              state.viewport(_currentViewport);
              if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
              }
            };
            this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
              if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return;
              }
              var framebuffer = properties.get(renderTarget).__webglFramebuffer;
              if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                  _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                  restore = true;
                }
                try {
                  var texture = renderTarget.texture;
                  var textureFormat = texture.format;
                  var textureType = texture.type;
                  if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                  }
                  if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                  !(textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
                  !(textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                  }
                  if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                      _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                    }
                  } else {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                  }
                } finally {
                  if (restore) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                  }
                }
              }
            };
            function paramThreeToGL(p) {
              var extension;
              if (p === RepeatWrapping)
                return _gl.REPEAT;
              if (p === ClampToEdgeWrapping)
                return _gl.CLAMP_TO_EDGE;
              if (p === MirroredRepeatWrapping)
                return _gl.MIRRORED_REPEAT;
              if (p === NearestFilter)
                return _gl.NEAREST;
              if (p === NearestMipMapNearestFilter)
                return _gl.NEAREST_MIPMAP_NEAREST;
              if (p === NearestMipMapLinearFilter)
                return _gl.NEAREST_MIPMAP_LINEAR;
              if (p === LinearFilter)
                return _gl.LINEAR;
              if (p === LinearMipMapNearestFilter)
                return _gl.LINEAR_MIPMAP_NEAREST;
              if (p === LinearMipMapLinearFilter)
                return _gl.LINEAR_MIPMAP_LINEAR;
              if (p === UnsignedByteType)
                return _gl.UNSIGNED_BYTE;
              if (p === UnsignedShort4444Type)
                return _gl.UNSIGNED_SHORT_4_4_4_4;
              if (p === UnsignedShort5551Type)
                return _gl.UNSIGNED_SHORT_5_5_5_1;
              if (p === UnsignedShort565Type)
                return _gl.UNSIGNED_SHORT_5_6_5;
              if (p === ByteType)
                return _gl.BYTE;
              if (p === ShortType)
                return _gl.SHORT;
              if (p === UnsignedShortType)
                return _gl.UNSIGNED_SHORT;
              if (p === IntType)
                return _gl.INT;
              if (p === UnsignedIntType)
                return _gl.UNSIGNED_INT;
              if (p === FloatType)
                return _gl.FLOAT;
              if (p === HalfFloatType) {
                extension = extensions.get("OES_texture_half_float");
                if (extension !== null)
                  return extension.HALF_FLOAT_OES;
              }
              if (p === AlphaFormat)
                return _gl.ALPHA;
              if (p === RGBFormat)
                return _gl.RGB;
              if (p === RGBAFormat)
                return _gl.RGBA;
              if (p === LuminanceFormat)
                return _gl.LUMINANCE;
              if (p === LuminanceAlphaFormat)
                return _gl.LUMINANCE_ALPHA;
              if (p === DepthFormat)
                return _gl.DEPTH_COMPONENT;
              if (p === DepthStencilFormat)
                return _gl.DEPTH_STENCIL;
              if (p === AddEquation)
                return _gl.FUNC_ADD;
              if (p === SubtractEquation)
                return _gl.FUNC_SUBTRACT;
              if (p === ReverseSubtractEquation)
                return _gl.FUNC_REVERSE_SUBTRACT;
              if (p === ZeroFactor)
                return _gl.ZERO;
              if (p === OneFactor)
                return _gl.ONE;
              if (p === SrcColorFactor)
                return _gl.SRC_COLOR;
              if (p === OneMinusSrcColorFactor)
                return _gl.ONE_MINUS_SRC_COLOR;
              if (p === SrcAlphaFactor)
                return _gl.SRC_ALPHA;
              if (p === OneMinusSrcAlphaFactor)
                return _gl.ONE_MINUS_SRC_ALPHA;
              if (p === DstAlphaFactor)
                return _gl.DST_ALPHA;
              if (p === OneMinusDstAlphaFactor)
                return _gl.ONE_MINUS_DST_ALPHA;
              if (p === DstColorFactor)
                return _gl.DST_COLOR;
              if (p === OneMinusDstColorFactor)
                return _gl.ONE_MINUS_DST_COLOR;
              if (p === SrcAlphaSaturateFactor)
                return _gl.SRC_ALPHA_SATURATE;
              if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get("WEBGL_compressed_texture_s3tc");
                if (extension !== null) {
                  if (p === RGB_S3TC_DXT1_Format)
                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT1_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT3_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (p === RGBA_S3TC_DXT5_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              }
              if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get("WEBGL_compressed_texture_pvrtc");
                if (extension !== null) {
                  if (p === RGB_PVRTC_4BPPV1_Format)
                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (p === RGB_PVRTC_2BPPV1_Format)
                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (p === RGBA_PVRTC_4BPPV1_Format)
                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (p === RGBA_PVRTC_2BPPV1_Format)
                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
              }
              if (p === RGB_ETC1_Format) {
                extension = extensions.get("WEBGL_compressed_texture_etc1");
                if (extension !== null)
                  return extension.COMPRESSED_RGB_ETC1_WEBGL;
              }
              if (p === MinEquation || p === MaxEquation) {
                extension = extensions.get("EXT_blend_minmax");
                if (extension !== null) {
                  if (p === MinEquation)
                    return extension.MIN_EXT;
                  if (p === MaxEquation)
                    return extension.MAX_EXT;
                }
              }
              if (p === UnsignedInt248Type) {
                extension = extensions.get("WEBGL_depth_texture");
                if (extension !== null)
                  return extension.UNSIGNED_INT_24_8_WEBGL;
              }
              return 0;
            }
          }
          function FogExp2(color, density) {
            this.name = "";
            this.color = new Color(color);
            this.density = density !== void 0 ? density : 25e-5;
          }
          FogExp2.prototype.isFogExp2 = true;
          FogExp2.prototype.clone = function() {
            return new FogExp2(this.color.getHex(), this.density);
          };
          FogExp2.prototype.toJSON = function(meta) {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density
            };
          };
          function Fog(color, near, far) {
            this.name = "";
            this.color = new Color(color);
            this.near = near !== void 0 ? near : 1;
            this.far = far !== void 0 ? far : 1e3;
          }
          Fog.prototype.isFog = true;
          Fog.prototype.clone = function() {
            return new Fog(this.color.getHex(), this.near, this.far);
          };
          Fog.prototype.toJSON = function(meta) {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far
            };
          };
          function Scene() {
            Object3D.call(this);
            this.type = "Scene";
            this.background = null;
            this.fog = null;
            this.overrideMaterial = null;
            this.autoUpdate = true;
          }
          Scene.prototype = Object.create(Object3D.prototype);
          Scene.prototype.constructor = Scene;
          Scene.prototype.copy = function(source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            if (source.background !== null)
              this.background = source.background.clone();
            if (source.fog !== null)
              this.fog = source.fog.clone();
            if (source.overrideMaterial !== null)
              this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
          };
          Scene.prototype.toJSON = function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            if (this.background !== null)
              data.object.background = this.background.toJSON(meta);
            if (this.fog !== null)
              data.object.fog = this.fog.toJSON();
            return data;
          };
          function LensFlare(texture, size, distance, blending, color) {
            Object3D.call(this);
            this.lensFlares = [];
            this.positionScreen = new Vector3();
            this.customUpdateCallback = void 0;
            if (texture !== void 0) {
              this.add(texture, size, distance, blending, color);
            }
          }
          LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: LensFlare,
            isLensFlare: true,
            copy: function(source) {
              Object3D.prototype.copy.call(this, source);
              this.positionScreen.copy(source.positionScreen);
              this.customUpdateCallback = source.customUpdateCallback;
              for (var i = 0, l = source.lensFlares.length; i < l; i++) {
                this.lensFlares.push(source.lensFlares[i]);
              }
              return this;
            },
            add: function(texture, size, distance, blending, color, opacity) {
              if (size === void 0)
                size = -1;
              if (distance === void 0)
                distance = 0;
              if (opacity === void 0)
                opacity = 1;
              if (color === void 0)
                color = new Color(16777215);
              if (blending === void 0)
                blending = NormalBlending;
              distance = Math.min(distance, Math.max(0, distance));
              this.lensFlares.push({
                texture,
                // THREE.Texture
                size,
                // size in pixels (-1 = use texture.width)
                distance,
                // distance (0-1) from light source (0=at light source)
                x: 0,
                y: 0,
                z: 0,
                // screen position (-1 => 1) z = 0 is in front z = 1 is back
                scale: 1,
                // scale
                rotation: 0,
                // rotation
                opacity,
                // opacity
                color,
                // color
                blending
                // blending
              });
            },
            /*
             * Update lens flares update positions on all flares based on the screen position
             * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
             */
            updateLensFlares: function() {
              var f, fl = this.lensFlares.length;
              var flare;
              var vecX = -this.positionScreen.x * 2;
              var vecY = -this.positionScreen.y * 2;
              for (f = 0; f < fl; f++) {
                flare = this.lensFlares[f];
                flare.x = this.positionScreen.x + vecX * flare.distance;
                flare.y = this.positionScreen.y + vecY * flare.distance;
                flare.wantedRotation = flare.x * Math.PI * 0.25;
                flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
              }
            }
          });
          function SpriteMaterial(parameters) {
            Material.call(this);
            this.type = "SpriteMaterial";
            this.color = new Color(16777215);
            this.map = null;
            this.rotation = 0;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
          }
          SpriteMaterial.prototype = Object.create(Material.prototype);
          SpriteMaterial.prototype.constructor = SpriteMaterial;
          SpriteMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.rotation = source.rotation;
            return this;
          };
          function Sprite(material) {
            Object3D.call(this);
            this.type = "Sprite";
            this.material = material !== void 0 ? material : new SpriteMaterial();
          }
          Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Sprite,
            isSprite: true,
            raycast: function() {
              var matrixPosition = new Vector3();
              return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
                var guessSizeSq = this.scale.x * this.scale.y / 4;
                if (distanceSq > guessSizeSq) {
                  return;
                }
                intersects.push({
                  distance: Math.sqrt(distanceSq),
                  point: this.position,
                  face: null,
                  object: this
                });
              };
            }(),
            clone: function() {
              return new this.constructor(this.material).copy(this);
            }
          });
          function LOD() {
            Object3D.call(this);
            this.type = "LOD";
            Object.defineProperties(this, {
              levels: {
                enumerable: true,
                value: []
              }
            });
          }
          LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: LOD,
            copy: function(source) {
              Object3D.prototype.copy.call(this, source, false);
              var levels = source.levels;
              for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
              }
              return this;
            },
            addLevel: function(object, distance) {
              if (distance === void 0)
                distance = 0;
              distance = Math.abs(distance);
              var levels = this.levels;
              for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                  break;
                }
              }
              levels.splice(l, 0, { distance, object });
              this.add(object);
            },
            getObjectForDistance: function(distance) {
              var levels = this.levels;
              for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                  break;
                }
              }
              return levels[i - 1].object;
            },
            raycast: function() {
              var matrixPosition = new Vector3();
              return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
              };
            }(),
            update: function() {
              var v1 = new Vector3();
              var v2 = new Vector3();
              return function update(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                  v1.setFromMatrixPosition(camera.matrixWorld);
                  v2.setFromMatrixPosition(this.matrixWorld);
                  var distance = v1.distanceTo(v2);
                  levels[0].object.visible = true;
                  for (var i = 1, l = levels.length; i < l; i++) {
                    if (distance >= levels[i].distance) {
                      levels[i - 1].object.visible = false;
                      levels[i].object.visible = true;
                    } else {
                      break;
                    }
                  }
                  for (; i < l; i++) {
                    levels[i].object.visible = false;
                  }
                }
              };
            }(),
            toJSON: function(meta) {
              var data = Object3D.prototype.toJSON.call(this, meta);
              data.object.levels = [];
              var levels = this.levels;
              for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                  object: level.object.uuid,
                  distance: level.distance
                });
              }
              return data;
            }
          });
          function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.image = { data, width, height };
            this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
            this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
          }
          DataTexture.prototype = Object.create(Texture.prototype);
          DataTexture.prototype.constructor = DataTexture;
          DataTexture.prototype.isDataTexture = true;
          function Skeleton(bones, boneInverses, useVertexTexture) {
            this.useVertexTexture = useVertexTexture !== void 0 ? useVertexTexture : true;
            this.identityMatrix = new Matrix4();
            bones = bones || [];
            this.bones = bones.slice(0);
            if (this.useVertexTexture) {
              var size = Math.sqrt(this.bones.length * 4);
              size = _Math.nextPowerOfTwo(Math.ceil(size));
              size = Math.max(size, 4);
              this.boneTextureWidth = size;
              this.boneTextureHeight = size;
              this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
              this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType);
            } else {
              this.boneMatrices = new Float32Array(16 * this.bones.length);
            }
            if (boneInverses === void 0) {
              this.calculateInverses();
            } else {
              if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
              } else {
                console.warn("THREE.Skeleton bonInverses is the wrong length.");
                this.boneInverses = [];
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                  this.boneInverses.push(new Matrix4());
                }
              }
            }
          }
          Object.assign(Skeleton.prototype, {
            calculateInverses: function() {
              this.boneInverses = [];
              for (var b = 0, bl = this.bones.length; b < bl; b++) {
                var inverse = new Matrix4();
                if (this.bones[b]) {
                  inverse.getInverse(this.bones[b].matrixWorld);
                }
                this.boneInverses.push(inverse);
              }
            },
            pose: function() {
              var bone;
              for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                  bone.matrixWorld.getInverse(this.boneInverses[b]);
                }
              }
              for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                  if (bone.parent && bone.parent.isBone) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                  } else {
                    bone.matrix.copy(bone.matrixWorld);
                  }
                  bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
              }
            },
            update: function() {
              var offsetMatrix = new Matrix4();
              return function update() {
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                  var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                  offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
                  offsetMatrix.toArray(this.boneMatrices, b * 16);
                }
                if (this.useVertexTexture) {
                  this.boneTexture.needsUpdate = true;
                }
              };
            }(),
            clone: function() {
              return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
            }
          });
          function Bone(skin) {
            Object3D.call(this);
            this.type = "Bone";
            this.skin = skin;
          }
          Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Bone,
            isBone: true,
            copy: function(source) {
              Object3D.prototype.copy.call(this, source);
              this.skin = source.skin;
              return this;
            }
          });
          function SkinnedMesh(geometry, material, useVertexTexture) {
            Mesh.call(this, geometry, material);
            this.type = "SkinnedMesh";
            this.bindMode = "attached";
            this.bindMatrix = new Matrix4();
            this.bindMatrixInverse = new Matrix4();
            var bones = [];
            if (this.geometry && this.geometry.bones !== void 0) {
              var bone, gbone;
              for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                bone = new Bone(this);
                bones.push(bone);
                bone.name = gbone.name;
                bone.position.fromArray(gbone.pos);
                bone.quaternion.fromArray(gbone.rotq);
                if (gbone.scl !== void 0)
                  bone.scale.fromArray(gbone.scl);
              }
              for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
                  bones[gbone.parent].add(bones[b]);
                } else {
                  this.add(bones[b]);
                }
              }
            }
            this.normalizeSkinWeights();
            this.updateMatrixWorld(true);
            this.bind(new Skeleton(bones, void 0, useVertexTexture), this.matrixWorld);
          }
          SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
            constructor: SkinnedMesh,
            isSkinnedMesh: true,
            bind: function(skeleton, bindMatrix) {
              this.skeleton = skeleton;
              if (bindMatrix === void 0) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
              }
              this.bindMatrix.copy(bindMatrix);
              this.bindMatrixInverse.getInverse(bindMatrix);
            },
            pose: function() {
              this.skeleton.pose();
            },
            normalizeSkinWeights: function() {
              if (this.geometry && this.geometry.isGeometry) {
                for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                  var sw = this.geometry.skinWeights[i];
                  var scale = 1 / sw.lengthManhattan();
                  if (scale !== Infinity) {
                    sw.multiplyScalar(scale);
                  } else {
                    sw.set(1, 0, 0, 0);
                  }
                }
              } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4();
                var skinWeight = this.geometry.attributes.skinWeight;
                for (var i = 0; i < skinWeight.count; i++) {
                  vec.x = skinWeight.getX(i);
                  vec.y = skinWeight.getY(i);
                  vec.z = skinWeight.getZ(i);
                  vec.w = skinWeight.getW(i);
                  var scale = 1 / vec.lengthManhattan();
                  if (scale !== Infinity) {
                    vec.multiplyScalar(scale);
                  } else {
                    vec.set(1, 0, 0, 0);
                  }
                  skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
              }
            },
            updateMatrixWorld: function(force) {
              Mesh.prototype.updateMatrixWorld.call(this, true);
              if (this.bindMode === "attached") {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
              } else if (this.bindMode === "detached") {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
              } else {
                console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode);
              }
            },
            clone: function() {
              return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
            }
          });
          function LineBasicMaterial(parameters) {
            Material.call(this);
            this.type = "LineBasicMaterial";
            this.color = new Color(16777215);
            this.linewidth = 1;
            this.linecap = "round";
            this.linejoin = "round";
            this.lights = false;
            this.setValues(parameters);
          }
          LineBasicMaterial.prototype = Object.create(Material.prototype);
          LineBasicMaterial.prototype.constructor = LineBasicMaterial;
          LineBasicMaterial.prototype.isLineBasicMaterial = true;
          LineBasicMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.linewidth = source.linewidth;
            this.linecap = source.linecap;
            this.linejoin = source.linejoin;
            return this;
          };
          function Line(geometry, material, mode) {
            if (mode === 1) {
              console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.");
              return new LineSegments(geometry, material);
            }
            Object3D.call(this);
            this.type = "Line";
            this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
            this.material = material !== void 0 ? material : new LineBasicMaterial({ color: Math.random() * 16777215 });
          }
          Line.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Line,
            isLine: true,
            raycast: function() {
              var inverseMatrix = new Matrix4();
              var ray = new Ray();
              var sphere = new Sphere();
              return function raycast(raycaster, intersects) {
                var precision = raycaster.linePrecision;
                var precisionSq = precision * precision;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false)
                  return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var vStart = new Vector3();
                var vEnd = new Vector3();
                var interSegment = new Vector3();
                var interRay = new Vector3();
                var step = this && this.isLineSegments ? 2 : 1;
                if (geometry && geometry.isBufferGeometry) {
                  var index = geometry.index;
                  var attributes = geometry.attributes;
                  var positions = attributes.position.array;
                  if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length - 1; i < l; i += step) {
                      var a = indices[i];
                      var b = indices[i + 1];
                      vStart.fromArray(positions, a * 3);
                      vEnd.fromArray(positions, b * 3);
                      var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                      if (distSq > precisionSq)
                        continue;
                      interRay.applyMatrix4(this.matrixWorld);
                      var distance = raycaster.ray.origin.distanceTo(interRay);
                      if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                      intersects.push({
                        distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                      });
                    }
                  } else {
                    for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                      vStart.fromArray(positions, 3 * i);
                      vEnd.fromArray(positions, 3 * i + 3);
                      var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                      if (distSq > precisionSq)
                        continue;
                      interRay.applyMatrix4(this.matrixWorld);
                      var distance = raycaster.ray.origin.distanceTo(interRay);
                      if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                      intersects.push({
                        distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                      });
                    }
                  }
                } else if (geometry && geometry.isGeometry) {
                  var vertices = geometry.vertices;
                  var nbVertices = vertices.length;
                  for (var i = 0; i < nbVertices - 1; i += step) {
                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                    if (distSq > precisionSq)
                      continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                      continue;
                    intersects.push({
                      distance,
                      // What do we want? intersection point on the ray or on the segment??
                      // point: raycaster.ray.at( distance ),
                      point: interSegment.clone().applyMatrix4(this.matrixWorld),
                      index: i,
                      face: null,
                      faceIndex: null,
                      object: this
                    });
                  }
                }
              };
            }(),
            clone: function() {
              return new this.constructor(this.geometry, this.material).copy(this);
            }
          });
          function LineSegments(geometry, material) {
            Line.call(this, geometry, material);
            this.type = "LineSegments";
          }
          LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
            constructor: LineSegments,
            isLineSegments: true
          });
          function PointsMaterial(parameters) {
            Material.call(this);
            this.type = "PointsMaterial";
            this.color = new Color(16777215);
            this.map = null;
            this.size = 1;
            this.sizeAttenuation = true;
            this.lights = false;
            this.setValues(parameters);
          }
          PointsMaterial.prototype = Object.create(Material.prototype);
          PointsMaterial.prototype.constructor = PointsMaterial;
          PointsMaterial.prototype.isPointsMaterial = true;
          PointsMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;
            return this;
          };
          function Points(geometry, material) {
            Object3D.call(this);
            this.type = "Points";
            this.geometry = geometry !== void 0 ? geometry : new BufferGeometry();
            this.material = material !== void 0 ? material : new PointsMaterial({ color: Math.random() * 16777215 });
          }
          Points.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Points,
            isPoints: true,
            raycast: function() {
              var inverseMatrix = new Matrix4();
              var ray = new Ray();
              var sphere = new Sphere();
              return function raycast(raycaster, intersects) {
                var object = this;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false)
                  return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;
                var position = new Vector3();
                function testPoint(point, index2) {
                  var rayPointDistanceSq = ray.distanceSqToPoint(point);
                  if (rayPointDistanceSq < localThresholdSq) {
                    var intersectPoint = ray.closestPointToPoint(point);
                    intersectPoint.applyMatrix4(matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far)
                      return;
                    intersects.push({
                      distance,
                      distanceToRay: Math.sqrt(rayPointDistanceSq),
                      point: intersectPoint.clone(),
                      index: index2,
                      face: null,
                      object
                    });
                  }
                }
                if (geometry && geometry.isBufferGeometry) {
                  var index = geometry.index;
                  var attributes = geometry.attributes;
                  var positions = attributes.position.array;
                  if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, il = indices.length; i < il; i++) {
                      var a = indices[i];
                      position.fromArray(positions, a * 3);
                      testPoint(position, a);
                    }
                  } else {
                    for (var i = 0, l = positions.length / 3; i < l; i++) {
                      position.fromArray(positions, i * 3);
                      testPoint(position, i);
                    }
                  }
                } else {
                  var vertices = geometry.vertices;
                  for (var i = 0, l = vertices.length; i < l; i++) {
                    testPoint(vertices[i], i);
                  }
                }
              };
            }(),
            clone: function() {
              return new this.constructor(this.geometry, this.material).copy(this);
            }
          });
          function Group() {
            Object3D.call(this);
            this.type = "Group";
          }
          Group.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Group
          });
          function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.generateMipmaps = false;
            var scope = this;
            function update() {
              requestAnimationFrame(update);
              if (video.readyState >= video.HAVE_CURRENT_DATA) {
                scope.needsUpdate = true;
              }
            }
            update();
          }
          VideoTexture.prototype = Object.create(Texture.prototype);
          VideoTexture.prototype.constructor = VideoTexture;
          function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.image = { width, height };
            this.mipmaps = mipmaps;
            this.flipY = false;
            this.generateMipmaps = false;
          }
          CompressedTexture.prototype = Object.create(Texture.prototype);
          CompressedTexture.prototype.constructor = CompressedTexture;
          CompressedTexture.prototype.isCompressedTexture = true;
          function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.needsUpdate = true;
          }
          CanvasTexture.prototype = Object.create(Texture.prototype);
          CanvasTexture.prototype.constructor = CanvasTexture;
          function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
            format = format !== void 0 ? format : DepthFormat;
            if (format !== DepthFormat && format !== DepthStencilFormat) {
              throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            }
            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.image = { width, height };
            this.type = type !== void 0 ? type : UnsignedShortType;
            this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
            this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
            this.flipY = false;
            this.generateMipmaps = false;
          }
          DepthTexture.prototype = Object.create(Texture.prototype);
          DepthTexture.prototype.constructor = DepthTexture;
          DepthTexture.prototype.isDepthTexture = true;
          function WireframeGeometry(geometry) {
            BufferGeometry.call(this);
            var edge = [0, 0], hash = {};
            function sortFunction(a, b) {
              return a - b;
            }
            var keys = ["a", "b", "c"];
            if (geometry && geometry.isGeometry) {
              var vertices = geometry.vertices;
              var faces = geometry.faces;
              var numEdges = 0;
              var edges = new Uint32Array(6 * faces.length);
              for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0; j < 3; j++) {
                  edge[0] = face[keys[j]];
                  edge[1] = face[keys[(j + 1) % 3]];
                  edge.sort(sortFunction);
                  var key = edge.toString();
                  if (hash[key] === void 0) {
                    edges[2 * numEdges] = edge[0];
                    edges[2 * numEdges + 1] = edge[1];
                    hash[key] = true;
                    numEdges++;
                  }
                }
              }
              var coords = new Float32Array(numEdges * 2 * 3);
              for (var i = 0, l = numEdges; i < l; i++) {
                for (var j = 0; j < 2; j++) {
                  var vertex = vertices[edges[2 * i + j]];
                  var index = 6 * i + 3 * j;
                  coords[index + 0] = vertex.x;
                  coords[index + 1] = vertex.y;
                  coords[index + 2] = vertex.z;
                }
              }
              this.addAttribute("position", new BufferAttribute(coords, 3));
            } else if (geometry && geometry.isBufferGeometry) {
              if (geometry.index !== null) {
                var indices = geometry.index.array;
                var vertices = geometry.attributes.position;
                var groups = geometry.groups;
                var numEdges = 0;
                if (groups.length === 0) {
                  geometry.addGroup(0, indices.length);
                }
                var edges = new Uint32Array(2 * indices.length);
                for (var o = 0, ol = groups.length; o < ol; ++o) {
                  var group = groups[o];
                  var start = group.start;
                  var count2 = group.count;
                  for (var i = start, il = start + count2; i < il; i += 3) {
                    for (var j = 0; j < 3; j++) {
                      edge[0] = indices[i + j];
                      edge[1] = indices[i + (j + 1) % 3];
                      edge.sort(sortFunction);
                      var key = edge.toString();
                      if (hash[key] === void 0) {
                        edges[2 * numEdges] = edge[0];
                        edges[2 * numEdges + 1] = edge[1];
                        hash[key] = true;
                        numEdges++;
                      }
                    }
                  }
                }
                var coords = new Float32Array(numEdges * 2 * 3);
                for (var i = 0, l = numEdges; i < l; i++) {
                  for (var j = 0; j < 2; j++) {
                    var index = 6 * i + 3 * j;
                    var index2 = edges[2 * i + j];
                    coords[index + 0] = vertices.getX(index2);
                    coords[index + 1] = vertices.getY(index2);
                    coords[index + 2] = vertices.getZ(index2);
                  }
                }
                this.addAttribute("position", new BufferAttribute(coords, 3));
              } else {
                var vertices = geometry.attributes.position.array;
                var numEdges = vertices.length / 3;
                var numTris = numEdges / 3;
                var coords = new Float32Array(numEdges * 2 * 3);
                for (var i = 0, l = numTris; i < l; i++) {
                  for (var j = 0; j < 3; j++) {
                    var index = 18 * i + 6 * j;
                    var index1 = 9 * i + 3 * j;
                    coords[index + 0] = vertices[index1];
                    coords[index + 1] = vertices[index1 + 1];
                    coords[index + 2] = vertices[index1 + 2];
                    var index2 = 9 * i + 3 * ((j + 1) % 3);
                    coords[index + 3] = vertices[index2];
                    coords[index + 4] = vertices[index2 + 1];
                    coords[index + 5] = vertices[index2 + 2];
                  }
                }
                this.addAttribute("position", new BufferAttribute(coords, 3));
              }
            }
          }
          WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
          WireframeGeometry.prototype.constructor = WireframeGeometry;
          function ParametricBufferGeometry(func, slices, stacks) {
            BufferGeometry.call(this);
            this.type = "ParametricBufferGeometry";
            this.parameters = {
              func,
              slices,
              stacks
            };
            var vertices = [];
            var uvs = [];
            var i, j, p;
            var u, v;
            var sliceCount = slices + 1;
            for (i = 0; i <= stacks; i++) {
              v = i / stacks;
              for (j = 0; j <= slices; j++) {
                u = j / slices;
                p = func(u, v);
                vertices.push(p.x, p.y, p.z);
                uvs.push(u, v);
              }
            }
            var indices = [];
            var a, b, c, d;
            for (i = 0; i < stacks; i++) {
              for (j = 0; j < slices; j++) {
                a = i * sliceCount + j;
                b = i * sliceCount + j + 1;
                c = (i + 1) * sliceCount + j + 1;
                d = (i + 1) * sliceCount + j;
                indices.push(a, b, d);
                indices.push(b, c, d);
              }
            }
            this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
            this.addAttribute("position", Float32Attribute(vertices, 3));
            this.addAttribute("uv", Float32Attribute(uvs, 2));
            this.computeVertexNormals();
          }
          ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
          function ParametricGeometry(func, slices, stacks) {
            Geometry.call(this);
            this.type = "ParametricGeometry";
            this.parameters = {
              func,
              slices,
              stacks
            };
            this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
            this.mergeVertices();
          }
          ParametricGeometry.prototype = Object.create(Geometry.prototype);
          ParametricGeometry.prototype.constructor = ParametricGeometry;
          function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
            BufferGeometry.call(this);
            this.type = "PolyhedronBufferGeometry";
            this.parameters = {
              vertices,
              indices,
              radius,
              detail
            };
            radius = radius || 1;
            detail = detail || 0;
            var vertexBuffer = [];
            var uvBuffer = [];
            subdivide(detail);
            appplyRadius(radius);
            generateUVs();
            this.addAttribute("position", Float32Attribute(vertexBuffer, 3));
            this.addAttribute("normal", Float32Attribute(vertexBuffer.slice(), 3));
            this.addAttribute("uv", Float32Attribute(uvBuffer, 2));
            this.normalizeNormals();
            this.boundingSphere = new Sphere(new Vector3(), radius);
            function subdivide(detail2) {
              var a = new Vector3();
              var b = new Vector3();
              var c = new Vector3();
              for (var i = 0; i < indices.length; i += 3) {
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                subdivideFace(a, b, c, detail2);
              }
            }
            function subdivideFace(a, b, c, detail2) {
              var cols = Math.pow(2, detail2);
              var v = [];
              var i, j;
              for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                  if (j === 0 && i === cols) {
                    v[i][j] = aj;
                  } else {
                    v[i][j] = aj.clone().lerp(bj, j / rows);
                  }
                }
              }
              for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                  var k = Math.floor(j / 2);
                  if (j % 2 === 0) {
                    pushVertex(v[i][k + 1]);
                    pushVertex(v[i + 1][k]);
                    pushVertex(v[i][k]);
                  } else {
                    pushVertex(v[i][k + 1]);
                    pushVertex(v[i + 1][k + 1]);
                    pushVertex(v[i + 1][k]);
                  }
                }
              }
            }
            function appplyRadius(radius2) {
              var vertex = new Vector3();
              for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius2);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
              }
            }
            function generateUVs() {
              var vertex = new Vector3();
              for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
              }
              correctUVs();
              correctSeam();
            }
            function correctSeam() {
              for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                if (max > 0.9 && min < 0.1) {
                  if (x0 < 0.2)
                    uvBuffer[i + 0] += 1;
                  if (x1 < 0.2)
                    uvBuffer[i + 2] += 1;
                  if (x2 < 0.2)
                    uvBuffer[i + 4] += 1;
                }
              }
            }
            function pushVertex(vertex) {
              vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            }
            function getVertexByIndex(index, vertex) {
              var stride = index * 3;
              vertex.x = vertices[stride + 0];
              vertex.y = vertices[stride + 1];
              vertex.z = vertices[stride + 2];
            }
            function correctUVs() {
              var a = new Vector3();
              var b = new Vector3();
              var c = new Vector3();
              var centroid = new Vector3();
              var uvA = new Vector2();
              var uvB = new Vector2();
              var uvC = new Vector2();
              for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
              }
            }
            function correctUV(uv, stride, vector, azimuth2) {
              if (azimuth2 < 0 && uv.x === 1) {
                uvBuffer[stride] = uv.x - 1;
              }
              if (vector.x === 0 && vector.z === 0) {
                uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
              }
            }
            function azimuth(vector) {
              return Math.atan2(vector.z, -vector.x);
            }
            function inclination(vector) {
              return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
            }
          }
          PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
          function TetrahedronBufferGeometry(radius, detail) {
            var vertices = [
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              1,
              -1,
              -1
            ];
            var indices = [
              2,
              1,
              0,
              0,
              3,
              2,
              1,
              3,
              0,
              2,
              3,
              1
            ];
            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
            this.type = "TetrahedronBufferGeometry";
            this.parameters = {
              radius,
              detail
            };
          }
          TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
          TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
          function TetrahedronGeometry(radius, detail) {
            Geometry.call(this);
            this.type = "TetrahedronGeometry";
            this.parameters = {
              radius,
              detail
            };
            this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
            this.mergeVertices();
          }
          TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
          TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
          function OctahedronBufferGeometry(radius, detail) {
            var vertices = [
              1,
              0,
              0,
              -1,
              0,
              0,
              0,
              1,
              0,
              0,
              -1,
              0,
              0,
              0,
              1,
              0,
              0,
              -1
            ];
            var indices = [
              0,
              2,
              4,
              0,
              4,
              3,
              0,
              3,
              5,
              0,
              5,
              2,
              1,
              2,
              5,
              1,
              5,
              3,
              1,
              3,
              4,
              1,
              4,
              2
            ];
            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
            this.type = "OctahedronBufferGeometry";
            this.parameters = {
              radius,
              detail
            };
          }
          OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
          OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
          function OctahedronGeometry(radius, detail) {
            Geometry.call(this);
            this.type = "OctahedronGeometry";
            this.parameters = {
              radius,
              detail
            };
            this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
            this.mergeVertices();
          }
          OctahedronGeometry.prototype = Object.create(Geometry.prototype);
          OctahedronGeometry.prototype.constructor = OctahedronGeometry;
          function IcosahedronBufferGeometry(radius, detail) {
            var t = (1 + Math.sqrt(5)) / 2;
            var vertices = [
              -1,
              t,
              0,
              1,
              t,
              0,
              -1,
              -t,
              0,
              1,
              -t,
              0,
              0,
              -1,
              t,
              0,
              1,
              t,
              0,
              -1,
              -t,
              0,
              1,
              -t,
              t,
              0,
              -1,
              t,
              0,
              1,
              -t,
              0,
              -1,
              -t,
              0,
              1
            ];
            var indices = [
              0,
              11,
              5,
              0,
              5,
              1,
              0,
              1,
              7,
              0,
              7,
              10,
              0,
              10,
              11,
              1,
              5,
              9,
              5,
              11,
              4,
              11,
              10,
              2,
              10,
              7,
              6,
              7,
              1,
              8,
              3,
              9,
              4,
              3,
              4,
              2,
              3,
              2,
              6,
              3,
              6,
              8,
              3,
              8,
              9,
              4,
              9,
              5,
              2,
              4,
              11,
              6,
              2,
              10,
              8,
              6,
              7,
              9,
              8,
              1
            ];
            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
            this.type = "IcosahedronBufferGeometry";
            this.parameters = {
              radius,
              detail
            };
          }
          IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
          IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
          function IcosahedronGeometry(radius, detail) {
            Geometry.call(this);
            this.type = "IcosahedronGeometry";
            this.parameters = {
              radius,
              detail
            };
            this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
            this.mergeVertices();
          }
          IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
          IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
          function DodecahedronBufferGeometry(radius, detail) {
            var t = (1 + Math.sqrt(5)) / 2;
            var r = 1 / t;
            var vertices = [
              // (1, 1, 1)
              -1,
              -1,
              -1,
              -1,
              -1,
              1,
              -1,
              1,
              -1,
              -1,
              1,
              1,
              1,
              -1,
              -1,
              1,
              -1,
              1,
              1,
              1,
              -1,
              1,
              1,
              1,
              // (0, 1/, )
              0,
              -r,
              -t,
              0,
              -r,
              t,
              0,
              r,
              -t,
              0,
              r,
              t,
              // (1/, , 0)
              -r,
              -t,
              0,
              -r,
              t,
              0,
              r,
              -t,
              0,
              r,
              t,
              0,
              // (, 0, 1/)
              -t,
              0,
              -r,
              t,
              0,
              -r,
              -t,
              0,
              r,
              t,
              0,
              r
            ];
            var indices = [
              3,
              11,
              7,
              3,
              7,
              15,
              3,
              15,
              13,
              7,
              19,
              17,
              7,
              17,
              6,
              7,
              6,
              15,
              17,
              4,
              8,
              17,
              8,
              10,
              17,
              10,
              6,
              8,
              0,
              16,
              8,
              16,
              2,
              8,
              2,
              10,
              0,
              12,
              1,
              0,
              1,
              18,
              0,
              18,
              16,
              6,
              10,
              2,
              6,
              2,
              13,
              6,
              13,
              15,
              2,
              16,
              18,
              2,
              18,
              3,
              2,
              3,
              13,
              18,
              1,
              9,
              18,
              9,
              11,
              18,
              11,
              3,
              4,
              14,
              12,
              4,
              12,
              0,
              4,
              0,
              8,
              11,
              9,
              5,
              11,
              5,
              19,
              11,
              19,
              7,
              19,
              5,
              14,
              19,
              14,
              4,
              19,
              4,
              17,
              1,
              12,
              14,
              1,
              14,
              5,
              1,
              5,
              9
            ];
            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
            this.type = "DodecahedronBufferGeometry";
            this.parameters = {
              radius,
              detail
            };
          }
          DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
          DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
          function DodecahedronGeometry(radius, detail) {
            Geometry.call(this);
            this.type = "DodecahedronGeometry";
            this.parameters = {
              radius,
              detail
            };
            this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
            this.mergeVertices();
          }
          DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
          DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
          function PolyhedronGeometry(vertices, indices, radius, detail) {
            Geometry.call(this);
            this.type = "PolyhedronGeometry";
            this.parameters = {
              vertices,
              indices,
              radius,
              detail
            };
            this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
            this.mergeVertices();
          }
          PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
          PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
          function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
            BufferGeometry.call(this);
            this.type = "TubeBufferGeometry";
            this.parameters = {
              path,
              tubularSegments,
              radius,
              radialSegments,
              closed
            };
            tubularSegments = tubularSegments || 64;
            radius = radius || 1;
            radialSegments = radialSegments || 8;
            closed = closed || false;
            var frames = path.computeFrenetFrames(tubularSegments, closed);
            this.tangents = frames.tangents;
            this.normals = frames.normals;
            this.binormals = frames.binormals;
            var vertex = new Vector3();
            var normal = new Vector3();
            var uv = new Vector2();
            var i, j;
            var vertices = [];
            var normals = [];
            var uvs = [];
            var indices = [];
            generateBufferData();
            this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
            this.addAttribute("position", Float32Attribute(vertices, 3));
            this.addAttribute("normal", Float32Attribute(normals, 3));
            this.addAttribute("uv", Float32Attribute(uvs, 2));
            function generateBufferData() {
              for (i = 0; i < tubularSegments; i++) {
                generateSegment(i);
              }
              generateSegment(closed === false ? tubularSegments : 0);
              generateUVs();
              generateIndices();
            }
            function generateSegment(i2) {
              var P = path.getPointAt(i2 / tubularSegments);
              var N = frames.normals[i2];
              var B = frames.binormals[i2];
              for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
              }
            }
            function generateIndices() {
              for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                  var a = (radialSegments + 1) * (j - 1) + (i - 1);
                  var b = (radialSegments + 1) * j + (i - 1);
                  var c = (radialSegments + 1) * j + i;
                  var d = (radialSegments + 1) * (j - 1) + i;
                  indices.push(a, b, d);
                  indices.push(b, c, d);
                }
              }
            }
            function generateUVs() {
              for (i = 0; i <= tubularSegments; i++) {
                for (j = 0; j <= radialSegments; j++) {
                  uv.x = i / tubularSegments;
                  uv.y = j / radialSegments;
                  uvs.push(uv.x, uv.y);
                }
              }
            }
          }
          TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
          function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
            Geometry.call(this);
            this.type = "TubeGeometry";
            this.parameters = {
              path,
              tubularSegments,
              radius,
              radialSegments,
              closed
            };
            if (taper !== void 0)
              console.warn("THREE.TubeGeometry: taper has been removed.");
            var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
            this.tangents = bufferGeometry.tangents;
            this.normals = bufferGeometry.normals;
            this.binormals = bufferGeometry.binormals;
            this.fromBufferGeometry(bufferGeometry);
            this.mergeVertices();
          }
          TubeGeometry.prototype = Object.create(Geometry.prototype);
          TubeGeometry.prototype.constructor = TubeGeometry;
          function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
            BufferGeometry.call(this);
            this.type = "TorusKnotBufferGeometry";
            this.parameters = {
              radius,
              tube,
              tubularSegments,
              radialSegments,
              p,
              q
            };
            radius = radius || 100;
            tube = tube || 40;
            tubularSegments = Math.floor(tubularSegments) || 64;
            radialSegments = Math.floor(radialSegments) || 8;
            p = p || 2;
            q = q || 3;
            var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
            var indexCount = radialSegments * tubularSegments * 2 * 3;
            var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var i, j, index = 0, indexOffset = 0;
            var vertex = new Vector3();
            var normal = new Vector3();
            var uv = new Vector2();
            var P1 = new Vector3();
            var P2 = new Vector3();
            var B = new Vector3();
            var T = new Vector3();
            var N = new Vector3();
            for (i = 0; i <= tubularSegments; ++i) {
              var u = i / tubularSegments * p * Math.PI * 2;
              calculatePositionOnCurve(u, p, q, radius, P1);
              calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
              T.subVectors(P2, P1);
              N.addVectors(P2, P1);
              B.crossVectors(T, N);
              N.crossVectors(B, T);
              B.normalize();
              N.normalize();
              for (j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                normal.subVectors(vertex, P1).normalize();
                normals.setXYZ(index, normal.x, normal.y, normal.z);
                uv.x = i / tubularSegments;
                uv.y = j / radialSegments;
                uvs.setXY(index, uv.x, uv.y);
                index++;
              }
            }
            for (j = 1; j <= tubularSegments; j++) {
              for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
              }
            }
            this.setIndex(indices);
            this.addAttribute("position", vertices);
            this.addAttribute("normal", normals);
            this.addAttribute("uv", uvs);
            function calculatePositionOnCurve(u2, p2, q2, radius2, position) {
              var cu = Math.cos(u2);
              var su = Math.sin(u2);
              var quOverP = q2 / p2 * u2;
              var cs = Math.cos(quOverP);
              position.x = radius2 * (2 + cs) * 0.5 * cu;
              position.y = radius2 * (2 + cs) * su * 0.5;
              position.z = radius2 * Math.sin(quOverP) * 0.5;
            }
          }
          TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
          function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
            Geometry.call(this);
            this.type = "TorusKnotGeometry";
            this.parameters = {
              radius,
              tube,
              tubularSegments,
              radialSegments,
              p,
              q
            };
            if (heightScale !== void 0)
              console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
            this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
            this.mergeVertices();
          }
          TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
          TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
          function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
            BufferGeometry.call(this);
            this.type = "TorusBufferGeometry";
            this.parameters = {
              radius,
              tube,
              radialSegments,
              tubularSegments,
              arc
            };
            radius = radius || 100;
            tube = tube || 40;
            radialSegments = Math.floor(radialSegments) || 8;
            tubularSegments = Math.floor(tubularSegments) || 6;
            arc = arc || Math.PI * 2;
            var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
            var indexCount = radialSegments * tubularSegments * 2 * 3;
            var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
            var vertices = new Float32Array(vertexCount * 3);
            var normals = new Float32Array(vertexCount * 3);
            var uvs = new Float32Array(vertexCount * 2);
            var vertexBufferOffset = 0;
            var uvBufferOffset = 0;
            var indexBufferOffset = 0;
            var center = new Vector3();
            var vertex = new Vector3();
            var normal = new Vector3();
            var j, i;
            for (j = 0; j <= radialSegments; j++) {
              for (i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices[vertexBufferOffset] = vertex.x;
                vertices[vertexBufferOffset + 1] = vertex.y;
                vertices[vertexBufferOffset + 2] = vertex.z;
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals[vertexBufferOffset] = normal.x;
                normals[vertexBufferOffset + 1] = normal.y;
                normals[vertexBufferOffset + 2] = normal.z;
                uvs[uvBufferOffset] = i / tubularSegments;
                uvs[uvBufferOffset + 1] = j / radialSegments;
                vertexBufferOffset += 3;
                uvBufferOffset += 2;
              }
            }
            for (j = 1; j <= radialSegments; j++) {
              for (i = 1; i <= tubularSegments; i++) {
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                indices[indexBufferOffset] = a;
                indices[indexBufferOffset + 1] = b;
                indices[indexBufferOffset + 2] = d;
                indices[indexBufferOffset + 3] = b;
                indices[indexBufferOffset + 4] = c;
                indices[indexBufferOffset + 5] = d;
                indexBufferOffset += 6;
              }
            }
            this.setIndex(new BufferAttribute(indices, 1));
            this.addAttribute("position", new BufferAttribute(vertices, 3));
            this.addAttribute("normal", new BufferAttribute(normals, 3));
            this.addAttribute("uv", new BufferAttribute(uvs, 2));
          }
          TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
          function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
            Geometry.call(this);
            this.type = "TorusGeometry";
            this.parameters = {
              radius,
              tube,
              radialSegments,
              tubularSegments,
              arc
            };
            this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
          }
          TorusGeometry.prototype = Object.create(Geometry.prototype);
          TorusGeometry.prototype.constructor = TorusGeometry;
          var ShapeUtils = {
            // calculate area of the contour polygon
            area: function(contour) {
              var n = contour.length;
              var a = 0;
              for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
              }
              return a * 0.5;
            },
            triangulate: /* @__PURE__ */ function() {
              function snip(contour, u, v, w, n, verts) {
                var p;
                var ax, ay, bx, by;
                var cx, cy, px, py;
                ax = contour[verts[u]].x;
                ay = contour[verts[u]].y;
                bx = contour[verts[v]].x;
                by = contour[verts[v]].y;
                cx = contour[verts[w]].x;
                cy = contour[verts[w]].y;
                if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0)
                  return false;
                var aX, aY, bX, bY, cX, cY;
                var apx, apy, bpx, bpy, cpx, cpy;
                var cCROSSap, bCROSScp, aCROSSbp;
                aX = cx - bx;
                aY = cy - by;
                bX = ax - cx;
                bY = ay - cy;
                cX = bx - ax;
                cY = by - ay;
                for (p = 0; p < n; p++) {
                  px = contour[verts[p]].x;
                  py = contour[verts[p]].y;
                  if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy)
                    continue;
                  apx = px - ax;
                  apy = py - ay;
                  bpx = px - bx;
                  bpy = py - by;
                  cpx = px - cx;
                  cpy = py - cy;
                  aCROSSbp = aX * bpy - aY * bpx;
                  cCROSSap = cX * apy - cY * apx;
                  bCROSScp = bX * cpy - bY * cpx;
                  if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)
                    return false;
                }
                return true;
              }
              return function triangulate(contour, indices) {
                var n = contour.length;
                if (n < 3)
                  return null;
                var result = [], verts = [], vertIndices = [];
                var u, v, w;
                if (ShapeUtils.area(contour) > 0) {
                  for (v = 0; v < n; v++)
                    verts[v] = v;
                } else {
                  for (v = 0; v < n; v++)
                    verts[v] = n - 1 - v;
                }
                var nv = n;
                var count2 = 2 * nv;
                for (v = nv - 1; nv > 2; ) {
                  if (count2-- <= 0) {
                    console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                    if (indices)
                      return vertIndices;
                    return result;
                  }
                  u = v;
                  if (nv <= u)
                    u = 0;
                  v = u + 1;
                  if (nv <= v)
                    v = 0;
                  w = v + 1;
                  if (nv <= w)
                    w = 0;
                  if (snip(contour, u, v, w, nv, verts)) {
                    var a, b, c, s, t;
                    a = verts[u];
                    b = verts[v];
                    c = verts[w];
                    result.push([
                      contour[a],
                      contour[b],
                      contour[c]
                    ]);
                    vertIndices.push([verts[u], verts[v], verts[w]]);
                    for (s = v, t = v + 1; t < nv; s++, t++) {
                      verts[s] = verts[t];
                    }
                    nv--;
                    count2 = 2 * nv;
                  }
                }
                if (indices)
                  return vertIndices;
                return result;
              };
            }(),
            triangulateShape: function(contour, holes) {
              function removeDupEndPts(points) {
                var l = points.length;
                if (l > 2 && points[l - 1].equals(points[0])) {
                  points.pop();
                }
              }
              removeDupEndPts(contour);
              holes.forEach(removeDupEndPts);
              function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                if (inSegPt1.x !== inSegPt2.x) {
                  if (inSegPt1.x < inSegPt2.x) {
                    return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
                  } else {
                    return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
                  }
                } else {
                  if (inSegPt1.y < inSegPt2.y) {
                    return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
                  } else {
                    return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
                  }
                }
              }
              function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
                var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
                var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
                var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
                var limit = seg1dy * seg2dx - seg1dx * seg2dy;
                var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (Math.abs(limit) > Number.EPSILON) {
                  var perpSeg2;
                  if (limit > 0) {
                    if (perpSeg1 < 0 || perpSeg1 > limit)
                      return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 < 0 || perpSeg2 > limit)
                      return [];
                  } else {
                    if (perpSeg1 > 0 || perpSeg1 < limit)
                      return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 > 0 || perpSeg2 < limit)
                      return [];
                  }
                  if (perpSeg2 === 0) {
                    if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                      return [];
                    return [inSeg1Pt1];
                  }
                  if (perpSeg2 === limit) {
                    if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                      return [];
                    return [inSeg1Pt2];
                  }
                  if (perpSeg1 === 0)
                    return [inSeg2Pt1];
                  if (perpSeg1 === limit)
                    return [inSeg2Pt2];
                  var factorSeg1 = perpSeg2 / limit;
                  return [{
                    x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                    y: inSeg1Pt1.y + factorSeg1 * seg1dy
                  }];
                } else {
                  if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)
                    return [];
                  var seg1Pt = seg1dx === 0 && seg1dy === 0;
                  var seg2Pt = seg2dx === 0 && seg2dy === 0;
                  if (seg1Pt && seg2Pt) {
                    if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y)
                      return [];
                    return [inSeg1Pt1];
                  }
                  if (seg1Pt) {
                    if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                      return [];
                    return [inSeg1Pt1];
                  }
                  if (seg2Pt) {
                    if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                      return [];
                    return [inSeg2Pt1];
                  }
                  var seg1min, seg1max, seg1minVal, seg1maxVal;
                  var seg2min, seg2max, seg2minVal, seg2maxVal;
                  if (seg1dx !== 0) {
                    if (inSeg1Pt1.x < inSeg1Pt2.x) {
                      seg1min = inSeg1Pt1;
                      seg1minVal = inSeg1Pt1.x;
                      seg1max = inSeg1Pt2;
                      seg1maxVal = inSeg1Pt2.x;
                    } else {
                      seg1min = inSeg1Pt2;
                      seg1minVal = inSeg1Pt2.x;
                      seg1max = inSeg1Pt1;
                      seg1maxVal = inSeg1Pt1.x;
                    }
                    if (inSeg2Pt1.x < inSeg2Pt2.x) {
                      seg2min = inSeg2Pt1;
                      seg2minVal = inSeg2Pt1.x;
                      seg2max = inSeg2Pt2;
                      seg2maxVal = inSeg2Pt2.x;
                    } else {
                      seg2min = inSeg2Pt2;
                      seg2minVal = inSeg2Pt2.x;
                      seg2max = inSeg2Pt1;
                      seg2maxVal = inSeg2Pt1.x;
                    }
                  } else {
                    if (inSeg1Pt1.y < inSeg1Pt2.y) {
                      seg1min = inSeg1Pt1;
                      seg1minVal = inSeg1Pt1.y;
                      seg1max = inSeg1Pt2;
                      seg1maxVal = inSeg1Pt2.y;
                    } else {
                      seg1min = inSeg1Pt2;
                      seg1minVal = inSeg1Pt2.y;
                      seg1max = inSeg1Pt1;
                      seg1maxVal = inSeg1Pt1.y;
                    }
                    if (inSeg2Pt1.y < inSeg2Pt2.y) {
                      seg2min = inSeg2Pt1;
                      seg2minVal = inSeg2Pt1.y;
                      seg2max = inSeg2Pt2;
                      seg2maxVal = inSeg2Pt2.y;
                    } else {
                      seg2min = inSeg2Pt2;
                      seg2minVal = inSeg2Pt2.y;
                      seg2max = inSeg2Pt1;
                      seg2maxVal = inSeg2Pt1.y;
                    }
                  }
                  if (seg1minVal <= seg2minVal) {
                    if (seg1maxVal < seg2minVal)
                      return [];
                    if (seg1maxVal === seg2minVal) {
                      if (inExcludeAdjacentSegs)
                        return [];
                      return [seg2min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                      return [seg2min, seg1max];
                    return [seg2min, seg2max];
                  } else {
                    if (seg1minVal > seg2maxVal)
                      return [];
                    if (seg1minVal === seg2maxVal) {
                      if (inExcludeAdjacentSegs)
                        return [];
                      return [seg1min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                      return [seg1min, seg1max];
                    return [seg1min, seg2max];
                  }
                }
              }
              function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
                var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
                var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
                var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
                var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (Math.abs(from2toAngle) > Number.EPSILON) {
                  var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                  if (from2toAngle > 0) {
                    return from2otherAngle >= 0 && other2toAngle >= 0;
                  } else {
                    return from2otherAngle >= 0 || other2toAngle >= 0;
                  }
                } else {
                  return from2otherAngle > 0;
                }
              }
              function removeHoles(contour2, holes2) {
                var shape = contour2.concat();
                var hole;
                function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                  var lastShapeIdx = shape.length - 1;
                  var prevShapeIdx = inShapeIdx - 1;
                  if (prevShapeIdx < 0)
                    prevShapeIdx = lastShapeIdx;
                  var nextShapeIdx = inShapeIdx + 1;
                  if (nextShapeIdx > lastShapeIdx)
                    nextShapeIdx = 0;
                  var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                  if (!insideAngle) {
                    return false;
                  }
                  var lastHoleIdx = hole.length - 1;
                  var prevHoleIdx = inHoleIdx - 1;
                  if (prevHoleIdx < 0)
                    prevHoleIdx = lastHoleIdx;
                  var nextHoleIdx = inHoleIdx + 1;
                  if (nextHoleIdx > lastHoleIdx)
                    nextHoleIdx = 0;
                  insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                  if (!insideAngle) {
                    return false;
                  }
                  return true;
                }
                function intersectsShapeEdge(inShapePt, inHolePt) {
                  var sIdx, nextIdx, intersection;
                  for (sIdx = 0; sIdx < shape.length; sIdx++) {
                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                    if (intersection.length > 0)
                      return true;
                  }
                  return false;
                }
                var indepHoles = [];
                function intersectsHoleEdge(inShapePt, inHolePt) {
                  var ihIdx, chkHole, hIdx, nextIdx, intersection;
                  for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                    chkHole = holes2[indepHoles[ihIdx]];
                    for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                      nextIdx = hIdx + 1;
                      nextIdx %= chkHole.length;
                      intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                      if (intersection.length > 0)
                        return true;
                    }
                  }
                  return false;
                }
                var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
                for (var h2 = 0, hl2 = holes2.length; h2 < hl2; h2++) {
                  indepHoles.push(h2);
                }
                var minShapeIndex = 0;
                var counter = indepHoles.length * 2;
                while (indepHoles.length > 0) {
                  counter--;
                  if (counter < 0) {
                    console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                    break;
                  }
                  for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                    shapePt = shape[shapeIndex];
                    holeIndex = -1;
                    for (var h2 = 0; h2 < indepHoles.length; h2++) {
                      holeIdx = indepHoles[h2];
                      cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                      if (failedCuts[cutKey] !== void 0)
                        continue;
                      hole = holes2[holeIdx];
                      for (var h22 = 0; h22 < hole.length; h22++) {
                        holePt = hole[h22];
                        if (!isCutLineInsideAngles(shapeIndex, h22))
                          continue;
                        if (intersectsShapeEdge(shapePt, holePt))
                          continue;
                        if (intersectsHoleEdge(shapePt, holePt))
                          continue;
                        holeIndex = h22;
                        indepHoles.splice(h2, 1);
                        tmpShape1 = shape.slice(0, shapeIndex + 1);
                        tmpShape2 = shape.slice(shapeIndex);
                        tmpHole1 = hole.slice(holeIndex);
                        tmpHole2 = hole.slice(0, holeIndex + 1);
                        shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                        minShapeIndex = shapeIndex;
                        break;
                      }
                      if (holeIndex >= 0)
                        break;
                      failedCuts[cutKey] = true;
                    }
                    if (holeIndex >= 0)
                      break;
                  }
                }
                return shape;
              }
              var i, il, f, face, key, index, allPointsMap = {};
              var allpoints = contour.concat();
              for (var h = 0, hl = holes.length; h < hl; h++) {
                Array.prototype.push.apply(allpoints, holes[h]);
              }
              for (i = 0, il = allpoints.length; i < il; i++) {
                key = allpoints[i].x + ":" + allpoints[i].y;
                if (allPointsMap[key] !== void 0) {
                  console.warn("THREE.ShapeUtils: Duplicate point", key, i);
                }
                allPointsMap[key] = i;
              }
              var shapeWithoutHoles = removeHoles(contour, holes);
              var triangles = ShapeUtils.triangulate(shapeWithoutHoles, false);
              for (i = 0, il = triangles.length; i < il; i++) {
                face = triangles[i];
                for (f = 0; f < 3; f++) {
                  key = face[f].x + ":" + face[f].y;
                  index = allPointsMap[key];
                  if (index !== void 0) {
                    face[f] = index;
                  }
                }
              }
              return triangles.concat();
            },
            isClockWise: function(pts) {
              return ShapeUtils.area(pts) < 0;
            },
            // Bezier Curves formulas obtained from
            // http://en.wikipedia.org/wiki/B%C3%A9zier_curve
            // Quad Bezier Functions
            b2: /* @__PURE__ */ function() {
              function b2p0(t, p) {
                var k = 1 - t;
                return k * k * p;
              }
              function b2p1(t, p) {
                return 2 * (1 - t) * t * p;
              }
              function b2p2(t, p) {
                return t * t * p;
              }
              return function b2(t, p0, p1, p2) {
                return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
              };
            }(),
            // Cubic Bezier Functions
            b3: /* @__PURE__ */ function() {
              function b3p0(t, p) {
                var k = 1 - t;
                return k * k * k * p;
              }
              function b3p1(t, p) {
                var k = 1 - t;
                return 3 * k * k * t * p;
              }
              function b3p2(t, p) {
                var k = 1 - t;
                return 3 * k * t * t * p;
              }
              function b3p3(t, p) {
                return t * t * t * p;
              }
              return function b3(t, p0, p1, p2, p3) {
                return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
              };
            }()
          };
          function ExtrudeGeometry(shapes, options) {
            if (typeof shapes === "undefined") {
              shapes = [];
              return;
            }
            Geometry.call(this);
            this.type = "ExtrudeGeometry";
            shapes = Array.isArray(shapes) ? shapes : [shapes];
            this.addShapeList(shapes, options);
            this.computeFaceNormals();
          }
          ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
          ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
          ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
            var sl = shapes.length;
            for (var s = 0; s < sl; s++) {
              var shape = shapes[s];
              this.addShape(shape, options);
            }
          };
          ExtrudeGeometry.prototype.addShape = function(shape, options) {
            var amount = options.amount !== void 0 ? options.amount : 100;
            var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
            var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
            var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
            var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            var steps = options.steps !== void 0 ? options.steps : 1;
            var extrudePath = options.extrudePath;
            var extrudePts, extrudeByPath = false;
            var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
            var splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = options.frames !== void 0 ? options.frames : extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
            }
            var ahole, h, hl;
            var scope = this;
            var shapesOffset = this.vertices.length;
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h] = ahole.reverse();
                }
              }
              reverse = false;
            }
            var faces = ShapeUtils.triangulateShape(vertices, holes);
            var contour = vertices;
            for (h = 0, hl = holes.length; h < hl; h++) {
              ahole = holes[h];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              var v_trans_x, v_trans_y, shrink_by = 1;
              var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                var ptNextShift_y = inNext.y + v_next_x / v_next_len;
                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector2(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                var direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            var contourMovements = [];
            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
            for (h = 0, hl = holes.length; h < hl; h++) {
              ahole = holes[h];
              oneHoleMovements = [];
              for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (b = 0; b < bevelSegments; b++) {
              t = b / bevelSegments;
              z = bevelThickness * Math.cos(t * Math.PI / 2);
              bs = bevelSize * Math.sin(t * Math.PI / 2);
              for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, -z);
              }
              for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                  vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                  v(vert.x, vert.y, -z);
                }
              }
            }
            bs = bevelSize;
            for (i = 0; i < vlen; i++) {
              vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            var s;
            for (s = 1; s <= steps; s++) {
              for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, amount / steps * s);
                } else {
                  normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (b = bevelSegments - 1; b >= 0; b--) {
              t = b / bevelSegments;
              z = bevelThickness * Math.cos(t * Math.PI / 2);
              bs = bevelSize * Math.sin(t * Math.PI / 2);
              for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, amount + z);
              }
              for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                  vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, amount + z);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              if (bevelEnabled) {
                var layer = 0;
                var offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                  face = faces[i];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                  face = faces[i];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (i = 0; i < flen; i++) {
                  face = faces[i];
                  f3(face[2], face[1], face[0]);
                }
                for (i = 0; i < flen; i++) {
                  face = faces[i];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
            }
            function buildSideFaces() {
              var layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
            }
            function sidewalls(contour2, layeroffset) {
              var j2, k2;
              i = contour2.length;
              while (--i >= 0) {
                j2 = i;
                k2 = i - 1;
                if (k2 < 0)
                  k2 = contour2.length - 1;
                var s2 = 0, sl = steps + bevelSegments * 2;
                for (s2 = 0; s2 < sl; s2++) {
                  var slen1 = vlen * s2;
                  var slen2 = vlen * (s2 + 1);
                  var a = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c = layeroffset + k2 + slen2, d = layeroffset + j2 + slen2;
                  f4(a, b2, c, d, contour2, s2, sl, j2, k2);
                }
              }
            }
            function v(x, y, z2) {
              scope.vertices.push(new Vector3(x, y, z2));
            }
            function f3(a, b2, c) {
              a += shapesOffset;
              b2 += shapesOffset;
              c += shapesOffset;
              scope.faces.push(new Face3(a, b2, c, null, null, 0));
              var uvs = uvgen.generateTopUV(scope, a, b2, c);
              scope.faceVertexUvs[0].push(uvs);
            }
            function f4(a, b2, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
              a += shapesOffset;
              b2 += shapesOffset;
              c += shapesOffset;
              d += shapesOffset;
              scope.faces.push(new Face3(a, b2, d, null, null, 1));
              scope.faces.push(new Face3(b2, c, d, null, null, 1));
              var uvs = uvgen.generateSideWallUV(scope, a, b2, c, d);
              scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
              scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
            }
          };
          ExtrudeGeometry.WorldUVGenerator = {
            generateTopUV: function(geometry, indexA, indexB, indexC) {
              var vertices = geometry.vertices;
              var a = vertices[indexA];
              var b = vertices[indexB];
              var c = vertices[indexC];
              return [
                new Vector2(a.x, a.y),
                new Vector2(b.x, b.y),
                new Vector2(c.x, c.y)
              ];
            },
            generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
              var vertices = geometry.vertices;
              var a = vertices[indexA];
              var b = vertices[indexB];
              var c = vertices[indexC];
              var d = vertices[indexD];
              if (Math.abs(a.y - b.y) < 0.01) {
                return [
                  new Vector2(a.x, 1 - a.z),
                  new Vector2(b.x, 1 - b.z),
                  new Vector2(c.x, 1 - c.z),
                  new Vector2(d.x, 1 - d.z)
                ];
              } else {
                return [
                  new Vector2(a.y, 1 - a.z),
                  new Vector2(b.y, 1 - b.z),
                  new Vector2(c.y, 1 - c.z),
                  new Vector2(d.y, 1 - d.z)
                ];
              }
            }
          };
          function TextGeometry(text, parameters) {
            parameters = parameters || {};
            var font = parameters.font;
            if ((font && font.isFont) === false) {
              console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
              return new Geometry();
            }
            var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
            parameters.amount = parameters.height !== void 0 ? parameters.height : 50;
            if (parameters.bevelThickness === void 0)
              parameters.bevelThickness = 10;
            if (parameters.bevelSize === void 0)
              parameters.bevelSize = 8;
            if (parameters.bevelEnabled === void 0)
              parameters.bevelEnabled = false;
            ExtrudeGeometry.call(this, shapes, parameters);
            this.type = "TextGeometry";
          }
          TextGeometry.prototype = Object.create(ExtrudeGeometry.prototype);
          TextGeometry.prototype.constructor = TextGeometry;
          function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            BufferGeometry.call(this);
            this.type = "SphereBufferGeometry";
            this.parameters = {
              radius,
              widthSegments,
              heightSegments,
              phiStart,
              phiLength,
              thetaStart,
              thetaLength
            };
            radius = radius || 50;
            widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
            heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
            phiStart = phiStart !== void 0 ? phiStart : 0;
            phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
            thetaStart = thetaStart !== void 0 ? thetaStart : 0;
            thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
            var thetaEnd = thetaStart + thetaLength;
            var vertexCount = (widthSegments + 1) * (heightSegments + 1);
            var positions = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, vertices = [], normal = new Vector3();
            for (var y = 0; y <= heightSegments; y++) {
              var verticesRow = [];
              var v = y / heightSegments;
              for (var x = 0; x <= widthSegments; x++) {
                var u = x / widthSegments;
                var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                var py = radius * Math.cos(thetaStart + v * thetaLength);
                var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                normal.set(px, py, pz).normalize();
                positions.setXYZ(index, px, py, pz);
                normals.setXYZ(index, normal.x, normal.y, normal.z);
                uvs.setXY(index, u, 1 - v);
                verticesRow.push(index);
                index++;
              }
              vertices.push(verticesRow);
            }
            var indices = [];
            for (var y = 0; y < heightSegments; y++) {
              for (var x = 0; x < widthSegments; x++) {
                var v1 = vertices[y][x + 1];
                var v2 = vertices[y][x];
                var v3 = vertices[y + 1][x];
                var v4 = vertices[y + 1][x + 1];
                if (y !== 0 || thetaStart > 0)
                  indices.push(v1, v2, v4);
                if (y !== heightSegments - 1 || thetaEnd < Math.PI)
                  indices.push(v2, v3, v4);
              }
            }
            this.setIndex(new (positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
            this.addAttribute("position", positions);
            this.addAttribute("normal", normals);
            this.addAttribute("uv", uvs);
            this.boundingSphere = new Sphere(new Vector3(), radius);
          }
          SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
          function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            Geometry.call(this);
            this.type = "SphereGeometry";
            this.parameters = {
              radius,
              widthSegments,
              heightSegments,
              phiStart,
              phiLength,
              thetaStart,
              thetaLength
            };
            this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
          }
          SphereGeometry.prototype = Object.create(Geometry.prototype);
          SphereGeometry.prototype.constructor = SphereGeometry;
          function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            BufferGeometry.call(this);
            this.type = "RingBufferGeometry";
            this.parameters = {
              innerRadius,
              outerRadius,
              thetaSegments,
              phiSegments,
              thetaStart,
              thetaLength
            };
            innerRadius = innerRadius || 20;
            outerRadius = outerRadius || 50;
            thetaStart = thetaStart !== void 0 ? thetaStart : 0;
            thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
            thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
            phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
            var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
            var indexCount = thetaSegments * phiSegments * 2 * 3;
            var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, segment;
            var radius = innerRadius;
            var radiusStep = (outerRadius - innerRadius) / phiSegments;
            var vertex = new Vector3();
            var uv = new Vector2();
            var j, i;
            for (j = 0; j <= phiSegments; j++) {
              for (i = 0; i <= thetaSegments; i++) {
                segment = thetaStart + i / thetaSegments * thetaLength;
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                normals.setXYZ(index, 0, 0, 1);
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.setXY(index, uv.x, uv.y);
                index++;
              }
              radius += radiusStep;
            }
            for (j = 0; j < phiSegments; j++) {
              var thetaSegmentLevel = j * (thetaSegments + 1);
              for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
              }
            }
            this.setIndex(indices);
            this.addAttribute("position", vertices);
            this.addAttribute("normal", normals);
            this.addAttribute("uv", uvs);
          }
          RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          RingBufferGeometry.prototype.constructor = RingBufferGeometry;
          function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            Geometry.call(this);
            this.type = "RingGeometry";
            this.parameters = {
              innerRadius,
              outerRadius,
              thetaSegments,
              phiSegments,
              thetaStart,
              thetaLength
            };
            this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
          }
          RingGeometry.prototype = Object.create(Geometry.prototype);
          RingGeometry.prototype.constructor = RingGeometry;
          function PlaneGeometry(width, height, widthSegments, heightSegments) {
            Geometry.call(this);
            this.type = "PlaneGeometry";
            this.parameters = {
              width,
              height,
              widthSegments,
              heightSegments
            };
            this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
          }
          PlaneGeometry.prototype = Object.create(Geometry.prototype);
          PlaneGeometry.prototype.constructor = PlaneGeometry;
          function LatheBufferGeometry(points, segments, phiStart, phiLength) {
            BufferGeometry.call(this);
            this.type = "LatheBufferGeometry";
            this.parameters = {
              points,
              segments,
              phiStart,
              phiLength
            };
            segments = Math.floor(segments) || 12;
            phiStart = phiStart || 0;
            phiLength = phiLength || Math.PI * 2;
            phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
            var vertexCount = (segments + 1) * points.length;
            var indexCount = segments * points.length * 2 * 3;
            var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, base;
            var inverseSegments = 1 / segments;
            var vertex = new Vector3();
            var uv = new Vector2();
            var i, j;
            for (i = 0; i <= segments; i++) {
              var phi = phiStart + i * inverseSegments * phiLength;
              var sin = Math.sin(phi);
              var cos = Math.cos(phi);
              for (j = 0; j <= points.length - 1; j++) {
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.setXY(index, uv.x, uv.y);
                index++;
              }
            }
            for (i = 0; i < segments; i++) {
              for (j = 0; j < points.length - 1; j++) {
                base = j + i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                indices.setX(indexOffset, a);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
                indices.setX(indexOffset, b);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
                indices.setX(indexOffset, d);
                indexOffset++;
              }
            }
            this.setIndex(indices);
            this.addAttribute("position", vertices);
            this.addAttribute("uv", uvs);
            this.computeVertexNormals();
            if (phiLength === Math.PI * 2) {
              var normals = this.attributes.normal.array;
              var n1 = new Vector3();
              var n2 = new Vector3();
              var n = new Vector3();
              base = segments * points.length * 3;
              for (i = 0, j = 0; i < points.length; i++, j += 3) {
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                n.addVectors(n1, n2).normalize();
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
              }
            }
          }
          LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
          function LatheGeometry(points, segments, phiStart, phiLength) {
            Geometry.call(this);
            this.type = "LatheGeometry";
            this.parameters = {
              points,
              segments,
              phiStart,
              phiLength
            };
            this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
            this.mergeVertices();
          }
          LatheGeometry.prototype = Object.create(Geometry.prototype);
          LatheGeometry.prototype.constructor = LatheGeometry;
          function ShapeGeometry(shapes, options) {
            Geometry.call(this);
            this.type = "ShapeGeometry";
            if (Array.isArray(shapes) === false)
              shapes = [shapes];
            this.addShapeList(shapes, options);
            this.computeFaceNormals();
          }
          ShapeGeometry.prototype = Object.create(Geometry.prototype);
          ShapeGeometry.prototype.constructor = ShapeGeometry;
          ShapeGeometry.prototype.addShapeList = function(shapes, options) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              this.addShape(shapes[i], options);
            }
            return this;
          };
          ShapeGeometry.prototype.addShape = function(shape, options) {
            if (options === void 0)
              options = {};
            var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            var material = options.material;
            var uvgen = options.UVGenerator === void 0 ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
            var i, l, hole;
            var shapesOffset = this.vertices.length;
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (i = 0, l = holes.length; i < l; i++) {
                hole = holes[i];
                if (ShapeUtils.isClockWise(hole)) {
                  holes[i] = hole.reverse();
                }
              }
              reverse = false;
            }
            var faces = ShapeUtils.triangulateShape(vertices, holes);
            for (i = 0, l = holes.length; i < l; i++) {
              hole = holes[i];
              vertices = vertices.concat(hole);
            }
            var vert, vlen = vertices.length;
            var face, flen = faces.length;
            for (i = 0; i < vlen; i++) {
              vert = vertices[i];
              this.vertices.push(new Vector3(vert.x, vert.y, 0));
            }
            for (i = 0; i < flen; i++) {
              face = faces[i];
              var a = face[0] + shapesOffset;
              var b = face[1] + shapesOffset;
              var c = face[2] + shapesOffset;
              this.faces.push(new Face3(a, b, c, null, null, material));
              this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
            }
          };
          function EdgesGeometry(geometry, thresholdAngle) {
            BufferGeometry.call(this);
            thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
            var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
            var edge = [0, 0], hash = {};
            function sortFunction(a, b) {
              return a - b;
            }
            var keys = ["a", "b", "c"];
            var geometry2;
            if (geometry && geometry.isBufferGeometry) {
              geometry2 = new Geometry();
              geometry2.fromBufferGeometry(geometry);
            } else {
              geometry2 = geometry.clone();
            }
            geometry2.mergeVertices();
            geometry2.computeFaceNormals();
            var vertices = geometry2.vertices;
            var faces = geometry2.faces;
            for (var i = 0, l = faces.length; i < l; i++) {
              var face = faces[i];
              for (var j = 0; j < 3; j++) {
                edge[0] = face[keys[j]];
                edge[1] = face[keys[(j + 1) % 3]];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === void 0) {
                  hash[key] = { vert1: edge[0], vert2: edge[1], face1: i, face2: void 0 };
                } else {
                  hash[key].face2 = i;
                }
              }
            }
            var coords = [];
            for (var key in hash) {
              var h = hash[key];
              if (h.face2 === void 0 || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
                var vertex = vertices[h.vert1];
                coords.push(vertex.x);
                coords.push(vertex.y);
                coords.push(vertex.z);
                vertex = vertices[h.vert2];
                coords.push(vertex.x);
                coords.push(vertex.y);
                coords.push(vertex.z);
              }
            }
            this.addAttribute("position", new BufferAttribute(new Float32Array(coords), 3));
          }
          EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
          EdgesGeometry.prototype.constructor = EdgesGeometry;
          function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            BufferGeometry.call(this);
            this.type = "CylinderBufferGeometry";
            this.parameters = {
              radiusTop,
              radiusBottom,
              height,
              radialSegments,
              heightSegments,
              openEnded,
              thetaStart,
              thetaLength
            };
            var scope = this;
            radiusTop = radiusTop !== void 0 ? radiusTop : 20;
            radiusBottom = radiusBottom !== void 0 ? radiusBottom : 20;
            height = height !== void 0 ? height : 100;
            radialSegments = Math.floor(radialSegments) || 8;
            heightSegments = Math.floor(heightSegments) || 1;
            openEnded = openEnded !== void 0 ? openEnded : false;
            thetaStart = thetaStart !== void 0 ? thetaStart : 0;
            thetaLength = thetaLength !== void 0 ? thetaLength : 2 * Math.PI;
            var nbCap = 0;
            if (openEnded === false) {
              if (radiusTop > 0)
                nbCap++;
              if (radiusBottom > 0)
                nbCap++;
            }
            var vertexCount = calculateVertexCount();
            var indexCount = calculateIndexCount();
            var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
            var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
            var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
            var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
            var groupStart = 0;
            generateTorso();
            if (openEnded === false) {
              if (radiusTop > 0)
                generateCap(true);
              if (radiusBottom > 0)
                generateCap(false);
            }
            this.setIndex(indices);
            this.addAttribute("position", vertices);
            this.addAttribute("normal", normals);
            this.addAttribute("uv", uvs);
            function calculateVertexCount() {
              var count2 = (radialSegments + 1) * (heightSegments + 1);
              if (openEnded === false) {
                count2 += (radialSegments + 1) * nbCap + radialSegments * nbCap;
              }
              return count2;
            }
            function calculateIndexCount() {
              var count2 = radialSegments * heightSegments * 2 * 3;
              if (openEnded === false) {
                count2 += radialSegments * nbCap * 3;
              }
              return count2;
            }
            function generateTorso() {
              var x, y;
              var normal = new Vector3();
              var vertex = new Vector3();
              var groupCount = 0;
              var slope = (radiusBottom - radiusTop) / height;
              for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                  var u = x / radialSegments;
                  var theta = u * thetaLength + thetaStart;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = Math.cos(theta);
                  vertex.x = radius * sinTheta;
                  vertex.y = -v * height + halfHeight;
                  vertex.z = radius * cosTheta;
                  vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                  normal.set(sinTheta, slope, cosTheta).normalize();
                  normals.setXYZ(index, normal.x, normal.y, normal.z);
                  uvs.setXY(index, u, 1 - v);
                  indexRow.push(index);
                  index++;
                }
                indexArray.push(indexRow);
              }
              for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                  var i1 = indexArray[y][x];
                  var i2 = indexArray[y + 1][x];
                  var i3 = indexArray[y + 1][x + 1];
                  var i4 = indexArray[y][x + 1];
                  indices.setX(indexOffset, i1);
                  indexOffset++;
                  indices.setX(indexOffset, i2);
                  indexOffset++;
                  indices.setX(indexOffset, i4);
                  indexOffset++;
                  indices.setX(indexOffset, i2);
                  indexOffset++;
                  indices.setX(indexOffset, i3);
                  indexOffset++;
                  indices.setX(indexOffset, i4);
                  indexOffset++;
                  groupCount += 6;
                }
              }
              scope.addGroup(groupStart, groupCount, 0);
              groupStart += groupCount;
            }
            function generateCap(top) {
              var x, centerIndexStart, centerIndexEnd;
              var uv = new Vector2();
              var vertex = new Vector3();
              var groupCount = 0;
              var radius = top === true ? radiusTop : radiusBottom;
              var sign = top === true ? 1 : -1;
              centerIndexStart = index;
              for (x = 1; x <= radialSegments; x++) {
                vertices.setXYZ(index, 0, halfHeight * sign, 0);
                normals.setXYZ(index, 0, sign, 0);
                uv.x = 0.5;
                uv.y = 0.5;
                uvs.setXY(index, uv.x, uv.y);
                index++;
              }
              centerIndexEnd = index;
              for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                normals.setXYZ(index, 0, sign, 0);
                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign + 0.5;
                uvs.setXY(index, uv.x, uv.y);
                index++;
              }
              for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                  indices.setX(indexOffset, i);
                  indexOffset++;
                  indices.setX(indexOffset, i + 1);
                  indexOffset++;
                  indices.setX(indexOffset, c);
                  indexOffset++;
                } else {
                  indices.setX(indexOffset, i + 1);
                  indexOffset++;
                  indices.setX(indexOffset, i);
                  indexOffset++;
                  indices.setX(indexOffset, c);
                  indexOffset++;
                }
                groupCount += 3;
              }
              scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
              groupStart += groupCount;
            }
          }
          CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
          function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            Geometry.call(this);
            this.type = "CylinderGeometry";
            this.parameters = {
              radiusTop,
              radiusBottom,
              height,
              radialSegments,
              heightSegments,
              openEnded,
              thetaStart,
              thetaLength
            };
            this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
            this.mergeVertices();
          }
          CylinderGeometry.prototype = Object.create(Geometry.prototype);
          CylinderGeometry.prototype.constructor = CylinderGeometry;
          function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = "ConeGeometry";
            this.parameters = {
              radius,
              height,
              radialSegments,
              heightSegments,
              openEnded,
              thetaStart,
              thetaLength
            };
          }
          ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
          ConeGeometry.prototype.constructor = ConeGeometry;
          function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = "ConeBufferGeometry";
            this.parameters = {
              radius,
              height,
              radialSegments,
              heightSegments,
              openEnded,
              thetaStart,
              thetaLength
            };
          }
          ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
          ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
          function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
            BufferGeometry.call(this);
            this.type = "CircleBufferGeometry";
            this.parameters = {
              radius,
              segments,
              thetaStart,
              thetaLength
            };
            radius = radius || 50;
            segments = segments !== void 0 ? Math.max(3, segments) : 8;
            thetaStart = thetaStart !== void 0 ? thetaStart : 0;
            thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
            var vertices = segments + 2;
            var positions = new Float32Array(vertices * 3);
            var normals = new Float32Array(vertices * 3);
            var uvs = new Float32Array(vertices * 2);
            normals[2] = 1;
            uvs[0] = 0.5;
            uvs[1] = 0.5;
            for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
              var segment = thetaStart + s / segments * thetaLength;
              positions[i] = radius * Math.cos(segment);
              positions[i + 1] = radius * Math.sin(segment);
              normals[i + 2] = 1;
              uvs[ii] = (positions[i] / radius + 1) / 2;
              uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
            }
            var indices = [];
            for (var i = 1; i <= segments; i++) {
              indices.push(i, i + 1, 0);
            }
            this.setIndex(new BufferAttribute(new Uint16Array(indices), 1));
            this.addAttribute("position", new BufferAttribute(positions, 3));
            this.addAttribute("normal", new BufferAttribute(normals, 3));
            this.addAttribute("uv", new BufferAttribute(uvs, 2));
            this.boundingSphere = new Sphere(new Vector3(), radius);
          }
          CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
          function CircleGeometry(radius, segments, thetaStart, thetaLength) {
            Geometry.call(this);
            this.type = "CircleGeometry";
            this.parameters = {
              radius,
              segments,
              thetaStart,
              thetaLength
            };
            this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
          }
          CircleGeometry.prototype = Object.create(Geometry.prototype);
          CircleGeometry.prototype.constructor = CircleGeometry;
          function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
            Geometry.call(this);
            this.type = "BoxGeometry";
            this.parameters = {
              width,
              height,
              depth,
              widthSegments,
              heightSegments,
              depthSegments
            };
            this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
            this.mergeVertices();
          }
          BoxGeometry.prototype = Object.create(Geometry.prototype);
          BoxGeometry.prototype.constructor = BoxGeometry;
          var Geometries = Object.freeze({
            WireframeGeometry,
            ParametricGeometry,
            ParametricBufferGeometry,
            TetrahedronGeometry,
            TetrahedronBufferGeometry,
            OctahedronGeometry,
            OctahedronBufferGeometry,
            IcosahedronGeometry,
            IcosahedronBufferGeometry,
            DodecahedronGeometry,
            DodecahedronBufferGeometry,
            PolyhedronGeometry,
            PolyhedronBufferGeometry,
            TubeGeometry,
            TubeBufferGeometry,
            TorusKnotGeometry,
            TorusKnotBufferGeometry,
            TorusGeometry,
            TorusBufferGeometry,
            TextGeometry,
            SphereBufferGeometry,
            SphereGeometry,
            RingGeometry,
            RingBufferGeometry,
            PlaneBufferGeometry,
            PlaneGeometry,
            LatheGeometry,
            LatheBufferGeometry,
            ShapeGeometry,
            ExtrudeGeometry,
            EdgesGeometry,
            ConeGeometry,
            ConeBufferGeometry,
            CylinderGeometry,
            CylinderBufferGeometry,
            CircleBufferGeometry,
            CircleGeometry,
            BoxBufferGeometry,
            BoxGeometry
          });
          function ShadowMaterial() {
            ShaderMaterial.call(this, {
              uniforms: UniformsUtils.merge([
                UniformsLib["lights"],
                {
                  opacity: { value: 1 }
                }
              ]),
              vertexShader: ShaderChunk["shadow_vert"],
              fragmentShader: ShaderChunk["shadow_frag"]
            });
            this.lights = true;
            this.transparent = true;
            Object.defineProperties(this, {
              opacity: {
                enumerable: true,
                get: function() {
                  return this.uniforms.opacity.value;
                },
                set: function(value) {
                  this.uniforms.opacity.value = value;
                }
              }
            });
          }
          ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype);
          ShadowMaterial.prototype.constructor = ShadowMaterial;
          ShadowMaterial.prototype.isShadowMaterial = true;
          function RawShaderMaterial(parameters) {
            ShaderMaterial.call(this, parameters);
            this.type = "RawShaderMaterial";
          }
          RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
          RawShaderMaterial.prototype.constructor = RawShaderMaterial;
          RawShaderMaterial.prototype.isRawShaderMaterial = true;
          function MultiMaterial(materials) {
            this.uuid = _Math.generateUUID();
            this.type = "MultiMaterial";
            this.materials = materials instanceof Array ? materials : [];
            this.visible = true;
          }
          MultiMaterial.prototype = {
            constructor: MultiMaterial,
            isMultiMaterial: true,
            toJSON: function(meta) {
              var output = {
                metadata: {
                  version: 4.2,
                  type: "material",
                  generator: "MaterialExporter"
                },
                uuid: this.uuid,
                type: this.type,
                materials: []
              };
              var materials = this.materials;
              for (var i = 0, l = materials.length; i < l; i++) {
                var material = materials[i].toJSON(meta);
                delete material.metadata;
                output.materials.push(material);
              }
              output.visible = this.visible;
              return output;
            },
            clone: function() {
              var material = new this.constructor();
              for (var i = 0; i < this.materials.length; i++) {
                material.materials.push(this.materials[i].clone());
              }
              material.visible = this.visible;
              return material;
            }
          };
          function MeshStandardMaterial(parameters) {
            Material.call(this);
            this.defines = { "STANDARD": "" };
            this.type = "MeshStandardMaterial";
            this.color = new Color(16777215);
            this.roughness = 0.5;
            this.metalness = 0.5;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1;
            this.aoMap = null;
            this.aoMapIntensity = 1;
            this.emissive = new Color(0);
            this.emissiveIntensity = 1;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.roughnessMap = null;
            this.metalnessMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapIntensity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = "round";
            this.wireframeLinejoin = "round";
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
          }
          MeshStandardMaterial.prototype = Object.create(Material.prototype);
          MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
          MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
          MeshStandardMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.defines = { "STANDARD": "" };
            this.color.copy(source.color);
            this.roughness = source.roughness;
            this.metalness = source.metalness;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.roughnessMap = source.roughnessMap;
            this.metalnessMap = source.metalnessMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapIntensity = source.envMapIntensity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
          };
          function MeshPhysicalMaterial(parameters) {
            MeshStandardMaterial.call(this);
            this.defines = { "PHYSICAL": "" };
            this.type = "MeshPhysicalMaterial";
            this.reflectivity = 0.5;
            this.clearCoat = 0;
            this.clearCoatRoughness = 0;
            this.setValues(parameters);
          }
          MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
          MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
          MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
          MeshPhysicalMaterial.prototype.copy = function(source) {
            MeshStandardMaterial.prototype.copy.call(this, source);
            this.defines = { "PHYSICAL": "" };
            this.reflectivity = source.reflectivity;
            this.clearCoat = source.clearCoat;
            this.clearCoatRoughness = source.clearCoatRoughness;
            return this;
          };
          function MeshPhongMaterial(parameters) {
            Material.call(this);
            this.type = "MeshPhongMaterial";
            this.color = new Color(16777215);
            this.specular = new Color(1118481);
            this.shininess = 30;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1;
            this.aoMap = null;
            this.aoMapIntensity = 1;
            this.emissive = new Color(0);
            this.emissiveIntensity = 1;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = "round";
            this.wireframeLinejoin = "round";
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
          }
          MeshPhongMaterial.prototype = Object.create(Material.prototype);
          MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
          MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
          MeshPhongMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.specular.copy(source.specular);
            this.shininess = source.shininess;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
          };
          function MeshNormalMaterial(parameters) {
            Material.call(this, parameters);
            this.type = "MeshNormalMaterial";
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.morphTargets = false;
            this.setValues(parameters);
          }
          MeshNormalMaterial.prototype = Object.create(Material.prototype);
          MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
          MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
          MeshNormalMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
          };
          function MeshLambertMaterial(parameters) {
            Material.call(this);
            this.type = "MeshLambertMaterial";
            this.color = new Color(16777215);
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1;
            this.aoMap = null;
            this.aoMapIntensity = 1;
            this.emissive = new Color(0);
            this.emissiveIntensity = 1;
            this.emissiveMap = null;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = "round";
            this.wireframeLinejoin = "round";
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
          }
          MeshLambertMaterial.prototype = Object.create(Material.prototype);
          MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
          MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
          MeshLambertMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
          };
          function LineDashedMaterial(parameters) {
            Material.call(this);
            this.type = "LineDashedMaterial";
            this.color = new Color(16777215);
            this.linewidth = 1;
            this.scale = 1;
            this.dashSize = 3;
            this.gapSize = 1;
            this.lights = false;
            this.setValues(parameters);
          }
          LineDashedMaterial.prototype = Object.create(Material.prototype);
          LineDashedMaterial.prototype.constructor = LineDashedMaterial;
          LineDashedMaterial.prototype.isLineDashedMaterial = true;
          LineDashedMaterial.prototype.copy = function(source) {
            Material.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.linewidth = source.linewidth;
            this.scale = source.scale;
            this.dashSize = source.dashSize;
            this.gapSize = source.gapSize;
            return this;
          };
          var Materials = Object.freeze({
            ShadowMaterial,
            SpriteMaterial,
            RawShaderMaterial,
            ShaderMaterial,
            PointsMaterial,
            MultiMaterial,
            MeshPhysicalMaterial,
            MeshStandardMaterial,
            MeshPhongMaterial,
            MeshNormalMaterial,
            MeshLambertMaterial,
            MeshDepthMaterial,
            MeshBasicMaterial,
            LineDashedMaterial,
            LineBasicMaterial,
            Material
          });
          var Cache = {
            enabled: false,
            files: {},
            add: function(key, file) {
              if (this.enabled === false)
                return;
              this.files[key] = file;
            },
            get: function(key) {
              if (this.enabled === false)
                return;
              return this.files[key];
            },
            remove: function(key) {
              delete this.files[key];
            },
            clear: function() {
              this.files = {};
            }
          };
          function LoadingManager(onLoad, onProgress, onError) {
            var scope = this;
            var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
            this.onStart = void 0;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;
            this.itemStart = function(url) {
              itemsTotal++;
              if (isLoading === false) {
                if (scope.onStart !== void 0) {
                  scope.onStart(url, itemsLoaded, itemsTotal);
                }
              }
              isLoading = true;
            };
            this.itemEnd = function(url) {
              itemsLoaded++;
              if (scope.onProgress !== void 0) {
                scope.onProgress(url, itemsLoaded, itemsTotal);
              }
              if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== void 0) {
                  scope.onLoad();
                }
              }
            };
            this.itemError = function(url) {
              if (scope.onError !== void 0) {
                scope.onError(url);
              }
            };
          }
          var DefaultLoadingManager = new LoadingManager();
          function XHRLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(XHRLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              if (url === void 0)
                url = "";
              if (this.path !== void 0)
                url = this.path + url;
              var scope = this;
              var cached = Cache.get(url);
              if (cached !== void 0) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                  if (onLoad)
                    onLoad(cached);
                  scope.manager.itemEnd(url);
                }, 0);
                return cached;
              }
              var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
              var dataUriRegexResult = url.match(dataUriRegex);
              if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data);
                if (isBase64) {
                  data = window.atob(data);
                }
                try {
                  var response;
                  var responseType = (this.responseType || "").toLowerCase();
                  switch (responseType) {
                    case "arraybuffer":
                    case "blob":
                      response = new ArrayBuffer(data.length);
                      var view = new Uint8Array(response);
                      for (var i = 0; i < data.length; i++) {
                        view[i] = data.charCodeAt(i);
                      }
                      if (responseType === "blob") {
                        response = new Blob([response], { "type": mimeType });
                      }
                      break;
                    case "document":
                      var parser = new DOMParser();
                      response = parser.parseFromString(data, mimeType);
                      break;
                    case "json":
                      response = JSON.parse(data);
                      break;
                    default:
                      response = data;
                      break;
                  }
                  window.setTimeout(function() {
                    if (onLoad)
                      onLoad(response);
                    scope.manager.itemEnd(url);
                  }, 0);
                } catch (error) {
                  window.setTimeout(function() {
                    if (onError)
                      onError(error);
                    scope.manager.itemError(url);
                  }, 0);
                }
              } else {
                var request = new XMLHttpRequest();
                request.open("GET", url, true);
                request.addEventListener("load", function(event) {
                  var response2 = event.target.response;
                  Cache.add(url, response2);
                  if (this.status === 200) {
                    if (onLoad)
                      onLoad(response2);
                    scope.manager.itemEnd(url);
                  } else if (this.status === 0) {
                    console.warn("THREE.XHRLoader: HTTP Status 0 received.");
                    if (onLoad)
                      onLoad(response2);
                    scope.manager.itemEnd(url);
                  } else {
                    if (onError)
                      onError(event);
                    scope.manager.itemError(url);
                  }
                }, false);
                if (onProgress !== void 0) {
                  request.addEventListener("progress", function(event) {
                    onProgress(event);
                  }, false);
                }
                request.addEventListener("error", function(event) {
                  if (onError)
                    onError(event);
                  scope.manager.itemError(url);
                }, false);
                if (this.responseType !== void 0)
                  request.responseType = this.responseType;
                if (this.withCredentials !== void 0)
                  request.withCredentials = this.withCredentials;
                if (request.overrideMimeType)
                  request.overrideMimeType("text/plain");
                request.send(null);
              }
              scope.manager.itemStart(url);
              return request;
            },
            setPath: function(value) {
              this.path = value;
              return this;
            },
            setResponseType: function(value) {
              this.responseType = value;
              return this;
            },
            setWithCredentials: function(value) {
              this.withCredentials = value;
              return this;
            }
          });
          function CompressedTextureLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
            this._parser = null;
          }
          Object.assign(CompressedTextureLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var images = [];
              var texture = new CompressedTexture();
              texture.image = images;
              var loader = new XHRLoader(this.manager);
              loader.setPath(this.path);
              loader.setResponseType("arraybuffer");
              function loadTexture(i2) {
                loader.load(url[i2], function(buffer) {
                  var texDatas = scope._parser(buffer, true);
                  images[i2] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                  };
                  loaded += 1;
                  if (loaded === 6) {
                    if (texDatas.mipmapCount === 1)
                      texture.minFilter = LinearFilter;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                      onLoad(texture);
                  }
                }, onProgress, onError);
              }
              if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                  loadTexture(i);
                }
              } else {
                loader.load(url, function(buffer) {
                  var texDatas = scope._parser(buffer, true);
                  if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (var f = 0; f < faces; f++) {
                      images[f] = { mipmaps: [] };
                      for (var i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                      }
                    }
                  } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                  }
                  if (texDatas.mipmapCount === 1) {
                    texture.minFilter = LinearFilter;
                  }
                  texture.format = texDatas.format;
                  texture.needsUpdate = true;
                  if (onLoad)
                    onLoad(texture);
                }, onProgress, onError);
              }
              return texture;
            },
            setPath: function(value) {
              this.path = value;
              return this;
            }
          });
          var DataTextureLoader = BinaryTextureLoader;
          function BinaryTextureLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
            this._parser = null;
          }
          Object.assign(BinaryTextureLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var texture = new DataTexture();
              var loader = new XHRLoader(this.manager);
              loader.setResponseType("arraybuffer");
              loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                if (!texData)
                  return;
                if (void 0 !== texData.image) {
                  texture.image = texData.image;
                } else if (void 0 !== texData.data) {
                  texture.image.width = texData.width;
                  texture.image.height = texData.height;
                  texture.image.data = texData.data;
                }
                texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : LinearFilter;
                texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
                texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1;
                if (void 0 !== texData.format) {
                  texture.format = texData.format;
                }
                if (void 0 !== texData.type) {
                  texture.type = texData.type;
                }
                if (void 0 !== texData.mipmaps) {
                  texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                  texture.minFilter = LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture, texData);
              }, onProgress, onError);
              return texture;
            }
          });
          function ImageLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(ImageLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
              image.onload = function() {
                image.onload = null;
                URL.revokeObjectURL(image.src);
                if (onLoad)
                  onLoad(image);
                scope.manager.itemEnd(url);
              };
              image.onerror = onError;
              if (url.indexOf("data:") === 0) {
                image.src = url;
              } else {
                var loader = new XHRLoader();
                loader.setPath(this.path);
                loader.setResponseType("blob");
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(blob) {
                  image.src = URL.createObjectURL(blob);
                }, onProgress, onError);
              }
              scope.manager.itemStart(url);
              return image;
            },
            setCrossOrigin: function(value) {
              this.crossOrigin = value;
              return this;
            },
            setWithCredentials: function(value) {
              this.withCredentials = value;
              return this;
            },
            setPath: function(value) {
              this.path = value;
              return this;
            }
          });
          function CubeTextureLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(CubeTextureLoader.prototype, {
            load: function(urls, onLoad, onProgress, onError) {
              var texture = new CubeTexture();
              var loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin);
              loader.setPath(this.path);
              var loaded = 0;
              function loadTexture(i2) {
                loader.load(urls[i2], function(image) {
                  texture.images[i2] = image;
                  loaded++;
                  if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad)
                      onLoad(texture);
                  }
                }, void 0, onError);
              }
              for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
              }
              return texture;
            },
            setCrossOrigin: function(value) {
              this.crossOrigin = value;
              return this;
            },
            setPath: function(value) {
              this.path = value;
              return this;
            }
          });
          function TextureLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(TextureLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var texture = new Texture();
              var loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin);
              loader.setWithCredentials(this.withCredentials);
              loader.setPath(this.path);
              loader.load(url, function(image) {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.image = image;
                texture.needsUpdate = true;
                if (onLoad !== void 0) {
                  onLoad(texture);
                }
              }, onProgress, onError);
              return texture;
            },
            setCrossOrigin: function(value) {
              this.crossOrigin = value;
              return this;
            },
            setWithCredentials: function(value) {
              this.withCredentials = value;
              return this;
            },
            setPath: function(value) {
              this.path = value;
              return this;
            }
          });
          function Light(color, intensity) {
            Object3D.call(this);
            this.type = "Light";
            this.color = new Color(color);
            this.intensity = intensity !== void 0 ? intensity : 1;
            this.receiveShadow = void 0;
          }
          Light.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Light,
            isLight: true,
            copy: function(source) {
              Object3D.prototype.copy.call(this, source);
              this.color.copy(source.color);
              this.intensity = source.intensity;
              return this;
            },
            toJSON: function(meta) {
              var data = Object3D.prototype.toJSON.call(this, meta);
              data.object.color = this.color.getHex();
              data.object.intensity = this.intensity;
              if (this.groundColor !== void 0)
                data.object.groundColor = this.groundColor.getHex();
              if (this.distance !== void 0)
                data.object.distance = this.distance;
              if (this.angle !== void 0)
                data.object.angle = this.angle;
              if (this.decay !== void 0)
                data.object.decay = this.decay;
              if (this.penumbra !== void 0)
                data.object.penumbra = this.penumbra;
              if (this.shadow !== void 0)
                data.object.shadow = this.shadow.toJSON();
              return data;
            }
          });
          function HemisphereLight(skyColor, groundColor, intensity) {
            Light.call(this, skyColor, intensity);
            this.type = "HemisphereLight";
            this.castShadow = void 0;
            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();
            this.groundColor = new Color(groundColor);
          }
          HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: HemisphereLight,
            isHemisphereLight: true,
            copy: function(source) {
              Light.prototype.copy.call(this, source);
              this.groundColor.copy(source.groundColor);
              return this;
            }
          });
          function LightShadow(camera) {
            this.camera = camera;
            this.bias = 0;
            this.radius = 1;
            this.mapSize = new Vector2(512, 512);
            this.map = null;
            this.matrix = new Matrix4();
          }
          Object.assign(LightShadow.prototype, {
            copy: function(source) {
              this.camera = source.camera.clone();
              this.bias = source.bias;
              this.radius = source.radius;
              this.mapSize.copy(source.mapSize);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            toJSON: function() {
              var object = {};
              if (this.bias !== 0)
                object.bias = this.bias;
              if (this.radius !== 1)
                object.radius = this.radius;
              if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
                object.mapSize = this.mapSize.toArray();
              object.camera = this.camera.toJSON(false).object;
              delete object.camera.matrix;
              return object;
            }
          });
          function SpotLightShadow() {
            LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
          }
          SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
            constructor: SpotLightShadow,
            isSpotLightShadow: true,
            update: function(light) {
              var fov = _Math.RAD2DEG * 2 * light.angle;
              var aspect = this.mapSize.width / this.mapSize.height;
              var far = light.distance || 500;
              var camera = this.camera;
              if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
              }
            }
          });
          function SpotLight(color, intensity, distance, angle, penumbra, decay) {
            Light.call(this, color, intensity);
            this.type = "SpotLight";
            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new Object3D();
            Object.defineProperty(this, "power", {
              get: function() {
                return this.intensity * Math.PI;
              },
              set: function(power) {
                this.intensity = power / Math.PI;
              }
            });
            this.distance = distance !== void 0 ? distance : 0;
            this.angle = angle !== void 0 ? angle : Math.PI / 3;
            this.penumbra = penumbra !== void 0 ? penumbra : 0;
            this.decay = decay !== void 0 ? decay : 1;
            this.shadow = new SpotLightShadow();
          }
          SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: SpotLight,
            isSpotLight: true,
            copy: function(source) {
              Light.prototype.copy.call(this, source);
              this.distance = source.distance;
              this.angle = source.angle;
              this.penumbra = source.penumbra;
              this.decay = source.decay;
              this.target = source.target.clone();
              this.shadow = source.shadow.clone();
              return this;
            }
          });
          function PointLight(color, intensity, distance, decay) {
            Light.call(this, color, intensity);
            this.type = "PointLight";
            Object.defineProperty(this, "power", {
              get: function() {
                return this.intensity * 4 * Math.PI;
              },
              set: function(power) {
                this.intensity = power / (4 * Math.PI);
              }
            });
            this.distance = distance !== void 0 ? distance : 0;
            this.decay = decay !== void 0 ? decay : 1;
            this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
          }
          PointLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: PointLight,
            isPointLight: true,
            copy: function(source) {
              Light.prototype.copy.call(this, source);
              this.distance = source.distance;
              this.decay = source.decay;
              this.shadow = source.shadow.clone();
              return this;
            }
          });
          function DirectionalLightShadow(light) {
            LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
          }
          DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
            constructor: DirectionalLightShadow
          });
          function DirectionalLight(color, intensity) {
            Light.call(this, color, intensity);
            this.type = "DirectionalLight";
            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new Object3D();
            this.shadow = new DirectionalLightShadow();
          }
          DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: DirectionalLight,
            isDirectionalLight: true,
            copy: function(source) {
              Light.prototype.copy.call(this, source);
              this.target = source.target.clone();
              this.shadow = source.shadow.clone();
              return this;
            }
          });
          function AmbientLight(color, intensity) {
            Light.call(this, color, intensity);
            this.type = "AmbientLight";
            this.castShadow = void 0;
          }
          AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
            constructor: AmbientLight,
            isAmbientLight: true
          });
          var AnimationUtils = {
            // same as Array.prototype.slice, but also works on typed arrays
            arraySlice: function(array, from, to) {
              if (AnimationUtils.isTypedArray(array)) {
                return new array.constructor(array.subarray(from, to));
              }
              return array.slice(from, to);
            },
            // converts an array to a specific type
            convertArray: function(array, type, forceClone) {
              if (!array || // let 'undefined' and 'null' pass
              !forceClone && array.constructor === type)
                return array;
              if (typeof type.BYTES_PER_ELEMENT === "number") {
                return new type(array);
              }
              return Array.prototype.slice.call(array);
            },
            isTypedArray: function(object) {
              return ArrayBuffer.isView(object) && !(object instanceof DataView);
            },
            // returns an array by which times and values can be sorted
            getKeyframeOrder: function(times) {
              function compareTime(i2, j) {
                return times[i2] - times[j];
              }
              var n = times.length;
              var result = new Array(n);
              for (var i = 0; i !== n; ++i)
                result[i] = i;
              result.sort(compareTime);
              return result;
            },
            // uses the array previously returned by 'getKeyframeOrder' to sort data
            sortedArray: function(values, stride, order) {
              var nValues = values.length;
              var result = new values.constructor(nValues);
              for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                  result[dstOffset++] = values[srcOffset + j];
                }
              }
              return result;
            },
            // function for parsing AOS keyframe formats
            flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
              var i = 1, key = jsonKeys[0];
              while (key !== void 0 && key[valuePropertyName] === void 0) {
                key = jsonKeys[i++];
              }
              if (key === void 0)
                return;
              var value = key[valuePropertyName];
              if (value === void 0)
                return;
              if (Array.isArray(value)) {
                do {
                  value = key[valuePropertyName];
                  if (value !== void 0) {
                    times.push(key.time);
                    values.push.apply(values, value);
                  }
                  key = jsonKeys[i++];
                } while (key !== void 0);
              } else if (value.toArray !== void 0) {
                do {
                  value = key[valuePropertyName];
                  if (value !== void 0) {
                    times.push(key.time);
                    value.toArray(values, values.length);
                  }
                  key = jsonKeys[i++];
                } while (key !== void 0);
              } else {
                do {
                  value = key[valuePropertyName];
                  if (value !== void 0) {
                    times.push(key.time);
                    values.push(value);
                  }
                  key = jsonKeys[i++];
                } while (key !== void 0);
              }
            }
          };
          function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
          }
          Interpolant.prototype = {
            constructor: Interpolant,
            evaluate: function(t) {
              var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
              validate_interval: {
                seek: {
                  var right;
                  linear_scan: {
                    forward_scan:
                      if (!(t < t1)) {
                        for (var giveUpAt = i1 + 2; ; ) {
                          if (t1 === void 0) {
                            if (t < t0)
                              break forward_scan;
                            i1 = pp.length;
                            this._cachedIndex = i1;
                            return this.afterEnd_(i1 - 1, t, t0);
                          }
                          if (i1 === giveUpAt)
                            break;
                          t0 = t1;
                          t1 = pp[++i1];
                          if (t < t1) {
                            break seek;
                          }
                        }
                        right = pp.length;
                        break linear_scan;
                      }
                    if (!(t >= t0)) {
                      var t1global = pp[1];
                      if (t < t1global) {
                        i1 = 2;
                        t0 = t1global;
                      }
                      for (var giveUpAt = i1 - 2; ; ) {
                        if (t0 === void 0) {
                          this._cachedIndex = 0;
                          return this.beforeStart_(0, t, t1);
                        }
                        if (i1 === giveUpAt)
                          break;
                        t1 = t0;
                        t0 = pp[--i1 - 1];
                        if (t >= t0) {
                          break seek;
                        }
                      }
                      right = i1;
                      i1 = 0;
                      break linear_scan;
                    }
                    break validate_interval;
                  }
                  while (i1 < right) {
                    var mid = i1 + right >>> 1;
                    if (t < pp[mid]) {
                      right = mid;
                    } else {
                      i1 = mid + 1;
                    }
                  }
                  t1 = pp[i1];
                  t0 = pp[i1 - 1];
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                  }
                  if (t1 === void 0) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                  }
                }
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
              }
              return this.interpolate_(i1, t0, t, t1);
            },
            settings: null,
            // optional, subclass-specific settings structure
            // Note: The indirection allows central control of many interpolants.
            // --- Protected interface
            DefaultSettings_: {},
            getSettings_: function() {
              return this.settings || this.DefaultSettings_;
            },
            copySampleValue_: function(index) {
              var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
              for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
              }
              return result;
            },
            // Template methods for derived classes:
            interpolate_: function(i1, t0, t, t1) {
              throw new Error("call to abstract method");
            },
            intervalChanged_: function(i1, t0, t1) {
            }
          };
          Object.assign(Interpolant.prototype, {
            beforeStart_: (
              //( 0, t, t0 ), returns this.resultBuffer
              Interpolant.prototype.copySampleValue_
            ),
            afterEnd_: (
              //( N-1, tN-1, t ), returns this.resultBuffer
              Interpolant.prototype.copySampleValue_
            )
          });
          function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            Interpolant.call(
              this,
              parameterPositions,
              sampleValues,
              sampleSize,
              resultBuffer
            );
            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;
          }
          CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
            constructor: CubicInterpolant,
            DefaultSettings_: {
              endingStart: ZeroCurvatureEnding,
              endingEnd: ZeroCurvatureEnding
            },
            intervalChanged_: function(i1, t0, t1) {
              var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
              if (tPrev === void 0) {
                switch (this.getSettings_().endingStart) {
                  case ZeroSlopeEnding:
                    iPrev = i1;
                    tPrev = 2 * t0 - t1;
                    break;
                  case WrapAroundEnding:
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                  default:
                    iPrev = i1;
                    tPrev = t1;
                }
              }
              if (tNext === void 0) {
                switch (this.getSettings_().endingEnd) {
                  case ZeroSlopeEnding:
                    iNext = i1;
                    tNext = 2 * t1 - t0;
                    break;
                  case WrapAroundEnding:
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;
                  default:
                    iNext = i1 - 1;
                    tNext = t0;
                }
              }
              var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
              this._weightPrev = halfDt / (t0 - tPrev);
              this._weightNext = halfDt / (tNext - t1);
              this._offsetPrev = iPrev * stride;
              this._offsetNext = iNext * stride;
            },
            interpolate_: function(i1, t0, t, t1) {
              var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
              var sP = -wP * ppp + 2 * wP * pp - wP * p;
              var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
              var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
              var sN = wN * ppp - wN * pp;
              for (var i = 0; i !== stride; ++i) {
                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
              }
              return result;
            }
          });
          function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            Interpolant.call(
              this,
              parameterPositions,
              sampleValues,
              sampleSize,
              resultBuffer
            );
          }
          LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
            constructor: LinearInterpolant,
            interpolate_: function(i1, t0, t, t1) {
              var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
              for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
              }
              return result;
            }
          });
          function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            Interpolant.call(
              this,
              parameterPositions,
              sampleValues,
              sampleSize,
              resultBuffer
            );
          }
          DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
            constructor: DiscreteInterpolant,
            interpolate_: function(i1, t0, t, t1) {
              return this.copySampleValue_(i1 - 1);
            }
          });
          var KeyframeTrackPrototype;
          KeyframeTrackPrototype = {
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: InterpolateLinear,
            InterpolantFactoryMethodDiscrete: function(result) {
              return new DiscreteInterpolant(
                this.times,
                this.values,
                this.getValueSize(),
                result
              );
            },
            InterpolantFactoryMethodLinear: function(result) {
              return new LinearInterpolant(
                this.times,
                this.values,
                this.getValueSize(),
                result
              );
            },
            InterpolantFactoryMethodSmooth: function(result) {
              return new CubicInterpolant(
                this.times,
                this.values,
                this.getValueSize(),
                result
              );
            },
            setInterpolation: function(interpolation) {
              var factoryMethod;
              switch (interpolation) {
                case InterpolateDiscrete:
                  factoryMethod = this.InterpolantFactoryMethodDiscrete;
                  break;
                case InterpolateLinear:
                  factoryMethod = this.InterpolantFactoryMethodLinear;
                  break;
                case InterpolateSmooth:
                  factoryMethod = this.InterpolantFactoryMethodSmooth;
                  break;
              }
              if (factoryMethod === void 0) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0) {
                  if (interpolation !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                  } else {
                    throw new Error(message);
                  }
                }
                console.warn(message);
                return;
              }
              this.createInterpolant = factoryMethod;
            },
            getInterpolation: function() {
              switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                  return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                  return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                  return InterpolateSmooth;
              }
            },
            getValueSize: function() {
              return this.values.length / this.times.length;
            },
            // move all keyframes either forwards or backwards in time
            shift: function(timeOffset) {
              if (timeOffset !== 0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                  times[i] += timeOffset;
                }
              }
              return this;
            },
            // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
            scale: function(timeScale) {
              if (timeScale !== 1) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                  times[i] *= timeScale;
                }
              }
              return this;
            },
            // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
            // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
            trim: function(startTime, endTime) {
              var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
              while (from !== nKeys && times[from] < startTime)
                ++from;
              while (to !== -1 && times[to] > endTime)
                --to;
              ++to;
              if (from !== 0 || to !== nKeys) {
                if (from >= to)
                  to = Math.max(to, 1), from = to - 1;
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
              }
              return this;
            },
            // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
            validate: function() {
              var valid = true;
              var valueSize = this.getValueSize();
              if (valueSize - Math.floor(valueSize) !== 0) {
                console.error("invalid value size in track", this);
                valid = false;
              }
              var times = this.times, values = this.values, nKeys = times.length;
              if (nKeys === 0) {
                console.error("track is empty", this);
                valid = false;
              }
              var prevTime = null;
              for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === "number" && isNaN(currTime)) {
                  console.error("time is not a valid number", this, i, currTime);
                  valid = false;
                  break;
                }
                if (prevTime !== null && prevTime > currTime) {
                  console.error("out of order keys", this, i, currTime, prevTime);
                  valid = false;
                  break;
                }
                prevTime = currTime;
              }
              if (values !== void 0) {
                if (AnimationUtils.isTypedArray(values)) {
                  for (var i = 0, n = values.length; i !== n; ++i) {
                    var value = values[i];
                    if (isNaN(value)) {
                      console.error("value is not a valid number", this, i, value);
                      valid = false;
                      break;
                    }
                  }
                }
              }
              return valid;
            },
            // removes equivalent sequential keys as common in morph target sequences
            // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
            optimize: function() {
              var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
              for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                  if (!smoothInterpolation) {
                    var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for (var j = 0; j !== stride; ++j) {
                      var value = values[offset + j];
                      if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = true;
                        break;
                      }
                    }
                  } else
                    keep = true;
                }
                if (keep) {
                  if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    var readOffset = i * stride, writeOffset = writeIndex * stride;
                    for (var j = 0; j !== stride; ++j)
                      values[writeOffset + j] = values[readOffset + j];
                  }
                  ++writeIndex;
                }
              }
              if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)
                  values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
              }
              if (writeIndex !== times.length) {
                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
              }
              return this;
            }
          };
          function KeyframeTrackConstructor(name, times, values, interpolation) {
            if (name === void 0)
              throw new Error("track name is undefined");
            if (times === void 0 || times.length === 0) {
              throw new Error("no keyframes in track named " + name);
            }
            this.name = name;
            this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
            this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
            this.setInterpolation(interpolation || this.DefaultInterpolation);
            this.validate();
            this.optimize();
          }
          function VectorKeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.call(this, name, times, values, interpolation);
          }
          VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: VectorKeyframeTrack,
            ValueTypeName: "vector"
            // ValueBufferType is inherited
            // DefaultInterpolation is inherited
          });
          function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            Interpolant.call(
              this,
              parameterPositions,
              sampleValues,
              sampleSize,
              resultBuffer
            );
          }
          QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
            constructor: QuaternionLinearInterpolant,
            interpolate_: function(i1, t0, t, t1) {
              var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
              for (var end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(
                  result,
                  0,
                  values,
                  offset - stride,
                  values,
                  offset,
                  alpha
                );
              }
              return result;
            }
          });
          function QuaternionKeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.call(this, name, times, values, interpolation);
          }
          QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: QuaternionKeyframeTrack,
            ValueTypeName: "quaternion",
            // ValueBufferType is inherited
            DefaultInterpolation: InterpolateLinear,
            InterpolantFactoryMethodLinear: function(result) {
              return new QuaternionLinearInterpolant(
                this.times,
                this.values,
                this.getValueSize(),
                result
              );
            },
            InterpolantFactoryMethodSmooth: void 0
            // not yet implemented
          });
          function NumberKeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.call(this, name, times, values, interpolation);
          }
          NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: NumberKeyframeTrack,
            ValueTypeName: "number"
            // ValueBufferType is inherited
            // DefaultInterpolation is inherited
          });
          function StringKeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.call(this, name, times, values, interpolation);
          }
          StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: StringKeyframeTrack,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: InterpolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
          });
          function BooleanKeyframeTrack(name, times, values) {
            KeyframeTrackConstructor.call(this, name, times, values);
          }
          BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: BooleanKeyframeTrack,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: InterpolateDiscrete,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
            // Note: Actually this track could have a optimized / compressed
            // representation of a single value and a custom interpolant that
            // computes "firstValue ^ isOdd( index )".
          });
          function ColorKeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.call(this, name, times, values, interpolation);
          }
          ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
            constructor: ColorKeyframeTrack,
            ValueTypeName: "color"
            // ValueBufferType is inherited
            // DefaultInterpolation is inherited
            // Note: Very basic implementation and nothing special yet.
            // However, this is the place for color space parameterization.
          });
          function KeyframeTrack(name, times, values, interpolation) {
            KeyframeTrackConstructor.apply(this, arguments);
          }
          KeyframeTrack.prototype = KeyframeTrackPrototype;
          KeyframeTrackPrototype.constructor = KeyframeTrack;
          Object.assign(KeyframeTrack, {
            // Serialization (in static context, because of constructor invocation
            // and automatic invocation of .toJSON):
            parse: function(json) {
              if (json.type === void 0) {
                throw new Error("track type undefined, can not parse");
              }
              var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
              if (json.times === void 0) {
                var times = [], values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, "value");
                json.times = times;
                json.values = values;
              }
              if (trackType.parse !== void 0) {
                return trackType.parse(json);
              } else {
                return new trackType(
                  json.name,
                  json.times,
                  json.values,
                  json.interpolation
                );
              }
            },
            toJSON: function(track) {
              var trackType = track.constructor;
              var json;
              if (trackType.toJSON !== void 0) {
                json = trackType.toJSON(track);
              } else {
                json = {
                  "name": track.name,
                  "times": AnimationUtils.convertArray(track.times, Array),
                  "values": AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                  json.interpolation = interpolation;
                }
              }
              json.type = track.ValueTypeName;
              return json;
            },
            _getTrackTypeForValueTypeName: function(typeName) {
              switch (typeName.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                  return NumberKeyframeTrack;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                  return VectorKeyframeTrack;
                case "color":
                  return ColorKeyframeTrack;
                case "quaternion":
                  return QuaternionKeyframeTrack;
                case "bool":
                case "boolean":
                  return BooleanKeyframeTrack;
                case "string":
                  return StringKeyframeTrack;
              }
              throw new Error("Unsupported typeName: " + typeName);
            }
          });
          function AnimationClip(name, duration, tracks) {
            this.name = name;
            this.tracks = tracks;
            this.duration = duration !== void 0 ? duration : -1;
            this.uuid = _Math.generateUUID();
            if (this.duration < 0) {
              this.resetDuration();
            }
            this.optimize();
          }
          AnimationClip.prototype = {
            constructor: AnimationClip,
            resetDuration: function() {
              var tracks = this.tracks, duration = 0;
              for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(
                  duration,
                  track.times[track.times.length - 1]
                );
              }
              this.duration = duration;
            },
            trim: function() {
              for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
              }
              return this;
            },
            optimize: function() {
              for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
              }
              return this;
            }
          };
          Object.assign(AnimationClip, {
            parse: function(json) {
              var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
              for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
              }
              return new AnimationClip(json.name, json.duration, tracks);
            },
            toJSON: function(clip) {
              var tracks = [], clipTracks = clip.tracks;
              var json = {
                "name": clip.name,
                "duration": clip.duration,
                "tracks": tracks
              };
              for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
              }
              return json;
            },
            CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
              var numMorphTargets = morphTargetSequence.length;
              var tracks = [];
              for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push(
                  (i + numMorphTargets - 1) % numMorphTargets,
                  i,
                  (i + 1) % numMorphTargets
                );
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order);
                if (!noLoop && times[0] === 0) {
                  times.push(numMorphTargets);
                  values.push(values[0]);
                }
                tracks.push(
                  new NumberKeyframeTrack(
                    ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
                    times,
                    values
                  ).scale(1 / fps)
                );
              }
              return new AnimationClip(name, -1, tracks);
            },
            findByName: function(objectOrClipArray, name) {
              var clipArray = objectOrClipArray;
              if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
              }
              for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                  return clipArray[i];
                }
              }
              return null;
            },
            CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
              var animationToMorphTargets = {};
              var pattern = /^([\w-]*?)([\d]+)$/;
              for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                  var name = parts[1];
                  var animationMorphTargets = animationToMorphTargets[name];
                  if (!animationMorphTargets) {
                    animationToMorphTargets[name] = animationMorphTargets = [];
                  }
                  animationMorphTargets.push(morphTarget);
                }
              }
              var clips = [];
              for (var name in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
              }
              return clips;
            },
            // parse the animation.hierarchy format
            parseAnimation: function(animation, bones) {
              if (!animation) {
                console.error("  no animation in JSONLoader data");
                return null;
              }
              var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
                if (animationKeys2.length !== 0) {
                  var times2 = [];
                  var values2 = [];
                  AnimationUtils.flattenJSON(
                    animationKeys2,
                    times2,
                    values2,
                    propertyName
                  );
                  if (times2.length !== 0) {
                    destTracks.push(new trackType(trackName, times2, values2));
                  }
                }
              };
              var tracks = [];
              var clipName = animation.name || "default";
              var duration = animation.length || -1;
              var fps = animation.fps || 30;
              var hierarchyTracks = animation.hierarchy || [];
              for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (!animationKeys || animationKeys.length === 0)
                  continue;
                if (animationKeys[0].morphTargets) {
                  var morphTargetNames = {};
                  for (var k = 0; k < animationKeys.length; k++) {
                    if (animationKeys[k].morphTargets) {
                      for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                        morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                      }
                    }
                  }
                  for (var morphTargetName in morphTargetNames) {
                    var times = [];
                    var values = [];
                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                      var animationKey = animationKeys[k];
                      times.push(animationKey.time);
                      values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack(
                      ".morphTargetInfluence[" + morphTargetName + "]",
                      times,
                      values
                    ));
                  }
                  duration = morphTargetNames.length * (fps || 1);
                } else {
                  var boneName = ".bones[" + bones[h].name + "]";
                  addNonemptyTrack(
                    VectorKeyframeTrack,
                    boneName + ".position",
                    animationKeys,
                    "pos",
                    tracks
                  );
                  addNonemptyTrack(
                    QuaternionKeyframeTrack,
                    boneName + ".quaternion",
                    animationKeys,
                    "rot",
                    tracks
                  );
                  addNonemptyTrack(
                    VectorKeyframeTrack,
                    boneName + ".scale",
                    animationKeys,
                    "scl",
                    tracks
                  );
                }
              }
              if (tracks.length === 0) {
                return null;
              }
              var clip = new AnimationClip(clipName, duration, tracks);
              return clip;
            }
          });
          function MaterialLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
            this.textures = {};
          }
          Object.assign(MaterialLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new XHRLoader(scope.manager);
              loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
              }, onProgress, onError);
            },
            setTextures: function(value) {
              this.textures = value;
            },
            parse: function(json) {
              var textures = this.textures;
              function getTexture(name) {
                if (textures[name] === void 0) {
                  console.warn("THREE.MaterialLoader: Undefined texture", name);
                }
                return textures[name];
              }
              var material = new Materials[json.type]();
              if (json.uuid !== void 0)
                material.uuid = json.uuid;
              if (json.name !== void 0)
                material.name = json.name;
              if (json.color !== void 0)
                material.color.setHex(json.color);
              if (json.roughness !== void 0)
                material.roughness = json.roughness;
              if (json.metalness !== void 0)
                material.metalness = json.metalness;
              if (json.emissive !== void 0)
                material.emissive.setHex(json.emissive);
              if (json.specular !== void 0)
                material.specular.setHex(json.specular);
              if (json.shininess !== void 0)
                material.shininess = json.shininess;
              if (json.uniforms !== void 0)
                material.uniforms = json.uniforms;
              if (json.vertexShader !== void 0)
                material.vertexShader = json.vertexShader;
              if (json.fragmentShader !== void 0)
                material.fragmentShader = json.fragmentShader;
              if (json.vertexColors !== void 0)
                material.vertexColors = json.vertexColors;
              if (json.fog !== void 0)
                material.fog = json.fog;
              if (json.shading !== void 0)
                material.shading = json.shading;
              if (json.blending !== void 0)
                material.blending = json.blending;
              if (json.side !== void 0)
                material.side = json.side;
              if (json.opacity !== void 0)
                material.opacity = json.opacity;
              if (json.transparent !== void 0)
                material.transparent = json.transparent;
              if (json.alphaTest !== void 0)
                material.alphaTest = json.alphaTest;
              if (json.depthTest !== void 0)
                material.depthTest = json.depthTest;
              if (json.depthWrite !== void 0)
                material.depthWrite = json.depthWrite;
              if (json.colorWrite !== void 0)
                material.colorWrite = json.colorWrite;
              if (json.wireframe !== void 0)
                material.wireframe = json.wireframe;
              if (json.wireframeLinewidth !== void 0)
                material.wireframeLinewidth = json.wireframeLinewidth;
              if (json.wireframeLinecap !== void 0)
                material.wireframeLinecap = json.wireframeLinecap;
              if (json.wireframeLinejoin !== void 0)
                material.wireframeLinejoin = json.wireframeLinejoin;
              if (json.skinning !== void 0)
                material.skinning = json.skinning;
              if (json.morphTargets !== void 0)
                material.morphTargets = json.morphTargets;
              if (json.size !== void 0)
                material.size = json.size;
              if (json.sizeAttenuation !== void 0)
                material.sizeAttenuation = json.sizeAttenuation;
              if (json.map !== void 0)
                material.map = getTexture(json.map);
              if (json.alphaMap !== void 0) {
                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
              }
              if (json.bumpMap !== void 0)
                material.bumpMap = getTexture(json.bumpMap);
              if (json.bumpScale !== void 0)
                material.bumpScale = json.bumpScale;
              if (json.normalMap !== void 0)
                material.normalMap = getTexture(json.normalMap);
              if (json.normalScale !== void 0) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                  normalScale = [normalScale, normalScale];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
              }
              if (json.displacementMap !== void 0)
                material.displacementMap = getTexture(json.displacementMap);
              if (json.displacementScale !== void 0)
                material.displacementScale = json.displacementScale;
              if (json.displacementBias !== void 0)
                material.displacementBias = json.displacementBias;
              if (json.roughnessMap !== void 0)
                material.roughnessMap = getTexture(json.roughnessMap);
              if (json.metalnessMap !== void 0)
                material.metalnessMap = getTexture(json.metalnessMap);
              if (json.emissiveMap !== void 0)
                material.emissiveMap = getTexture(json.emissiveMap);
              if (json.emissiveIntensity !== void 0)
                material.emissiveIntensity = json.emissiveIntensity;
              if (json.specularMap !== void 0)
                material.specularMap = getTexture(json.specularMap);
              if (json.envMap !== void 0)
                material.envMap = getTexture(json.envMap);
              if (json.reflectivity !== void 0)
                material.reflectivity = json.reflectivity;
              if (json.lightMap !== void 0)
                material.lightMap = getTexture(json.lightMap);
              if (json.lightMapIntensity !== void 0)
                material.lightMapIntensity = json.lightMapIntensity;
              if (json.aoMap !== void 0)
                material.aoMap = getTexture(json.aoMap);
              if (json.aoMapIntensity !== void 0)
                material.aoMapIntensity = json.aoMapIntensity;
              if (json.materials !== void 0) {
                for (var i = 0, l = json.materials.length; i < l; i++) {
                  material.materials.push(this.parse(json.materials[i]));
                }
              }
              return material;
            }
          });
          function BufferGeometryLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(BufferGeometryLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new XHRLoader(scope.manager);
              loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
              }, onProgress, onError);
            },
            parse: function(json) {
              var geometry = new BufferGeometry();
              var index = json.data.index;
              var TYPED_ARRAYS = {
                "Int8Array": Int8Array,
                "Uint8Array": Uint8Array,
                "Uint8ClampedArray": Uint8ClampedArray,
                "Int16Array": Int16Array,
                "Uint16Array": Uint16Array,
                "Int32Array": Int32Array,
                "Uint32Array": Uint32Array,
                "Float32Array": Float32Array,
                "Float64Array": Float64Array
              };
              if (index !== void 0) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
              }
              var attributes = json.data.attributes;
              for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
              }
              var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
              if (groups !== void 0) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                  var group = groups[i];
                  geometry.addGroup(group.start, group.count, group.materialIndex);
                }
              }
              var boundingSphere = json.data.boundingSphere;
              if (boundingSphere !== void 0) {
                var center = new Vector3();
                if (boundingSphere.center !== void 0) {
                  center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
              }
              return geometry;
            }
          });
          function Loader() {
            this.onLoadStart = function() {
            };
            this.onLoadProgress = function() {
            };
            this.onLoadComplete = function() {
            };
          }
          Loader.prototype = {
            constructor: Loader,
            crossOrigin: void 0,
            extractUrlBase: function(url) {
              var parts = url.split("/");
              if (parts.length === 1)
                return "./";
              parts.pop();
              return parts.join("/") + "/";
            },
            initMaterials: function(materials, texturePath, crossOrigin) {
              var array = [];
              for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
              }
              return array;
            },
            createMaterial: /* @__PURE__ */ function() {
              var color, textureLoader, materialLoader;
              return function createMaterial(m, texturePath, crossOrigin) {
                if (color === void 0)
                  color = new Color();
                if (textureLoader === void 0)
                  textureLoader = new TextureLoader();
                if (materialLoader === void 0)
                  materialLoader = new MaterialLoader();
                var textures = {};
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                  var fullPath = texturePath + path;
                  var loader = Loader.Handlers.get(fullPath);
                  var texture;
                  if (loader !== null) {
                    texture = loader.load(fullPath);
                  } else {
                    textureLoader.setCrossOrigin(crossOrigin);
                    texture = textureLoader.load(fullPath);
                  }
                  if (repeat !== void 0) {
                    texture.repeat.fromArray(repeat);
                    if (repeat[0] !== 1)
                      texture.wrapS = RepeatWrapping;
                    if (repeat[1] !== 1)
                      texture.wrapT = RepeatWrapping;
                  }
                  if (offset !== void 0) {
                    texture.offset.fromArray(offset);
                  }
                  if (wrap !== void 0) {
                    if (wrap[0] === "repeat")
                      texture.wrapS = RepeatWrapping;
                    if (wrap[0] === "mirror")
                      texture.wrapS = MirroredRepeatWrapping;
                    if (wrap[1] === "repeat")
                      texture.wrapT = RepeatWrapping;
                    if (wrap[1] === "mirror")
                      texture.wrapT = MirroredRepeatWrapping;
                  }
                  if (anisotropy !== void 0) {
                    texture.anisotropy = anisotropy;
                  }
                  var uuid = _Math.generateUUID();
                  textures[uuid] = texture;
                  return uuid;
                }
                var json = {
                  uuid: _Math.generateUUID(),
                  type: "MeshLambertMaterial"
                };
                for (var name in m) {
                  var value = m[name];
                  switch (name) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                      break;
                    case "DbgName":
                      json.name = value;
                      break;
                    case "blending":
                      json.blending = BlendingMode[value];
                      break;
                    case "colorAmbient":
                    case "mapAmbient":
                      console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                      break;
                    case "colorDiffuse":
                      json.color = color.fromArray(value).getHex();
                      break;
                    case "colorSpecular":
                      json.specular = color.fromArray(value).getHex();
                      break;
                    case "colorEmissive":
                      json.emissive = color.fromArray(value).getHex();
                      break;
                    case "specularCoef":
                      json.shininess = value;
                      break;
                    case "shading":
                      if (value.toLowerCase() === "basic")
                        json.type = "MeshBasicMaterial";
                      if (value.toLowerCase() === "phong")
                        json.type = "MeshPhongMaterial";
                      if (value.toLowerCase() === "standard")
                        json.type = "MeshStandardMaterial";
                      break;
                    case "mapDiffuse":
                      json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                      break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                      break;
                    case "mapEmissive":
                      json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                      break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                      break;
                    case "mapLight":
                      json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                      break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                      break;
                    case "mapAO":
                      json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                      break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                      break;
                    case "mapBump":
                      json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                      break;
                    case "mapBumpScale":
                      json.bumpScale = value;
                      break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                      break;
                    case "mapNormal":
                      json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                      break;
                    case "mapNormalFactor":
                      json.normalScale = [value, value];
                      break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                      break;
                    case "mapSpecular":
                      json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                      break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                      break;
                    case "mapMetalness":
                      json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                      break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                      break;
                    case "mapRoughness":
                      json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                      break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                      break;
                    case "mapAlpha":
                      json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                      break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                      break;
                    case "flipSided":
                      json.side = BackSide;
                      break;
                    case "doubleSided":
                      json.side = DoubleSide;
                      break;
                    case "transparency":
                      console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                      json.opacity = value;
                      break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                      json[name] = value;
                      break;
                    case "vertexColors":
                      if (value === true)
                        json.vertexColors = VertexColors;
                      if (value === "face")
                        json.vertexColors = FaceColors;
                      break;
                    default:
                      console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                      break;
                  }
                }
                if (json.type === "MeshBasicMaterial")
                  delete json.emissive;
                if (json.type !== "MeshPhongMaterial")
                  delete json.specular;
                if (json.opacity < 1)
                  json.transparent = true;
                materialLoader.setTextures(textures);
                return materialLoader.parse(json);
              };
            }()
          };
          Loader.Handlers = {
            handlers: [],
            add: function(regex, loader) {
              this.handlers.push(regex, loader);
            },
            get: function(file) {
              var handlers = this.handlers;
              for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                  return loader;
                }
              }
              return null;
            }
          };
          function JSONLoader(manager) {
            if (typeof manager === "boolean") {
              console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor.");
              manager = void 0;
            }
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
            this.withCredentials = false;
          }
          Object.assign(JSONLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var texturePath = this.texturePath && typeof this.texturePath === "string" ? this.texturePath : Loader.prototype.extractUrlBase(url);
              var loader = new XHRLoader(this.manager);
              loader.setWithCredentials(this.withCredentials);
              loader.load(url, function(text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== void 0) {
                  var type = metadata.type;
                  if (type !== void 0) {
                    if (type.toLowerCase() === "object") {
                      console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                      return;
                    }
                    if (type.toLowerCase() === "scene") {
                      console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.");
                      return;
                    }
                  }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
              }, onProgress, onError);
            },
            setTexturePath: function(value) {
              this.texturePath = value;
            },
            parse: function(json, texturePath) {
              var geometry = new Geometry(), scale = json.scale !== void 0 ? 1 / json.scale : 1;
              parseModel(scale);
              parseSkin();
              parseMorphing(scale);
              parseAnimations();
              geometry.computeFaceNormals();
              geometry.computeBoundingSphere();
              function parseModel(scale2) {
                function isBitSet(value, position) {
                  return value & 1 << position;
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
                if (json.uvs !== void 0) {
                  for (i = 0; i < json.uvs.length; i++) {
                    if (json.uvs[i].length)
                      nUvLayers++;
                  }
                  for (i = 0; i < nUvLayers; i++) {
                    geometry.faceVertexUvs[i] = [];
                  }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                  vertex = new Vector3();
                  vertex.x = vertices[offset++] * scale2;
                  vertex.y = vertices[offset++] * scale2;
                  vertex.z = vertices[offset++] * scale2;
                  geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                  type = faces[offset++];
                  isQuad = isBitSet(type, 0);
                  hasMaterial = isBitSet(type, 1);
                  hasFaceVertexUv = isBitSet(type, 3);
                  hasFaceNormal = isBitSet(type, 4);
                  hasFaceVertexNormal = isBitSet(type, 5);
                  hasFaceColor = isBitSet(type, 6);
                  hasFaceVertexColor = isBitSet(type, 7);
                  if (isQuad) {
                    faceA = new Face3();
                    faceA.a = faces[offset];
                    faceA.b = faces[offset + 1];
                    faceA.c = faces[offset + 3];
                    faceB = new Face3();
                    faceB.a = faces[offset + 1];
                    faceB.b = faces[offset + 2];
                    faceB.c = faces[offset + 3];
                    offset += 4;
                    if (hasMaterial) {
                      materialIndex = faces[offset++];
                      faceA.materialIndex = materialIndex;
                      faceB.materialIndex = materialIndex;
                    }
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                      for (i = 0; i < nUvLayers; i++) {
                        uvLayer = json.uvs[i];
                        geometry.faceVertexUvs[i][fi] = [];
                        geometry.faceVertexUvs[i][fi + 1] = [];
                        for (j = 0; j < 4; j++) {
                          uvIndex = faces[offset++];
                          u = uvLayer[uvIndex * 2];
                          v = uvLayer[uvIndex * 2 + 1];
                          uv = new Vector2(u, v);
                          if (j !== 2)
                            geometry.faceVertexUvs[i][fi].push(uv);
                          if (j !== 0)
                            geometry.faceVertexUvs[i][fi + 1].push(uv);
                        }
                      }
                    }
                    if (hasFaceNormal) {
                      normalIndex = faces[offset++] * 3;
                      faceA.normal.set(
                        normals[normalIndex++],
                        normals[normalIndex++],
                        normals[normalIndex]
                      );
                      faceB.normal.copy(faceA.normal);
                    }
                    if (hasFaceVertexNormal) {
                      for (i = 0; i < 4; i++) {
                        normalIndex = faces[offset++] * 3;
                        normal = new Vector3(
                          normals[normalIndex++],
                          normals[normalIndex++],
                          normals[normalIndex]
                        );
                        if (i !== 2)
                          faceA.vertexNormals.push(normal);
                        if (i !== 0)
                          faceB.vertexNormals.push(normal);
                      }
                    }
                    if (hasFaceColor) {
                      colorIndex = faces[offset++];
                      hex = colors[colorIndex];
                      faceA.color.setHex(hex);
                      faceB.color.setHex(hex);
                    }
                    if (hasFaceVertexColor) {
                      for (i = 0; i < 4; i++) {
                        colorIndex = faces[offset++];
                        hex = colors[colorIndex];
                        if (i !== 2)
                          faceA.vertexColors.push(new Color(hex));
                        if (i !== 0)
                          faceB.vertexColors.push(new Color(hex));
                      }
                    }
                    geometry.faces.push(faceA);
                    geometry.faces.push(faceB);
                  } else {
                    face = new Face3();
                    face.a = faces[offset++];
                    face.b = faces[offset++];
                    face.c = faces[offset++];
                    if (hasMaterial) {
                      materialIndex = faces[offset++];
                      face.materialIndex = materialIndex;
                    }
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                      for (i = 0; i < nUvLayers; i++) {
                        uvLayer = json.uvs[i];
                        geometry.faceVertexUvs[i][fi] = [];
                        for (j = 0; j < 3; j++) {
                          uvIndex = faces[offset++];
                          u = uvLayer[uvIndex * 2];
                          v = uvLayer[uvIndex * 2 + 1];
                          uv = new Vector2(u, v);
                          geometry.faceVertexUvs[i][fi].push(uv);
                        }
                      }
                    }
                    if (hasFaceNormal) {
                      normalIndex = faces[offset++] * 3;
                      face.normal.set(
                        normals[normalIndex++],
                        normals[normalIndex++],
                        normals[normalIndex]
                      );
                    }
                    if (hasFaceVertexNormal) {
                      for (i = 0; i < 3; i++) {
                        normalIndex = faces[offset++] * 3;
                        normal = new Vector3(
                          normals[normalIndex++],
                          normals[normalIndex++],
                          normals[normalIndex]
                        );
                        face.vertexNormals.push(normal);
                      }
                    }
                    if (hasFaceColor) {
                      colorIndex = faces[offset++];
                      face.color.setHex(colors[colorIndex]);
                    }
                    if (hasFaceVertexColor) {
                      for (i = 0; i < 3; i++) {
                        colorIndex = faces[offset++];
                        face.vertexColors.push(new Color(colors[colorIndex]));
                      }
                    }
                    geometry.faces.push(face);
                  }
                }
              }
              function parseSkin() {
                var influencesPerVertex = json.influencesPerVertex !== void 0 ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                  for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                    var x = json.skinWeights[i];
                    var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                    var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                    var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                  }
                }
                if (json.skinIndices) {
                  for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                    var a = json.skinIndices[i];
                    var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                    var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                    var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                  }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                  console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
                }
              }
              function parseMorphing(scale2) {
                if (json.morphTargets !== void 0) {
                  for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                    geometry.morphTargets[i] = {};
                    geometry.morphTargets[i].name = json.morphTargets[i].name;
                    geometry.morphTargets[i].vertices = [];
                    var dstVertices = geometry.morphTargets[i].vertices;
                    var srcVertices = json.morphTargets[i].vertices;
                    for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                      var vertex = new Vector3();
                      vertex.x = srcVertices[v] * scale2;
                      vertex.y = srcVertices[v + 1] * scale2;
                      vertex.z = srcVertices[v + 2] * scale2;
                      dstVertices.push(vertex);
                    }
                  }
                }
                if (json.morphColors !== void 0 && json.morphColors.length > 0) {
                  console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                  var faces = geometry.faces;
                  var morphColors = json.morphColors[0].colors;
                  for (var i = 0, l = faces.length; i < l; i++) {
                    faces[i].color.fromArray(morphColors, i * 3);
                  }
                }
              }
              function parseAnimations() {
                var outputAnimations = [];
                var animations = [];
                if (json.animation !== void 0) {
                  animations.push(json.animation);
                }
                if (json.animations !== void 0) {
                  if (json.animations.length) {
                    animations = animations.concat(json.animations);
                  } else {
                    animations.push(json.animations);
                  }
                }
                for (var i = 0; i < animations.length; i++) {
                  var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                  if (clip)
                    outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                  var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                  outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0)
                  geometry.animations = outputAnimations;
              }
              if (json.materials === void 0 || json.materials.length === 0) {
                return { geometry };
              } else {
                var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                return { geometry, materials };
              }
            }
          });
          function ObjectLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
            this.texturePath = "";
          }
          Object.assign(ObjectLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              if (this.texturePath === "") {
                this.texturePath = url.substring(0, url.lastIndexOf("/") + 1);
              }
              var scope = this;
              var loader = new XHRLoader(scope.manager);
              loader.load(url, function(text) {
                scope.parse(JSON.parse(text), onLoad);
              }, onProgress, onError);
            },
            setTexturePath: function(value) {
              this.texturePath = value;
            },
            setCrossOrigin: function(value) {
              this.crossOrigin = value;
            },
            parse: function(json, onLoad) {
              var geometries = this.parseGeometries(json.geometries);
              var images = this.parseImages(json.images, function() {
                if (onLoad !== void 0)
                  onLoad(object);
              });
              var textures = this.parseTextures(json.textures, images);
              var materials = this.parseMaterials(json.materials, textures);
              var object = this.parseObject(json.object, geometries, materials);
              if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
              }
              if (json.images === void 0 || json.images.length === 0) {
                if (onLoad !== void 0)
                  onLoad(object);
              }
              return object;
            },
            parseGeometries: function(json) {
              var geometries = {};
              if (json !== void 0) {
                var geometryLoader = new JSONLoader();
                var bufferGeometryLoader = new BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                  var geometry;
                  var data = json[i];
                  switch (data.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.width,
                        data.height,
                        data.widthSegments,
                        data.heightSegments
                      );
                      break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                      geometry = new Geometries[data.type](
                        data.width,
                        data.height,
                        data.depth,
                        data.widthSegments,
                        data.heightSegments,
                        data.depthSegments
                      );
                      break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.segments,
                        data.thetaStart,
                        data.thetaLength
                      );
                      break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radiusTop,
                        data.radiusBottom,
                        data.height,
                        data.radialSegments,
                        data.heightSegments,
                        data.openEnded,
                        data.thetaStart,
                        data.thetaLength
                      );
                      break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.height,
                        data.radialSegments,
                        data.heightSegments,
                        data.openEnded,
                        data.thetaStart,
                        data.thetaLength
                      );
                      break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.widthSegments,
                        data.heightSegments,
                        data.phiStart,
                        data.phiLength,
                        data.thetaStart,
                        data.thetaLength
                      );
                      break;
                    case "DodecahedronGeometry":
                    case "IcosahedronGeometry":
                    case "OctahedronGeometry":
                    case "TetrahedronGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.detail
                      );
                      break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.innerRadius,
                        data.outerRadius,
                        data.thetaSegments,
                        data.phiSegments,
                        data.thetaStart,
                        data.thetaLength
                      );
                      break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.tube,
                        data.radialSegments,
                        data.tubularSegments,
                        data.arc
                      );
                      break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.radius,
                        data.tube,
                        data.tubularSegments,
                        data.radialSegments,
                        data.p,
                        data.q
                      );
                      break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                      geometry = new Geometries[data.type](
                        data.points,
                        data.segments,
                        data.phiStart,
                        data.phiLength
                      );
                      break;
                    case "BufferGeometry":
                      geometry = bufferGeometryLoader.parse(data);
                      break;
                    case "Geometry":
                      geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                      break;
                    default:
                      console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                      continue;
                  }
                  geometry.uuid = data.uuid;
                  if (data.name !== void 0)
                    geometry.name = data.name;
                  geometries[data.uuid] = geometry;
                }
              }
              return geometries;
            },
            parseMaterials: function(json, textures) {
              var materials = {};
              if (json !== void 0) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                  var material = loader.parse(json[i]);
                  materials[material.uuid] = material;
                }
              }
              return materials;
            },
            parseAnimations: function(json) {
              var animations = [];
              for (var i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
              }
              return animations;
            },
            parseImages: function(json, onLoad) {
              var scope = this;
              var images = {};
              function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function() {
                  scope.manager.itemEnd(url);
                }, void 0, function() {
                  scope.manager.itemError(url);
                });
              }
              if (json !== void 0 && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                var loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                  var image = json[i];
                  var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                  images[image.uuid] = loadImage(path);
                }
              }
              return images;
            },
            parseTextures: function(json, images) {
              function parseConstant(value, type) {
                if (typeof value === "number")
                  return value;
                console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
                return type[value];
              }
              var textures = {};
              if (json !== void 0) {
                for (var i = 0, l = json.length; i < l; i++) {
                  var data = json[i];
                  if (data.image === void 0) {
                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                  }
                  if (images[data.image] === void 0) {
                    console.warn("THREE.ObjectLoader: Undefined image", data.image);
                  }
                  var texture = new Texture(images[data.image]);
                  texture.needsUpdate = true;
                  texture.uuid = data.uuid;
                  if (data.name !== void 0)
                    texture.name = data.name;
                  if (data.mapping !== void 0)
                    texture.mapping = parseConstant(data.mapping, TextureMapping);
                  if (data.offset !== void 0)
                    texture.offset.fromArray(data.offset);
                  if (data.repeat !== void 0)
                    texture.repeat.fromArray(data.repeat);
                  if (data.wrap !== void 0) {
                    texture.wrapS = parseConstant(data.wrap[0], TextureWrapping);
                    texture.wrapT = parseConstant(data.wrap[1], TextureWrapping);
                  }
                  if (data.minFilter !== void 0)
                    texture.minFilter = parseConstant(data.minFilter, TextureFilter);
                  if (data.magFilter !== void 0)
                    texture.magFilter = parseConstant(data.magFilter, TextureFilter);
                  if (data.anisotropy !== void 0)
                    texture.anisotropy = data.anisotropy;
                  if (data.flipY !== void 0)
                    texture.flipY = data.flipY;
                  textures[data.uuid] = texture;
                }
              }
              return textures;
            },
            parseObject: function() {
              var matrix = new Matrix4();
              return function parseObject(data, geometries, materials) {
                var object;
                function getGeometry(name) {
                  if (geometries[name] === void 0) {
                    console.warn("THREE.ObjectLoader: Undefined geometry", name);
                  }
                  return geometries[name];
                }
                function getMaterial(name) {
                  if (name === void 0)
                    return void 0;
                  if (materials[name] === void 0) {
                    console.warn("THREE.ObjectLoader: Undefined material", name);
                  }
                  return materials[name];
                }
                switch (data.type) {
                  case "Scene":
                    object = new Scene();
                    if (data.background !== void 0) {
                      if (Number.isInteger(data.background)) {
                        object.background = new Color(data.background);
                      }
                    }
                    if (data.fog !== void 0) {
                      if (data.fog.type === "Fog") {
                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                      } else if (data.fog.type === "FogExp2") {
                        object.fog = new FogExp2(data.fog.color, data.fog.density);
                      }
                    }
                    break;
                  case "PerspectiveCamera":
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== void 0)
                      object.focus = data.focus;
                    if (data.zoom !== void 0)
                      object.zoom = data.zoom;
                    if (data.filmGauge !== void 0)
                      object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== void 0)
                      object.filmOffset = data.filmOffset;
                    if (data.view !== void 0)
                      object.view = Object.assign({}, data.view);
                    break;
                  case "OrthographicCamera":
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;
                  case "AmbientLight":
                    object = new AmbientLight(data.color, data.intensity);
                    break;
                  case "DirectionalLight":
                    object = new DirectionalLight(data.color, data.intensity);
                    break;
                  case "PointLight":
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                  case "SpotLight":
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;
                  case "HemisphereLight":
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                  case "Mesh":
                    var geometry = getGeometry(data.geometry);
                    var material = getMaterial(data.material);
                    if (geometry.bones && geometry.bones.length > 0) {
                      object = new SkinnedMesh(geometry, material);
                    } else {
                      object = new Mesh(geometry, material);
                    }
                    break;
                  case "LOD":
                    object = new LOD();
                    break;
                  case "Line":
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;
                  case "LineSegments":
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                  case "PointCloud":
                  case "Points":
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                  case "Sprite":
                    object = new Sprite(getMaterial(data.material));
                    break;
                  case "Group":
                    object = new Group();
                    break;
                  default:
                    object = new Object3D();
                }
                object.uuid = data.uuid;
                if (data.name !== void 0)
                  object.name = data.name;
                if (data.matrix !== void 0) {
                  matrix.fromArray(data.matrix);
                  matrix.decompose(object.position, object.quaternion, object.scale);
                } else {
                  if (data.position !== void 0)
                    object.position.fromArray(data.position);
                  if (data.rotation !== void 0)
                    object.rotation.fromArray(data.rotation);
                  if (data.quaternion !== void 0)
                    object.quaternion.fromArray(data.quaternion);
                  if (data.scale !== void 0)
                    object.scale.fromArray(data.scale);
                }
                if (data.castShadow !== void 0)
                  object.castShadow = data.castShadow;
                if (data.receiveShadow !== void 0)
                  object.receiveShadow = data.receiveShadow;
                if (data.shadow) {
                  if (data.shadow.bias !== void 0)
                    object.shadow.bias = data.shadow.bias;
                  if (data.shadow.radius !== void 0)
                    object.shadow.radius = data.shadow.radius;
                  if (data.shadow.mapSize !== void 0)
                    object.shadow.mapSize.fromArray(data.shadow.mapSize);
                  if (data.shadow.camera !== void 0)
                    object.shadow.camera = this.parseObject(data.shadow.camera);
                }
                if (data.visible !== void 0)
                  object.visible = data.visible;
                if (data.userData !== void 0)
                  object.userData = data.userData;
                if (data.children !== void 0) {
                  for (var child in data.children) {
                    object.add(this.parseObject(data.children[child], geometries, materials));
                  }
                }
                if (data.type === "LOD") {
                  var levels = data.levels;
                  for (var l = 0; l < levels.length; l++) {
                    var level = levels[l];
                    var child = object.getObjectByProperty("uuid", level.object);
                    if (child !== void 0) {
                      object.addLevel(child, level.distance);
                    }
                  }
                }
                return object;
              };
            }()
          });
          function Curve() {
          }
          Curve.prototype = {
            constructor: Curve,
            // Virtual base class method to overwrite and implement in subclasses
            //	- t [0 .. 1]
            getPoint: function(t) {
              console.warn("THREE.Curve: Warning, getPoint() not implemented!");
              return null;
            },
            // Get point at relative position in curve according to arc length
            // - u [0 .. 1]
            getPointAt: function(u) {
              var t = this.getUtoTmapping(u);
              return this.getPoint(t);
            },
            // Get sequence of points using getPoint( t )
            getPoints: function(divisions) {
              if (!divisions)
                divisions = 5;
              var points = [];
              for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
              }
              return points;
            },
            // Get sequence of points using getPointAt( u )
            getSpacedPoints: function(divisions) {
              if (!divisions)
                divisions = 5;
              var points = [];
              for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
              }
              return points;
            },
            // Get total curve arc length
            getLength: function() {
              var lengths = this.getLengths();
              return lengths[lengths.length - 1];
            },
            // Get list of cumulative segment lengths
            getLengths: function(divisions) {
              if (!divisions)
                divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
              if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                return this.cacheArcLengths;
              }
              this.needsUpdate = false;
              var cache = [];
              var current, last = this.getPoint(0);
              var p, sum = 0;
              cache.push(0);
              for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
              }
              this.cacheArcLengths = cache;
              return cache;
            },
            updateArcLengths: function() {
              this.needsUpdate = true;
              this.getLengths();
            },
            // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
            getUtoTmapping: function(u, distance) {
              var arcLengths = this.getLengths();
              var i = 0, il = arcLengths.length;
              var targetArcLength;
              if (distance) {
                targetArcLength = distance;
              } else {
                targetArcLength = u * arcLengths[il - 1];
              }
              var low = 0, high = il - 1, comparison;
              while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                  low = i + 1;
                } else if (comparison > 0) {
                  high = i - 1;
                } else {
                  high = i;
                  break;
                }
              }
              i = high;
              if (arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
              }
              var lengthBefore = arcLengths[i];
              var lengthAfter = arcLengths[i + 1];
              var segmentLength = lengthAfter - lengthBefore;
              var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
              var t = (i + segmentFraction) / (il - 1);
              return t;
            },
            // Returns a unit vector tangent at t
            // In case any sub curve does not implement its tangent derivation,
            // 2 points a small delta apart will be used to find its gradient
            // which seems to give a reasonable approximation
            getTangent: function(t) {
              var delta = 1e-4;
              var t1 = t - delta;
              var t2 = t + delta;
              if (t1 < 0)
                t1 = 0;
              if (t2 > 1)
                t2 = 1;
              var pt1 = this.getPoint(t1);
              var pt2 = this.getPoint(t2);
              var vec = pt2.clone().sub(pt1);
              return vec.normalize();
            },
            getTangentAt: function(u) {
              var t = this.getUtoTmapping(u);
              return this.getTangent(t);
            },
            computeFrenetFrames: function(segments, closed) {
              var normal = new Vector3();
              var tangents = [];
              var normals = [];
              var binormals = [];
              var vec = new Vector3();
              var mat = new Matrix4();
              var i, u, theta;
              for (i = 0; i <= segments; i++) {
                u = i / segments;
                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
              }
              normals[0] = new Vector3();
              binormals[0] = new Vector3();
              var min = Number.MAX_VALUE;
              var tx = Math.abs(tangents[0].x);
              var ty = Math.abs(tangents[0].y);
              var tz = Math.abs(tangents[0].z);
              if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
              }
              if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
              }
              if (tz <= min) {
                normal.set(0, 0, 1);
              }
              vec.crossVectors(tangents[0], normal).normalize();
              normals[0].crossVectors(tangents[0], vec);
              binormals[0].crossVectors(tangents[0], normals[0]);
              for (i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                  vec.normalize();
                  theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                  normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
              }
              if (closed === true) {
                theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                  theta = -theta;
                }
                for (i = 1; i <= segments; i++) {
                  normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                  binormals[i].crossVectors(tangents[i], normals[i]);
                }
              }
              return {
                tangents,
                normals,
                binormals
              };
            }
          };
          Curve.create = function(constructor, getPointFunc) {
            constructor.prototype = Object.create(Curve.prototype);
            constructor.prototype.constructor = constructor;
            constructor.prototype.getPoint = getPointFunc;
            return constructor;
          };
          function LineCurve(v1, v2) {
            this.v1 = v1;
            this.v2 = v2;
          }
          LineCurve.prototype = Object.create(Curve.prototype);
          LineCurve.prototype.constructor = LineCurve;
          LineCurve.prototype.isLineCurve = true;
          LineCurve.prototype.getPoint = function(t) {
            if (t === 1) {
              return this.v2.clone();
            }
            var point = this.v2.clone().sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
            return point;
          };
          LineCurve.prototype.getPointAt = function(u) {
            return this.getPoint(u);
          };
          LineCurve.prototype.getTangent = function(t) {
            var tangent = this.v2.clone().sub(this.v1);
            return tangent.normalize();
          };
          function CurvePath() {
            this.curves = [];
            this.autoClose = false;
          }
          CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
            constructor: CurvePath,
            add: function(curve) {
              this.curves.push(curve);
            },
            closePath: function() {
              var startPoint = this.curves[0].getPoint(0);
              var endPoint = this.curves[this.curves.length - 1].getPoint(1);
              if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
              }
            },
            // To get accurate point with reference to
            // entire path distance at time t,
            // following has to be done:
            // 1. Length of each sub path have to be known
            // 2. Locate and identify type of curve
            // 3. Get t for the curve
            // 4. Return curve.getPointAt(t')
            getPoint: function(t) {
              var d = t * this.getLength();
              var curveLengths = this.getCurveLengths();
              var i = 0;
              while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                  var diff = curveLengths[i] - d;
                  var curve = this.curves[i];
                  var segmentLength = curve.getLength();
                  var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getPointAt(u);
                }
                i++;
              }
              return null;
            },
            // We cannot use the default THREE.Curve getPoint() with getLength() because in
            // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
            // getPoint() depends on getLength
            getLength: function() {
              var lens = this.getCurveLengths();
              return lens[lens.length - 1];
            },
            // cacheLengths must be recalculated.
            updateArcLengths: function() {
              this.needsUpdate = true;
              this.cacheLengths = null;
              this.getLengths();
            },
            // Compute lengths and cache them
            // We cannot overwrite getLengths() because UtoT mapping uses it.
            getCurveLengths: function() {
              if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
              }
              var lengths = [], sums = 0;
              for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
              }
              this.cacheLengths = lengths;
              return lengths;
            },
            getSpacedPoints: function(divisions) {
              if (!divisions)
                divisions = 40;
              var points = [];
              for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
              }
              if (this.autoClose) {
                points.push(points[0]);
              }
              return points;
            },
            getPoints: function(divisions) {
              divisions = divisions || 12;
              var points = [], last;
              for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                  var point = pts[j];
                  if (last && last.equals(point))
                    continue;
                  points.push(point);
                  last = point;
                }
              }
              if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
              }
              return points;
            },
            /**************************************************************
             *	Create Geometries Helpers
             **************************************************************/
            /// Generate geometry from path points (for Line or Points objects)
            createPointsGeometry: function(divisions) {
              var pts = this.getPoints(divisions);
              return this.createGeometry(pts);
            },
            // Generate geometry from equidistant sampling along the path
            createSpacedPointsGeometry: function(divisions) {
              var pts = this.getSpacedPoints(divisions);
              return this.createGeometry(pts);
            },
            createGeometry: function(points) {
              var geometry = new Geometry();
              for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
              }
              return geometry;
            }
          });
          function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            this.aX = aX;
            this.aY = aY;
            this.xRadius = xRadius;
            this.yRadius = yRadius;
            this.aStartAngle = aStartAngle;
            this.aEndAngle = aEndAngle;
            this.aClockwise = aClockwise;
            this.aRotation = aRotation || 0;
          }
          EllipseCurve.prototype = Object.create(Curve.prototype);
          EllipseCurve.prototype.constructor = EllipseCurve;
          EllipseCurve.prototype.isEllipseCurve = true;
          EllipseCurve.prototype.getPoint = function(t) {
            var twoPi = Math.PI * 2;
            var deltaAngle = this.aEndAngle - this.aStartAngle;
            var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
            while (deltaAngle < 0)
              deltaAngle += twoPi;
            while (deltaAngle > twoPi)
              deltaAngle -= twoPi;
            if (deltaAngle < Number.EPSILON) {
              if (samePoints) {
                deltaAngle = 0;
              } else {
                deltaAngle = twoPi;
              }
            }
            if (this.aClockwise === true && !samePoints) {
              if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
              } else {
                deltaAngle = deltaAngle - twoPi;
              }
            }
            var angle = this.aStartAngle + t * deltaAngle;
            var x = this.aX + this.xRadius * Math.cos(angle);
            var y = this.aY + this.yRadius * Math.sin(angle);
            if (this.aRotation !== 0) {
              var cos = Math.cos(this.aRotation);
              var sin = Math.sin(this.aRotation);
              var tx = x - this.aX;
              var ty = y - this.aY;
              x = tx * cos - ty * sin + this.aX;
              y = tx * sin + ty * cos + this.aY;
            }
            return new Vector2(x, y);
          };
          var CurveUtils = {
            tangentQuadraticBezier: function(t, p0, p1, p2) {
              return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
            },
            // Puay Bing, thanks for helping with this derivative!
            tangentCubicBezier: function(t, p0, p1, p2, p3) {
              return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
            },
            tangentSpline: function(t, p0, p1, p2, p3) {
              var h00 = 6 * t * t - 6 * t;
              var h10 = 3 * t * t - 4 * t + 1;
              var h01 = -6 * t * t + 6 * t;
              var h11 = 3 * t * t - 2 * t;
              return h00 + h10 + h01 + h11;
            },
            // Catmull-Rom
            interpolate: function(p0, p1, p2, p3, t) {
              var v0 = (p2 - p0) * 0.5;
              var v1 = (p3 - p1) * 0.5;
              var t2 = t * t;
              var t3 = t * t2;
              return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
          };
          function SplineCurve(points) {
            this.points = points === void 0 ? [] : points;
          }
          SplineCurve.prototype = Object.create(Curve.prototype);
          SplineCurve.prototype.constructor = SplineCurve;
          SplineCurve.prototype.isSplineCurve = true;
          SplineCurve.prototype.getPoint = function(t) {
            var points = this.points;
            var point = (points.length - 1) * t;
            var intPoint = Math.floor(point);
            var weight = point - intPoint;
            var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            var point1 = points[intPoint];
            var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
            var interpolate = CurveUtils.interpolate;
            return new Vector2(
              interpolate(point0.x, point1.x, point2.x, point3.x, weight),
              interpolate(point0.y, point1.y, point2.y, point3.y, weight)
            );
          };
          function CubicBezierCurve(v0, v1, v2, v3) {
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;
          }
          CubicBezierCurve.prototype = Object.create(Curve.prototype);
          CubicBezierCurve.prototype.constructor = CubicBezierCurve;
          CubicBezierCurve.prototype.getPoint = function(t) {
            var b3 = ShapeUtils.b3;
            return new Vector2(
              b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
              b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
            );
          };
          CubicBezierCurve.prototype.getTangent = function(t) {
            var tangentCubicBezier = CurveUtils.tangentCubicBezier;
            return new Vector2(
              tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
              tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)
            ).normalize();
          };
          function QuadraticBezierCurve(v0, v1, v2) {
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
          }
          QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
          QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
          QuadraticBezierCurve.prototype.getPoint = function(t) {
            var b2 = ShapeUtils.b2;
            return new Vector2(
              b2(t, this.v0.x, this.v1.x, this.v2.x),
              b2(t, this.v0.y, this.v1.y, this.v2.y)
            );
          };
          QuadraticBezierCurve.prototype.getTangent = function(t) {
            var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;
            return new Vector2(
              tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x),
              tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)
            ).normalize();
          };
          var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
            fromPoints: function(vectors) {
              this.moveTo(vectors[0].x, vectors[0].y);
              for (var i = 1, l = vectors.length; i < l; i++) {
                this.lineTo(vectors[i].x, vectors[i].y);
              }
            },
            moveTo: function(x, y) {
              this.currentPoint.set(x, y);
            },
            lineTo: function(x, y) {
              var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
              this.curves.push(curve);
              this.currentPoint.set(x, y);
            },
            quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
              var curve = new QuadraticBezierCurve(
                this.currentPoint.clone(),
                new Vector2(aCPx, aCPy),
                new Vector2(aX, aY)
              );
              this.curves.push(curve);
              this.currentPoint.set(aX, aY);
            },
            bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              var curve = new CubicBezierCurve(
                this.currentPoint.clone(),
                new Vector2(aCP1x, aCP1y),
                new Vector2(aCP2x, aCP2y),
                new Vector2(aX, aY)
              );
              this.curves.push(curve);
              this.currentPoint.set(aX, aY);
            },
            splineThru: function(pts) {
              var npts = [this.currentPoint.clone()].concat(pts);
              var curve = new SplineCurve(npts);
              this.curves.push(curve);
              this.currentPoint.copy(pts[pts.length - 1]);
            },
            arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              var x0 = this.currentPoint.x;
              var y0 = this.currentPoint.y;
              this.absarc(
                aX + x0,
                aY + y0,
                aRadius,
                aStartAngle,
                aEndAngle,
                aClockwise
              );
            },
            absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
            },
            ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              var x0 = this.currentPoint.x;
              var y0 = this.currentPoint.y;
              this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            },
            absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
              if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                  this.lineTo(firstPoint.x, firstPoint.y);
                }
              }
              this.curves.push(curve);
              var lastPoint = curve.getPoint(1);
              this.currentPoint.copy(lastPoint);
            }
          });
          function Shape() {
            Path.apply(this, arguments);
            this.holes = [];
          }
          Shape.prototype = Object.assign(Object.create(PathPrototype), {
            constructor: Shape,
            getPointsHoles: function(divisions) {
              var holesPts = [];
              for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
              }
              return holesPts;
            },
            // Get points of shape and holes (keypoints based on segments parameter)
            extractAllPoints: function(divisions) {
              return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
              };
            },
            extractPoints: function(divisions) {
              return this.extractAllPoints(divisions);
            }
          });
          function Path(points) {
            CurvePath.call(this);
            this.currentPoint = new Vector2();
            if (points) {
              this.fromPoints(points);
            }
          }
          Path.prototype = PathPrototype;
          PathPrototype.constructor = Path;
          function ShapePath() {
            this.subPaths = [];
            this.currentPath = null;
          }
          ShapePath.prototype = {
            moveTo: function(x, y) {
              this.currentPath = new Path();
              this.subPaths.push(this.currentPath);
              this.currentPath.moveTo(x, y);
            },
            lineTo: function(x, y) {
              this.currentPath.lineTo(x, y);
            },
            quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
              this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
            },
            bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
            },
            splineThru: function(pts) {
              this.currentPath.splineThru(pts);
            },
            toShapes: function(isCCW, noHoles) {
              function toShapesNoHoles(inSubpaths) {
                var shapes2 = [];
                for (var i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
                  var tmpPath2 = inSubpaths[i2];
                  var tmpShape2 = new Shape();
                  tmpShape2.curves = tmpPath2.curves;
                  shapes2.push(tmpShape2);
                }
                return shapes2;
              }
              function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                  var edgeLowPt = inPolygon[p];
                  var edgeHighPt = inPolygon[q];
                  var edgeDx = edgeHighPt.x - edgeLowPt.x;
                  var edgeDy = edgeHighPt.y - edgeLowPt.y;
                  if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0) {
                      edgeLowPt = inPolygon[q];
                      edgeDx = -edgeDx;
                      edgeHighPt = inPolygon[p];
                      edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                      continue;
                    if (inPt.y === edgeLowPt.y) {
                      if (inPt.x === edgeLowPt.x)
                        return true;
                    } else {
                      var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                      if (perpEdge === 0)
                        return true;
                      if (perpEdge < 0)
                        continue;
                      inside = !inside;
                    }
                  } else {
                    if (inPt.y !== edgeLowPt.y)
                      continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                      return true;
                  }
                }
                return inside;
              }
              var isClockWise = ShapeUtils.isClockWise;
              var subPaths = this.subPaths;
              if (subPaths.length === 0)
                return [];
              if (noHoles === true)
                return toShapesNoHoles(subPaths);
              var solid, tmpPath, tmpShape, shapes = [];
              if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
              }
              var holesFirst = !isClockWise(subPaths[0].getPoints());
              holesFirst = isCCW ? !holesFirst : holesFirst;
              var betterShapeHoles = [];
              var newShapes = [];
              var newShapeHoles = [];
              var mainIdx = 0;
              var tmpPoints;
              newShapes[mainIdx] = void 0;
              newShapeHoles[mainIdx] = [];
              for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                  if (!holesFirst && newShapes[mainIdx])
                    mainIdx++;
                  newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                  newShapes[mainIdx].s.curves = tmpPath.curves;
                  if (holesFirst)
                    mainIdx++;
                  newShapeHoles[mainIdx] = [];
                } else {
                  newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                }
              }
              if (!newShapes[0])
                return toShapesNoHoles(subPaths);
              if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                  betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                  var sho = newShapeHoles[sIdx];
                  for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                    var ho = sho[hIdx];
                    var hole_unassigned = true;
                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                      if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx !== s2Idx)
                          toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                        if (hole_unassigned) {
                          hole_unassigned = false;
                          betterShapeHoles[s2Idx].push(ho);
                        } else {
                          ambiguous = true;
                        }
                      }
                    }
                    if (hole_unassigned) {
                      betterShapeHoles[sIdx].push(ho);
                    }
                  }
                }
                if (toChange.length > 0) {
                  if (!ambiguous)
                    newShapeHoles = betterShapeHoles;
                }
              }
              var tmpHoles;
              for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                  tmpShape.holes.push(tmpHoles[j].h);
                }
              }
              return shapes;
            }
          };
          function Font(data) {
            this.data = data;
          }
          Object.assign(Font.prototype, {
            isFont: true,
            generateShapes: function(text, size, divisions) {
              function createPaths(text2) {
                var chars = String(text2).split("");
                var scale = size / data.resolution;
                var offset = 0;
                var paths2 = [];
                for (var i = 0; i < chars.length; i++) {
                  var ret = createPath(chars[i], scale, offset);
                  offset += ret.offset;
                  paths2.push(ret.path);
                }
                return paths2;
              }
              function createPath(c, scale, offset) {
                var glyph = data.glyphs[c] || data.glyphs["?"];
                if (!glyph)
                  return;
                var path = new ShapePath();
                var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
                var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
                if (glyph.o) {
                  var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
                  for (var i = 0, l = outline.length; i < l; ) {
                    var action = outline[i++];
                    switch (action) {
                      case "m":
                        x = outline[i++] * scale + offset;
                        y = outline[i++] * scale;
                        path.moveTo(x, y);
                        break;
                      case "l":
                        x = outline[i++] * scale + offset;
                        y = outline[i++] * scale;
                        path.lineTo(x, y);
                        break;
                      case "q":
                        cpx = outline[i++] * scale + offset;
                        cpy = outline[i++] * scale;
                        cpx1 = outline[i++] * scale + offset;
                        cpy1 = outline[i++] * scale;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        laste = pts[pts.length - 1];
                        if (laste) {
                          cpx0 = laste.x;
                          cpy0 = laste.y;
                          for (var i2 = 1; i2 <= divisions; i2++) {
                            var t = i2 / divisions;
                            b2(t, cpx0, cpx1, cpx);
                            b2(t, cpy0, cpy1, cpy);
                          }
                        }
                        break;
                      case "b":
                        cpx = outline[i++] * scale + offset;
                        cpy = outline[i++] * scale;
                        cpx1 = outline[i++] * scale + offset;
                        cpy1 = outline[i++] * scale;
                        cpx2 = outline[i++] * scale + offset;
                        cpy2 = outline[i++] * scale;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        laste = pts[pts.length - 1];
                        if (laste) {
                          cpx0 = laste.x;
                          cpy0 = laste.y;
                          for (var i2 = 1; i2 <= divisions; i2++) {
                            var t = i2 / divisions;
                            b3(t, cpx0, cpx1, cpx2, cpx);
                            b3(t, cpy0, cpy1, cpy2, cpy);
                          }
                        }
                        break;
                    }
                  }
                }
                return { offset: glyph.ha * scale, path };
              }
              if (size === void 0)
                size = 100;
              if (divisions === void 0)
                divisions = 4;
              var data = this.data;
              var paths = createPaths(text);
              var shapes = [];
              for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
              }
              return shapes;
            }
          });
          function FontLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(FontLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var scope = this;
              var loader = new XHRLoader(this.manager);
              loader.load(url, function(text) {
                var json;
                try {
                  json = JSON.parse(text);
                } catch (e2) {
                  console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
                  json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad)
                  onLoad(font);
              }, onProgress, onError);
            },
            parse: function(json) {
              return new Font(json);
            }
          });
          var context;
          function getAudioContext() {
            if (context === void 0) {
              context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return context;
          }
          function AudioLoader(manager) {
            this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          }
          Object.assign(AudioLoader.prototype, {
            load: function(url, onLoad, onProgress, onError) {
              var loader = new XHRLoader(this.manager);
              loader.setResponseType("arraybuffer");
              loader.load(url, function(buffer) {
                var context2 = getAudioContext();
                context2.decodeAudioData(buffer, function(audioBuffer) {
                  onLoad(audioBuffer);
                });
              }, onProgress, onError);
            }
          });
          function StereoCamera() {
            this.type = "StereoCamera";
            this.aspect = 1;
            this.eyeSep = 0.064;
            this.cameraL = new PerspectiveCamera();
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;
            this.cameraR = new PerspectiveCamera();
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;
          }
          Object.assign(StereoCamera.prototype, {
            update: function() {
              var instance, focus, fov, aspect, near, far, zoom;
              var eyeRight = new Matrix4();
              var eyeLeft = new Matrix4();
              return function update(camera) {
                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom;
                if (needsUpdate) {
                  instance = this;
                  focus = camera.focus;
                  fov = camera.fov;
                  aspect = camera.aspect * this.aspect;
                  near = camera.near;
                  far = camera.far;
                  zoom = camera.zoom;
                  var projectionMatrix = camera.projectionMatrix.clone();
                  var eyeSep = this.eyeSep / 2;
                  var eyeSepOnProjection = eyeSep * near / focus;
                  var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
                  var xmin, xmax;
                  eyeLeft.elements[12] = -eyeSep;
                  eyeRight.elements[12] = eyeSep;
                  xmin = -ymax * aspect + eyeSepOnProjection;
                  xmax = ymax * aspect + eyeSepOnProjection;
                  projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                  projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                  this.cameraL.projectionMatrix.copy(projectionMatrix);
                  xmin = -ymax * aspect - eyeSepOnProjection;
                  xmax = ymax * aspect - eyeSepOnProjection;
                  projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                  projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                  this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
              };
            }()
          });
          function CubeCamera(near, far, cubeResolution) {
            Object3D.call(this);
            this.type = "CubeCamera";
            var fov = 90, aspect = 1;
            var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
            cameraPX.up.set(0, -1, 0);
            cameraPX.lookAt(new Vector3(1, 0, 0));
            this.add(cameraPX);
            var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
            cameraNX.up.set(0, -1, 0);
            cameraNX.lookAt(new Vector3(-1, 0, 0));
            this.add(cameraNX);
            var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
            cameraPY.up.set(0, 0, 1);
            cameraPY.lookAt(new Vector3(0, 1, 0));
            this.add(cameraPY);
            var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
            cameraNY.up.set(0, 0, -1);
            cameraNY.lookAt(new Vector3(0, -1, 0));
            this.add(cameraNY);
            var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraPZ.up.set(0, -1, 0);
            cameraPZ.lookAt(new Vector3(0, 0, 1));
            this.add(cameraPZ);
            var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
            cameraNZ.up.set(0, -1, 0);
            cameraNZ.lookAt(new Vector3(0, 0, -1));
            this.add(cameraNZ);
            var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
            this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
            this.updateCubeMap = function(renderer, scene) {
              if (this.parent === null)
                this.updateMatrixWorld();
              var renderTarget = this.renderTarget;
              var generateMipmaps = renderTarget.texture.generateMipmaps;
              renderTarget.texture.generateMipmaps = false;
              renderTarget.activeCubeFace = 0;
              renderer.render(scene, cameraPX, renderTarget);
              renderTarget.activeCubeFace = 1;
              renderer.render(scene, cameraNX, renderTarget);
              renderTarget.activeCubeFace = 2;
              renderer.render(scene, cameraPY, renderTarget);
              renderTarget.activeCubeFace = 3;
              renderer.render(scene, cameraNY, renderTarget);
              renderTarget.activeCubeFace = 4;
              renderer.render(scene, cameraPZ, renderTarget);
              renderTarget.texture.generateMipmaps = generateMipmaps;
              renderTarget.activeCubeFace = 5;
              renderer.render(scene, cameraNZ, renderTarget);
              renderer.setRenderTarget(null);
            };
          }
          CubeCamera.prototype = Object.create(Object3D.prototype);
          CubeCamera.prototype.constructor = CubeCamera;
          function AudioListener() {
            Object3D.call(this);
            this.type = "AudioListener";
            this.context = getAudioContext();
            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: AudioListener,
            getInput: function() {
              return this.gain;
            },
            removeFilter: function() {
              if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
              }
            },
            getFilter: function() {
              return this.filter;
            },
            setFilter: function(value) {
              if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
              } else {
                this.gain.disconnect(this.context.destination);
              }
              this.filter = value;
              this.gain.connect(this.filter);
              this.filter.connect(this.context.destination);
            },
            getMasterVolume: function() {
              return this.gain.gain.value;
            },
            setMasterVolume: function(value) {
              this.gain.gain.value = value;
            },
            updateMatrixWorld: function() {
              var position = new Vector3();
              var quaternion = new Quaternion();
              var scale = new Vector3();
              var orientation = new Vector3();
              return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener;
                var up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale);
                orientation.set(0, 0, -1).applyQuaternion(quaternion);
                listener.setPosition(position.x, position.y, position.z);
                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
              };
            }()
          });
          function Audio(listener) {
            Object3D.call(this);
            this.type = "Audio";
            this.context = listener.context;
            this.source = this.context.createBufferSource();
            this.source.onended = this.onEnded.bind(this);
            this.gain = this.context.createGain();
            this.gain.connect(listener.getInput());
            this.autoplay = false;
            this.startTime = 0;
            this.playbackRate = 1;
            this.isPlaying = false;
            this.hasPlaybackControl = true;
            this.sourceType = "empty";
            this.filters = [];
          }
          Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
            constructor: Audio,
            getOutput: function() {
              return this.gain;
            },
            setNodeSource: function(audioNode) {
              this.hasPlaybackControl = false;
              this.sourceType = "audioNode";
              this.source = audioNode;
              this.connect();
              return this;
            },
            setBuffer: function(audioBuffer) {
              this.source.buffer = audioBuffer;
              this.sourceType = "buffer";
              if (this.autoplay)
                this.play();
              return this;
            },
            play: function() {
              if (this.isPlaying === true) {
                console.warn("THREE.Audio: Audio is already playing.");
                return;
              }
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              var source = this.context.createBufferSource();
              source.buffer = this.source.buffer;
              source.loop = this.source.loop;
              source.onended = this.source.onended;
              source.start(0, this.startTime);
              source.playbackRate.value = this.playbackRate;
              this.isPlaying = true;
              this.source = source;
              return this.connect();
            },
            pause: function() {
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              this.source.stop();
              this.startTime = this.context.currentTime;
              this.isPlaying = false;
              return this;
            },
            stop: function() {
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              this.source.stop();
              this.startTime = 0;
              this.isPlaying = false;
              return this;
            },
            connect: function() {
              if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                  this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
              } else {
                this.source.connect(this.getOutput());
              }
              return this;
            },
            disconnect: function() {
              if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                  this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
              } else {
                this.source.disconnect(this.getOutput());
              }
              return this;
            },
            getFilters: function() {
              return this.filters;
            },
            setFilters: function(value) {
              if (!value)
                value = [];
              if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
              } else {
                this.filters = value;
              }
              return this;
            },
            getFilter: function() {
              return this.getFilters()[0];
            },
            setFilter: function(filter) {
              return this.setFilters(filter ? [filter] : []);
            },
            setPlaybackRate: function(value) {
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              this.playbackRate = value;
              if (this.isPlaying === true) {
                this.source.playbackRate.value = this.playbackRate;
              }
              return this;
            },
            getPlaybackRate: function() {
              return this.playbackRate;
            },
            onEnded: function() {
              this.isPlaying = false;
            },
            getLoop: function() {
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return false;
              }
              return this.source.loop;
            },
            setLoop: function(value) {
              if (this.hasPlaybackControl === false) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              this.source.loop = value;
            },
            getVolume: function() {
              return this.gain.gain.value;
            },
            setVolume: function(value) {
              this.gain.gain.value = value;
              return this;
            }
          });
          function PositionalAudio(listener) {
            Audio.call(this, listener);
            this.panner = this.context.createPanner();
            this.panner.connect(this.gain);
          }
          PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
            constructor: PositionalAudio,
            getOutput: function() {
              return this.panner;
            },
            getRefDistance: function() {
              return this.panner.refDistance;
            },
            setRefDistance: function(value) {
              this.panner.refDistance = value;
            },
            getRolloffFactor: function() {
              return this.panner.rolloffFactor;
            },
            setRolloffFactor: function(value) {
              this.panner.rolloffFactor = value;
            },
            getDistanceModel: function() {
              return this.panner.distanceModel;
            },
            setDistanceModel: function(value) {
              this.panner.distanceModel = value;
            },
            getMaxDistance: function() {
              return this.panner.maxDistance;
            },
            setMaxDistance: function(value) {
              this.panner.maxDistance = value;
            },
            updateMatrixWorld: function() {
              var position = new Vector3();
              return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                position.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(position.x, position.y, position.z);
              };
            }()
          });
          function AudioAnalyser(audio, fftSize) {
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
          }
          Object.assign(AudioAnalyser.prototype, {
            getFrequencyData: function() {
              this.analyser.getByteFrequencyData(this.data);
              return this.data;
            },
            getAverageFrequency: function() {
              var value = 0, data = this.getFrequencyData();
              for (var i = 0; i < data.length; i++) {
                value += data[i];
              }
              return value / data.length;
            }
          });
          function PropertyMixer(binding, typeName, valueSize) {
            this.binding = binding;
            this.valueSize = valueSize;
            var bufferType = Float64Array, mixFunction;
            switch (typeName) {
              case "quaternion":
                mixFunction = this._slerp;
                break;
              case "string":
              case "bool":
                bufferType = Array, mixFunction = this._select;
                break;
              default:
                mixFunction = this._lerp;
            }
            this.buffer = new bufferType(valueSize * 4);
            this._mixBufferRegion = mixFunction;
            this.cumulativeWeight = 0;
            this.useCount = 0;
            this.referenceCount = 0;
          }
          PropertyMixer.prototype = {
            constructor: PropertyMixer,
            // accumulate data in the 'incoming' region into 'accu<i>'
            accumulate: function(accuIndex, weight) {
              var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
              if (currentWeight === 0) {
                for (var i = 0; i !== stride; ++i) {
                  buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
              } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
              }
              this.cumulativeWeight = currentWeight;
            },
            // apply the state of 'accu<i>' to the binding when accus differ
            apply: function(accuIndex) {
              var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
              this.cumulativeWeight = 0;
              if (weight < 1) {
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(
                  buffer,
                  offset,
                  originalValueOffset,
                  1 - weight,
                  stride
                );
              }
              for (var i = stride, e2 = stride + stride; i !== e2; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                  binding.setValue(buffer, offset);
                  break;
                }
              }
            },
            // remember the state of the bound property and copy it to both accus
            saveOriginalState: function() {
              var binding = this.binding;
              var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
              binding.getValue(buffer, originalValueOffset);
              for (var i = stride, e2 = originalValueOffset; i !== e2; ++i) {
                buffer[i] = buffer[originalValueOffset + i % stride];
              }
              this.cumulativeWeight = 0;
            },
            // apply the state previously taken via 'saveOriginalState' to the binding
            restoreOriginalState: function() {
              var originalValueOffset = this.valueSize * 3;
              this.binding.setValue(this.buffer, originalValueOffset);
            },
            // mix functions
            _select: function(buffer, dstOffset, srcOffset, t, stride) {
              if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                  buffer[dstOffset + i] = buffer[srcOffset + i];
                }
              }
            },
            _slerp: function(buffer, dstOffset, srcOffset, t, stride) {
              Quaternion.slerpFlat(
                buffer,
                dstOffset,
                buffer,
                dstOffset,
                buffer,
                srcOffset,
                t
              );
            },
            _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
              var s = 1 - t;
              for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
              }
            }
          };
          function PropertyBinding(rootNode, path, parsedPath) {
            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
            this.node = PropertyBinding.findNode(
              rootNode,
              this.parsedPath.nodeName
            ) || rootNode;
            this.rootNode = rootNode;
          }
          PropertyBinding.prototype = {
            constructor: PropertyBinding,
            getValue: function getValue_unbound(targetArray, offset) {
              this.bind();
              this.getValue(targetArray, offset);
            },
            setValue: function getValue_unbound(sourceArray, offset) {
              this.bind();
              this.setValue(sourceArray, offset);
            },
            // create getter / setter pair for a property in the scene graph
            bind: function() {
              var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
              if (!targetObject) {
                targetObject = PropertyBinding.findNode(
                  this.rootNode,
                  parsedPath.nodeName
                ) || this.rootNode;
                this.node = targetObject;
              }
              this.getValue = this._getValue_unavailable;
              this.setValue = this._setValue_unavailable;
              if (!targetObject) {
                console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                return;
              }
              if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) {
                      console.error("  can not bind to material as node does not have a material", this);
                      return;
                    }
                    if (!targetObject.material.materials) {
                      console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                      return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                  case "bones":
                    if (!targetObject.skeleton) {
                      console.error("  can not bind to bones as node does not have a skeleton", this);
                      return;
                    }
                    targetObject = targetObject.skeleton.bones;
                    for (var i = 0; i < targetObject.length; i++) {
                      if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                      }
                    }
                    break;
                  default:
                    if (targetObject[objectName] === void 0) {
                      console.error("  can not bind to objectName of node, undefined", this);
                      return;
                    }
                    targetObject = targetObject[objectName];
                }
                if (objectIndex !== void 0) {
                  if (targetObject[objectIndex] === void 0) {
                    console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                    return;
                  }
                  targetObject = targetObject[objectIndex];
                }
              }
              var nodeProperty = targetObject[propertyName];
              if (nodeProperty === void 0) {
                var nodeName = parsedPath.nodeName;
                console.error("  trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
                return;
              }
              var versioning = this.Versioning.None;
              if (targetObject.needsUpdate !== void 0) {
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
              } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
              }
              var bindingType = this.BindingType.Direct;
              if (propertyIndex !== void 0) {
                if (propertyName === "morphTargetInfluences") {
                  if (!targetObject.geometry) {
                    console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                    return;
                  }
                  if (!targetObject.geometry.morphTargets) {
                    console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                    return;
                  }
                  for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                      propertyIndex = i;
                      break;
                    }
                  }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
              } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
              } else if (nodeProperty.length !== void 0) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
              } else {
                this.propertyName = propertyName;
              }
              this.getValue = this.GetterByBindingType[bindingType];
              this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
            },
            unbind: function() {
              this.node = null;
              this.getValue = this._getValue_unbound;
              this.setValue = this._setValue_unbound;
            }
          };
          Object.assign(PropertyBinding.prototype, {
            // prototype, continued
            // these are used to "bind" a nonexistent property
            _getValue_unavailable: function() {
            },
            _setValue_unavailable: function() {
            },
            // initial state of these methods that calls 'bind'
            _getValue_unbound: PropertyBinding.prototype.getValue,
            _setValue_unbound: PropertyBinding.prototype.setValue,
            BindingType: {
              Direct: 0,
              EntireArray: 1,
              ArrayElement: 2,
              HasFromToArray: 3
            },
            Versioning: {
              None: 0,
              NeedsUpdate: 1,
              MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [
              function getValue_direct(buffer, offset) {
                buffer[offset] = this.node[this.propertyName];
              },
              function getValue_array(buffer, offset) {
                var source = this.resolvedProperty;
                for (var i = 0, n = source.length; i !== n; ++i) {
                  buffer[offset++] = source[i];
                }
              },
              function getValue_arrayElement(buffer, offset) {
                buffer[offset] = this.resolvedProperty[this.propertyIndex];
              },
              function getValue_toArray(buffer, offset) {
                this.resolvedProperty.toArray(buffer, offset);
              }
            ],
            SetterByBindingTypeAndVersioning: [
              [
                // Direct
                function setValue_direct(buffer, offset) {
                  this.node[this.propertyName] = buffer[offset];
                },
                function setValue_direct_setNeedsUpdate(buffer, offset) {
                  this.node[this.propertyName] = buffer[offset];
                  this.targetObject.needsUpdate = true;
                },
                function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                  this.node[this.propertyName] = buffer[offset];
                  this.targetObject.matrixWorldNeedsUpdate = true;
                }
              ],
              [
                // EntireArray
                function setValue_array(buffer, offset) {
                  var dest = this.resolvedProperty;
                  for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                  }
                },
                function setValue_array_setNeedsUpdate(buffer, offset) {
                  var dest = this.resolvedProperty;
                  for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                  }
                  this.targetObject.needsUpdate = true;
                },
                function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                  var dest = this.resolvedProperty;
                  for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                  }
                  this.targetObject.matrixWorldNeedsUpdate = true;
                }
              ],
              [
                // ArrayElement
                function setValue_arrayElement(buffer, offset) {
                  this.resolvedProperty[this.propertyIndex] = buffer[offset];
                },
                function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                  this.resolvedProperty[this.propertyIndex] = buffer[offset];
                  this.targetObject.needsUpdate = true;
                },
                function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                  this.resolvedProperty[this.propertyIndex] = buffer[offset];
                  this.targetObject.matrixWorldNeedsUpdate = true;
                }
              ],
              [
                // HasToFromArray
                function setValue_fromArray(buffer, offset) {
                  this.resolvedProperty.fromArray(buffer, offset);
                },
                function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                  this.resolvedProperty.fromArray(buffer, offset);
                  this.targetObject.needsUpdate = true;
                },
                function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                  this.resolvedProperty.fromArray(buffer, offset);
                  this.targetObject.matrixWorldNeedsUpdate = true;
                }
              ]
            ]
          });
          PropertyBinding.Composite = function(targetGroup, path, optionalParsedPath) {
            var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
          };
          PropertyBinding.Composite.prototype = {
            constructor: PropertyBinding.Composite,
            getValue: function(array, offset) {
              this.bind();
              var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
              if (binding !== void 0)
                binding.getValue(array, offset);
            },
            setValue: function(array, offset) {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
              }
            },
            bind: function() {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
              }
            },
            unbind: function() {
              var bindings = this._bindings;
              for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
              }
            }
          };
          PropertyBinding.create = function(root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) {
              return new PropertyBinding(root, path, parsedPath);
            } else {
              return new PropertyBinding.Composite(root, path, parsedPath);
            }
          };
          PropertyBinding.parseTrackName = function(trackName) {
            var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
            var matches = re.exec(trackName);
            if (!matches) {
              throw new Error("cannot parse trackName at all: " + trackName);
            }
            var results = {
              // directoryName: matches[ 1 ], // (tschw) currently unused
              nodeName: matches[2],
              // allowed to be null, specified root node.
              objectName: matches[3],
              objectIndex: matches[4],
              propertyName: matches[5],
              propertyIndex: matches[6]
              // allowed to be null, specifies that the whole property is set.
            };
            if (results.propertyName === null || results.propertyName.length === 0) {
              throw new Error("can not parse propertyName from trackName: " + trackName);
            }
            return results;
          };
          PropertyBinding.findNode = function(root, nodeName) {
            if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
              return root;
            }
            if (root.skeleton) {
              var searchSkeleton = function(skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                  var bone2 = skeleton.bones[i];
                  if (bone2.name === nodeName) {
                    return bone2;
                  }
                }
                return null;
              };
              var bone = searchSkeleton(root.skeleton);
              if (bone) {
                return bone;
              }
            }
            if (root.children) {
              var searchNodeSubtree = function(children) {
                for (var i = 0; i < children.length; i++) {
                  var childNode = children[i];
                  if (childNode.name === nodeName || childNode.uuid === nodeName) {
                    return childNode;
                  }
                  var result = searchNodeSubtree(childNode.children);
                  if (result)
                    return result;
                }
                return null;
              };
              var subTreeNode = searchNodeSubtree(root.children);
              if (subTreeNode) {
                return subTreeNode;
              }
            }
            return null;
          };
          function AnimationObjectGroup(var_args) {
            this.uuid = _Math.generateUUID();
            this._objects = Array.prototype.slice.call(arguments);
            this.nCachedObjects_ = 0;
            var indices = {};
            this._indicesByUUID = indices;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
              indices[arguments[i].uuid] = i;
            }
            this._paths = [];
            this._parsedPaths = [];
            this._bindings = [];
            this._bindingsIndicesByPath = {};
            var scope = this;
            this.stats = {
              objects: {
                get total() {
                  return scope._objects.length;
                },
                get inUse() {
                  return this.total - scope.nCachedObjects_;
                }
              },
              get bindingsPerObject() {
                return scope._bindings.length;
              }
            };
          }
          AnimationObjectGroup.prototype = {
            constructor: AnimationObjectGroup,
            isAnimationObjectGroup: true,
            add: function(var_args) {
              var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index === void 0) {
                  index = nObjects++;
                  indicesByUUID[uuid] = index;
                  objects.push(object);
                  for (var j = 0, m = nBindings; j !== m; ++j) {
                    bindings[j].push(
                      new PropertyBinding(
                        object,
                        paths[j],
                        parsedPaths[j]
                      )
                    );
                  }
                } else if (index < nCachedObjects) {
                  var knownObject = objects[index];
                  var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                  indicesByUUID[lastCachedObject.uuid] = index;
                  objects[index] = lastCachedObject;
                  indicesByUUID[uuid] = firstActiveIndex;
                  objects[firstActiveIndex] = object;
                  for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === void 0) {
                      binding = new PropertyBinding(
                        object,
                        paths[j],
                        parsedPaths[j]
                      );
                    }
                    bindingsForPath[firstActiveIndex] = binding;
                  }
                } else if (objects[index] !== knownObject) {
                  console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...");
                }
              }
              this.nCachedObjects_ = nCachedObjects;
            },
            remove: function(var_args) {
              var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== void 0 && index >= nCachedObjects) {
                  var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                  indicesByUUID[firstActiveObject.uuid] = index;
                  objects[index] = firstActiveObject;
                  indicesByUUID[uuid] = lastCachedIndex;
                  objects[lastCachedIndex] = object;
                  for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                  }
                }
              }
              this.nCachedObjects_ = nCachedObjects;
            },
            // remove & forget
            uncache: function(var_args) {
              var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
              for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== void 0) {
                  delete indicesByUUID[uuid];
                  if (index < nCachedObjects) {
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                      var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                      bindingsForPath[index] = lastCached;
                      bindingsForPath[firstActiveIndex] = last;
                      bindingsForPath.pop();
                    }
                  } else {
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                      var bindingsForPath = bindings[j];
                      bindingsForPath[index] = bindingsForPath[lastIndex];
                      bindingsForPath.pop();
                    }
                  }
                }
              }
              this.nCachedObjects_ = nCachedObjects;
            },
            // Internal interface used by befriended PropertyBinding.Composite:
            subscribe_: function(path, parsedPath) {
              var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
              if (index !== void 0)
                return bindings[index];
              var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
              index = bindings.length;
              indicesByPath[path] = index;
              paths.push(path);
              parsedPaths.push(parsedPath);
              bindings.push(bindingsForPath);
              for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
              }
              return bindingsForPath;
            },
            unsubscribe_: function(path) {
              var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
              if (index !== void 0) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
              }
            }
          };
          function AnimationAction(mixer, clip, localRoot) {
            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot || null;
            var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
            var interpolantSettings = {
              endingStart: ZeroCurvatureEnding,
              endingEnd: ZeroCurvatureEnding
            };
            for (var i = 0; i !== nTracks; ++i) {
              var interpolant = tracks[i].createInterpolant(null);
              interpolants[i] = interpolant;
              interpolant.settings = interpolantSettings;
            }
            this._interpolantSettings = interpolantSettings;
            this._interpolants = interpolants;
            this._propertyBindings = new Array(nTracks);
            this._cacheIndex = null;
            this._byClipCacheIndex = null;
            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;
            this.loop = LoopRepeat;
            this._loopCount = -1;
            this._startTime = null;
            this.time = 0;
            this.timeScale = 1;
            this._effectiveTimeScale = 1;
            this.weight = 1;
            this._effectiveWeight = 1;
            this.repetitions = Infinity;
            this.paused = false;
            this.enabled = true;
            this.clampWhenFinished = false;
            this.zeroSlopeAtStart = true;
            this.zeroSlopeAtEnd = true;
          }
          AnimationAction.prototype = {
            constructor: AnimationAction,
            // State & Scheduling
            play: function() {
              this._mixer._activateAction(this);
              return this;
            },
            stop: function() {
              this._mixer._deactivateAction(this);
              return this.reset();
            },
            reset: function() {
              this.paused = false;
              this.enabled = true;
              this.time = 0;
              this._loopCount = -1;
              this._startTime = null;
              return this.stopFading().stopWarping();
            },
            isRunning: function() {
              return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
            },
            // return true when play has been called
            isScheduled: function() {
              return this._mixer._isActiveAction(this);
            },
            startAt: function(time) {
              this._startTime = time;
              return this;
            },
            setLoop: function(mode, repetitions) {
              this.loop = mode;
              this.repetitions = repetitions;
              return this;
            },
            // Weight
            // set the weight stopping any scheduled fading
            // although .enabled = false yields an effective weight of zero, this
            // method does *not* change .enabled, because it would be confusing
            setEffectiveWeight: function(weight) {
              this.weight = weight;
              this._effectiveWeight = this.enabled ? weight : 0;
              return this.stopFading();
            },
            // return the weight considering fading and .enabled
            getEffectiveWeight: function() {
              return this._effectiveWeight;
            },
            fadeIn: function(duration) {
              return this._scheduleFading(duration, 0, 1);
            },
            fadeOut: function(duration) {
              return this._scheduleFading(duration, 1, 0);
            },
            crossFadeFrom: function(fadeOutAction, duration, warp) {
              fadeOutAction.fadeOut(duration);
              this.fadeIn(duration);
              if (warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration);
                this.warp(endStartRatio, 1, duration);
              }
              return this;
            },
            crossFadeTo: function(fadeInAction, duration, warp) {
              return fadeInAction.crossFadeFrom(this, duration, warp);
            },
            stopFading: function() {
              var weightInterpolant = this._weightInterpolant;
              if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
              }
              return this;
            },
            // Time Scale Control
            // set the weight stopping any scheduled warping
            // although .paused = true yields an effective time scale of zero, this
            // method does *not* change .paused, because it would be confusing
            setEffectiveTimeScale: function(timeScale) {
              this.timeScale = timeScale;
              this._effectiveTimeScale = this.paused ? 0 : timeScale;
              return this.stopWarping();
            },
            // return the time scale considering warping and .paused
            getEffectiveTimeScale: function() {
              return this._effectiveTimeScale;
            },
            setDuration: function(duration) {
              this.timeScale = this._clip.duration / duration;
              return this.stopWarping();
            },
            syncWith: function(action) {
              this.time = action.time;
              this.timeScale = action.timeScale;
              return this.stopWarping();
            },
            halt: function(duration) {
              return this.warp(this._effectiveTimeScale, 0, duration);
            },
            warp: function(startTimeScale, endTimeScale, duration) {
              var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
              if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant;
              }
              var times = interpolant.parameterPositions, values = interpolant.sampleValues;
              times[0] = now;
              times[1] = now + duration;
              values[0] = startTimeScale / timeScale;
              values[1] = endTimeScale / timeScale;
              return this;
            },
            stopWarping: function() {
              var timeScaleInterpolant = this._timeScaleInterpolant;
              if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
              }
              return this;
            },
            // Object Accessors
            getMixer: function() {
              return this._mixer;
            },
            getClip: function() {
              return this._clip;
            },
            getRoot: function() {
              return this._localRoot || this._mixer._root;
            },
            // Interna
            _update: function(time, deltaTime, timeDirection, accuIndex) {
              var startTime = this._startTime;
              if (startTime !== null) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                  return;
                }
                this._startTime = null;
                deltaTime = timeDirection * timeRunning;
              }
              deltaTime *= this._updateTimeScale(time);
              var clipTime = this._updateTime(deltaTime);
              var weight = this._updateWeight(time);
              if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                for (var j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
              }
            },
            _updateWeight: function(time) {
              var weight = 0;
              if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                  var interpolantValue = interpolant.evaluate(time)[0];
                  weight *= interpolantValue;
                  if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) {
                      this.enabled = false;
                    }
                  }
                }
              }
              this._effectiveWeight = weight;
              return weight;
            },
            _updateTimeScale: function(time) {
              var timeScale = 0;
              if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                  var interpolantValue = interpolant.evaluate(time)[0];
                  timeScale *= interpolantValue;
                  if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) {
                      this.paused = true;
                    } else {
                      this.timeScale = timeScale;
                    }
                  }
                }
              }
              this._effectiveTimeScale = timeScale;
              return timeScale;
            },
            _updateTime: function(deltaTime) {
              var time = this.time + deltaTime;
              if (deltaTime === 0)
                return time;
              var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
              if (loop === LoopOnce) {
                if (loopCount === -1) {
                  this.loopCount = 0;
                  this._setEndings(true, true, false);
                }
                handle_stop: {
                  if (time >= duration) {
                    time = duration;
                  } else if (time < 0) {
                    time = 0;
                  } else
                    break handle_stop;
                  if (this.clampWhenFinished)
                    this.paused = true;
                  else
                    this.enabled = false;
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                  });
                }
              } else {
                var pingPong = loop === LoopPingPong;
                if (loopCount === -1) {
                  if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(
                      true,
                      this.repetitions === 0,
                      pingPong
                    );
                  } else {
                    this._setEndings(
                      this.repetitions === 0,
                      true,
                      pingPong
                    );
                  }
                }
                if (time >= duration || time < 0) {
                  var loopDelta = Math.floor(time / duration);
                  time -= duration * loopDelta;
                  loopCount += Math.abs(loopDelta);
                  var pending = this.repetitions - loopCount;
                  if (pending < 0) {
                    if (this.clampWhenFinished)
                      this.paused = true;
                    else
                      this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: deltaTime > 0 ? 1 : -1
                    });
                  } else {
                    if (pending === 0) {
                      var atStart = deltaTime < 0;
                      this._setEndings(atStart, !atStart, pingPong);
                    } else {
                      this._setEndings(false, false, pingPong);
                    }
                    this._loopCount = loopCount;
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta
                    });
                  }
                }
                if (pingPong && (loopCount & 1) === 1) {
                  this.time = time;
                  return duration - time;
                }
              }
              this.time = time;
              return time;
            },
            _setEndings: function(atStart, atEnd, pingPong) {
              var settings = this._interpolantSettings;
              if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
              } else {
                if (atStart) {
                  settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                  settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                  settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                  settings.endingEnd = WrapAroundEnding;
                }
              }
            },
            _scheduleFading: function(duration, weightNow, weightThen) {
              var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
              if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant;
              }
              var times = interpolant.parameterPositions, values = interpolant.sampleValues;
              times[0] = now;
              values[0] = weightNow;
              times[1] = now + duration;
              values[1] = weightThen;
              return this;
            }
          };
          function AnimationMixer(root) {
            this._root = root;
            this._initMemoryManager();
            this._accuIndex = 0;
            this.time = 0;
            this.timeScale = 1;
          }
          Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
            // return an action for a clip optionally using a custom root target
            // object (this method allocates a lot of dynamic memory in case a
            // previously unknown clip/root combination is specified)
            clipAction: function(clip, optionalRoot) {
              var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
              if (actionsForClip !== void 0) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== void 0) {
                  return existingAction;
                }
                prototypeAction = actionsForClip.knownActions[0];
                if (clipObject === null)
                  clipObject = prototypeAction._clip;
              }
              if (clipObject === null)
                return null;
              var newAction = new AnimationAction(this, clipObject, optionalRoot);
              this._bindAction(newAction, prototypeAction);
              this._addInactiveAction(newAction, clipUuid, rootUuid);
              return newAction;
            },
            // get an existing action
            existingAction: function(clip, optionalRoot) {
              var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
              if (actionsForClip !== void 0) {
                return actionsForClip.actionByRoot[rootUuid] || null;
              }
              return null;
            },
            // deactivates all previously scheduled actions
            stopAllAction: function() {
              var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
              this._nActiveActions = 0;
              this._nActiveBindings = 0;
              for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
              }
              for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
              }
              return this;
            },
            // advance the time and update apply the animation
            update: function(deltaTime) {
              deltaTime *= this.timeScale;
              var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
              for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                if (action.enabled) {
                  action._update(time, deltaTime, timeDirection, accuIndex);
                }
              }
              var bindings = this._bindings, nBindings = this._nActiveBindings;
              for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
              }
              return this;
            },
            // return this mixer's root target object
            getRoot: function() {
              return this._root;
            },
            // free all resources specific to a particular clip
            uncacheClip: function(clip) {
              var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip !== void 0) {
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                  var action = actionsToRemove[i];
                  this._deactivateAction(action);
                  var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                  action._cacheIndex = null;
                  action._byClipCacheIndex = null;
                  lastInactiveAction._cacheIndex = cacheIndex;
                  actions[cacheIndex] = lastInactiveAction;
                  actions.pop();
                  this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
              }
            },
            // free all resources specific to a particular root target object
            uncacheRoot: function(root) {
              var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
              for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                if (action !== void 0) {
                  this._deactivateAction(action);
                  this._removeInactiveAction(action);
                }
              }
              var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
              if (bindingByName !== void 0) {
                for (var trackName in bindingByName) {
                  var binding = bindingByName[trackName];
                  binding.restoreOriginalState();
                  this._removeInactiveBinding(binding);
                }
              }
            },
            // remove a targeted clip from the cache
            uncacheAction: function(clip, optionalRoot) {
              var action = this.existingAction(clip, optionalRoot);
              if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
              }
            }
          });
          Object.assign(AnimationMixer.prototype, {
            _bindAction: function(action, prototypeAction) {
              var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
              if (bindingsByName === void 0) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
              }
              for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (binding !== void 0) {
                  bindings[i] = binding;
                } else {
                  binding = bindings[i];
                  if (binding !== void 0) {
                    if (binding._cacheIndex === null) {
                      ++binding.referenceCount;
                      this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                  }
                  var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                  binding = new PropertyMixer(
                    PropertyBinding.create(root, trackName, path),
                    track.ValueTypeName,
                    track.getValueSize()
                  );
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                  bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
              }
            },
            _activateAction: function(action) {
              if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                  var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                  this._bindAction(
                    action,
                    actionsForClip && actionsForClip.knownActions[0]
                  );
                  this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                  var binding = bindings[i];
                  if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                  }
                }
                this._lendAction(action);
              }
            },
            _deactivateAction: function(action) {
              if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                  var binding = bindings[i];
                  if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                  }
                }
                this._takeBackAction(action);
              }
            },
            // Memory manager
            _initMemoryManager: function() {
              this._actions = [];
              this._nActiveActions = 0;
              this._actionsByClip = {};
              this._bindings = [];
              this._nActiveBindings = 0;
              this._bindingsByRootAndName = {};
              this._controlInterpolants = [];
              this._nActiveControlInterpolants = 0;
              var scope = this;
              this.stats = {
                actions: {
                  get total() {
                    return scope._actions.length;
                  },
                  get inUse() {
                    return scope._nActiveActions;
                  }
                },
                bindings: {
                  get total() {
                    return scope._bindings.length;
                  },
                  get inUse() {
                    return scope._nActiveBindings;
                  }
                },
                controlInterpolants: {
                  get total() {
                    return scope._controlInterpolants.length;
                  },
                  get inUse() {
                    return scope._nActiveControlInterpolants;
                  }
                }
              };
            },
            // Memory management for AnimationAction objects
            _isActiveAction: function(action) {
              var index = action._cacheIndex;
              return index !== null && index < this._nActiveActions;
            },
            _addInactiveAction: function(action, clipUuid, rootUuid) {
              var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip === void 0) {
                actionsForClip = {
                  knownActions: [action],
                  actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
              } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
              }
              action._cacheIndex = actions.length;
              actions.push(action);
              actionsForClip.actionByRoot[rootUuid] = action;
            },
            _removeInactiveAction: function(action) {
              var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              action._cacheIndex = null;
              var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
              lastKnownAction._byClipCacheIndex = byClipCacheIndex;
              knownActionsForClip[byClipCacheIndex] = lastKnownAction;
              knownActionsForClip.pop();
              action._byClipCacheIndex = null;
              var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
              delete actionByRoot[rootUuid];
              if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
              }
              this._removeInactiveBindingsForAction(action);
            },
            _removeInactiveBindingsForAction: function(action) {
              var bindings = action._propertyBindings;
              for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                  this._removeInactiveBinding(binding);
                }
              }
            },
            _lendAction: function(action) {
              var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
              action._cacheIndex = lastActiveIndex;
              actions[lastActiveIndex] = action;
              firstInactiveAction._cacheIndex = prevIndex;
              actions[prevIndex] = firstInactiveAction;
            },
            _takeBackAction: function(action) {
              var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
              action._cacheIndex = firstInactiveIndex;
              actions[firstInactiveIndex] = action;
              lastActiveAction._cacheIndex = prevIndex;
              actions[prevIndex] = lastActiveAction;
            },
            // Memory management for PropertyMixer objects
            _addInactiveBinding: function(binding, rootUuid, trackName) {
              var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
              if (bindingByName === void 0) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
              }
              bindingByName[trackName] = binding;
              binding._cacheIndex = bindings.length;
              bindings.push(binding);
            },
            _removeInactiveBinding: function(binding) {
              var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
              lastInactiveBinding._cacheIndex = cacheIndex;
              bindings[cacheIndex] = lastInactiveBinding;
              bindings.pop();
              delete bindingByName[trackName];
              remove_empty_map: {
                for (var _ in bindingByName)
                  break remove_empty_map;
                delete bindingsByRoot[rootUuid];
              }
            },
            _lendBinding: function(binding) {
              var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
              binding._cacheIndex = lastActiveIndex;
              bindings[lastActiveIndex] = binding;
              firstInactiveBinding._cacheIndex = prevIndex;
              bindings[prevIndex] = firstInactiveBinding;
            },
            _takeBackBinding: function(binding) {
              var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
              binding._cacheIndex = firstInactiveIndex;
              bindings[firstInactiveIndex] = binding;
              lastActiveBinding._cacheIndex = prevIndex;
              bindings[prevIndex] = lastActiveBinding;
            },
            // Memory management of Interpolants for weight and time scale
            _lendControlInterpolant: function() {
              var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
              if (interpolant === void 0) {
                interpolant = new LinearInterpolant(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer
                );
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
              }
              return interpolant;
            },
            _takeBackControlInterpolant: function(interpolant) {
              var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
              interpolant.__cacheIndex = firstInactiveIndex;
              interpolants[firstInactiveIndex] = interpolant;
              lastActiveInterpolant.__cacheIndex = prevIndex;
              interpolants[prevIndex] = lastActiveInterpolant;
            },
            _controlInterpolantsResultBuffer: new Float32Array(1)
          });
          function Uniform(value) {
            if (typeof value === "string") {
              console.warn("THREE.Uniform: Type parameter is no longer needed.");
              value = arguments[1];
            }
            this.value = value;
          }
          function InstancedBufferGeometry() {
            BufferGeometry.call(this);
            this.type = "InstancedBufferGeometry";
            this.maxInstancedCount = void 0;
          }
          InstancedBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
          InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
          InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
          InstancedBufferGeometry.prototype.addGroup = function(start, count2, materialIndex) {
            this.groups.push({
              start,
              count: count2,
              materialIndex
            });
          };
          InstancedBufferGeometry.prototype.copy = function(source) {
            var index = source.index;
            if (index !== null) {
              this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (var name in attributes) {
              var attribute = attributes[name];
              this.addAttribute(name, attribute.clone());
            }
            var groups = source.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              this.addGroup(group.start, group.count, group.materialIndex);
            }
            return this;
          };
          function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
            this.uuid = _Math.generateUUID();
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized === true;
          }
          InterleavedBufferAttribute.prototype = {
            constructor: InterleavedBufferAttribute,
            isInterleavedBufferAttribute: true,
            get count() {
              return this.data.count;
            },
            get array() {
              return this.data.array;
            },
            setX: function(index, x) {
              this.data.array[index * this.data.stride + this.offset] = x;
              return this;
            },
            setY: function(index, y) {
              this.data.array[index * this.data.stride + this.offset + 1] = y;
              return this;
            },
            setZ: function(index, z) {
              this.data.array[index * this.data.stride + this.offset + 2] = z;
              return this;
            },
            setW: function(index, w) {
              this.data.array[index * this.data.stride + this.offset + 3] = w;
              return this;
            },
            getX: function(index) {
              return this.data.array[index * this.data.stride + this.offset];
            },
            getY: function(index) {
              return this.data.array[index * this.data.stride + this.offset + 1];
            },
            getZ: function(index) {
              return this.data.array[index * this.data.stride + this.offset + 2];
            },
            getW: function(index) {
              return this.data.array[index * this.data.stride + this.offset + 3];
            },
            setXY: function(index, x, y) {
              index = index * this.data.stride + this.offset;
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              return this;
            },
            setXYZ: function(index, x, y, z) {
              index = index * this.data.stride + this.offset;
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              this.data.array[index + 2] = z;
              return this;
            },
            setXYZW: function(index, x, y, z, w) {
              index = index * this.data.stride + this.offset;
              this.data.array[index + 0] = x;
              this.data.array[index + 1] = y;
              this.data.array[index + 2] = z;
              this.data.array[index + 3] = w;
              return this;
            }
          };
          function InterleavedBuffer(array, stride) {
            this.uuid = _Math.generateUUID();
            this.array = array;
            this.stride = stride;
            this.count = array !== void 0 ? array.length / stride : 0;
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
          }
          InterleavedBuffer.prototype = {
            constructor: InterleavedBuffer,
            isInterleavedBuffer: true,
            set needsUpdate(value) {
              if (value === true)
                this.version++;
            },
            setArray: function(array) {
              if (Array.isArray(array)) {
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
              }
              this.count = array !== void 0 ? array.length / this.stride : 0;
              this.array = array;
            },
            setDynamic: function(value) {
              this.dynamic = value;
              return this;
            },
            copy: function(source) {
              this.array = new source.array.constructor(source.array);
              this.count = source.count;
              this.stride = source.stride;
              this.dynamic = source.dynamic;
              return this;
            },
            copyAt: function(index1, attribute, index2) {
              index1 *= this.stride;
              index2 *= attribute.stride;
              for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
              }
              return this;
            },
            set: function(value, offset) {
              if (offset === void 0)
                offset = 0;
              this.array.set(value, offset);
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            }
          };
          function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
            InterleavedBuffer.call(this, array, stride);
            this.meshPerAttribute = meshPerAttribute || 1;
          }
          InstancedInterleavedBuffer.prototype = Object.create(InterleavedBuffer.prototype);
          InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
          InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
          InstancedInterleavedBuffer.prototype.copy = function(source) {
            InterleavedBuffer.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
          };
          function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
            BufferAttribute.call(this, array, itemSize);
            this.meshPerAttribute = meshPerAttribute || 1;
          }
          InstancedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
          InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
          InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
          InstancedBufferAttribute.prototype.copy = function(source) {
            BufferAttribute.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
          };
          function Raycaster(origin, direction, near, far) {
            this.ray = new Ray(origin, direction);
            this.near = near || 0;
            this.far = far || Infinity;
            this.params = {
              Mesh: {},
              Line: {},
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {}
            };
            Object.defineProperties(this.params, {
              PointCloud: {
                get: function() {
                  console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                  return this.Points;
                }
              }
            });
          }
          function ascSort(a, b) {
            return a.distance - b.distance;
          }
          function intersectObject(object, raycaster, intersects, recursive) {
            if (object.visible === false)
              return;
            object.raycast(raycaster, intersects);
            if (recursive === true) {
              var children = object.children;
              for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
              }
            }
          }
          Raycaster.prototype = {
            constructor: Raycaster,
            linePrecision: 1,
            set: function(origin, direction) {
              this.ray.set(origin, direction);
            },
            setFromCamera: function(coords, camera) {
              if (camera && camera.isPerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
              } else if (camera && camera.isOrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
              } else {
                console.error("THREE.Raycaster: Unsupported camera type.");
              }
            },
            intersectObject: function(object, recursive) {
              var intersects = [];
              intersectObject(object, this, intersects, recursive);
              intersects.sort(ascSort);
              return intersects;
            },
            intersectObjects: function(objects, recursive) {
              var intersects = [];
              if (Array.isArray(objects) === false) {
                console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
                return intersects;
              }
              for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
              }
              intersects.sort(ascSort);
              return intersects;
            }
          };
          function Clock(autoStart) {
            this.autoStart = autoStart !== void 0 ? autoStart : true;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
          }
          Clock.prototype = {
            constructor: Clock,
            start: function() {
              this.startTime = (performance || Date).now();
              this.oldTime = this.startTime;
              this.elapsedTime = 0;
              this.running = true;
            },
            stop: function() {
              this.getElapsedTime();
              this.running = false;
            },
            getElapsedTime: function() {
              this.getDelta();
              return this.elapsedTime;
            },
            getDelta: function() {
              var diff = 0;
              if (this.autoStart && !this.running) {
                this.start();
              }
              if (this.running) {
                var newTime = (performance || Date).now();
                diff = (newTime - this.oldTime) / 1e3;
                this.oldTime = newTime;
                this.elapsedTime += diff;
              }
              return diff;
            }
          };
          function Spline(points) {
            this.points = points;
            var c = [], v3 = { x: 0, y: 0, z: 0 }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
            this.initFromArray = function(a) {
              this.points = [];
              for (var i = 0; i < a.length; i++) {
                this.points[i] = { x: a[i][0], y: a[i][1], z: a[i][2] };
              }
            };
            this.getPoint = function(k) {
              point = (this.points.length - 1) * k;
              intPoint = Math.floor(point);
              weight = point - intPoint;
              c[0] = intPoint === 0 ? intPoint : intPoint - 1;
              c[1] = intPoint;
              c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
              c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
              pa = this.points[c[0]];
              pb = this.points[c[1]];
              pc = this.points[c[2]];
              pd = this.points[c[3]];
              w2 = weight * weight;
              w3 = weight * w2;
              v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
              v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
              v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
              return v3;
            };
            this.getControlPointsArray = function() {
              var i, p, l = this.points.length, coords = [];
              for (i = 0; i < l; i++) {
                p = this.points[i];
                coords[i] = [p.x, p.y, p.z];
              }
              return coords;
            };
            this.getLength = function(nSubDivisions) {
              var i, index, nSamples, position, point2 = 0, intPoint2 = 0, oldIntPoint = 0, oldPosition = new Vector3(), tmpVec = new Vector3(), chunkLengths = [], totalLength = 0;
              chunkLengths[0] = 0;
              if (!nSubDivisions)
                nSubDivisions = 100;
              nSamples = this.points.length * nSubDivisions;
              oldPosition.copy(this.points[0]);
              for (i = 1; i < nSamples; i++) {
                index = i / nSamples;
                position = this.getPoint(index);
                tmpVec.copy(position);
                totalLength += tmpVec.distanceTo(oldPosition);
                oldPosition.copy(position);
                point2 = (this.points.length - 1) * index;
                intPoint2 = Math.floor(point2);
                if (intPoint2 !== oldIntPoint) {
                  chunkLengths[intPoint2] = totalLength;
                  oldIntPoint = intPoint2;
                }
              }
              chunkLengths[chunkLengths.length] = totalLength;
              return { chunks: chunkLengths, total: totalLength };
            };
            this.reparametrizeByArcLength = function(samplingCoef) {
              var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new Vector3(), sl = this.getLength();
              newpoints.push(tmpVec.copy(this.points[0]).clone());
              for (i = 1; i < this.points.length; i++) {
                realDistance = sl.chunks[i] - sl.chunks[i - 1];
                sampling = Math.ceil(samplingCoef * realDistance / sl.total);
                indexCurrent = (i - 1) / (this.points.length - 1);
                indexNext = i / (this.points.length - 1);
                for (j = 1; j < sampling - 1; j++) {
                  index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
                  position = this.getPoint(index);
                  newpoints.push(tmpVec.copy(position).clone());
                }
                newpoints.push(tmpVec.copy(this.points[i]).clone());
              }
              this.points = newpoints;
            };
            function interpolate(p0, p1, p2, p3, t, t2, t3) {
              var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
              return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
          }
          function Spherical(radius, phi, theta) {
            this.radius = radius !== void 0 ? radius : 1;
            this.phi = phi !== void 0 ? phi : 0;
            this.theta = theta !== void 0 ? theta : 0;
            return this;
          }
          Spherical.prototype = {
            constructor: Spherical,
            set: function(radius, phi, theta) {
              this.radius = radius;
              this.phi = phi;
              this.theta = theta;
              return this;
            },
            clone: function() {
              return new this.constructor().copy(this);
            },
            copy: function(other) {
              this.radius = other.radius;
              this.phi = other.phi;
              this.theta = other.theta;
              return this;
            },
            // restrict phi to be betwee EPS and PI-EPS
            makeSafe: function() {
              var EPS = 1e-6;
              this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
              return this;
            },
            setFromVector3: function(vec3) {
              this.radius = vec3.length();
              if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
              } else {
                this.theta = Math.atan2(vec3.x, vec3.z);
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1));
              }
              return this;
            }
          };
          function MorphBlendMesh(geometry, material) {
            Mesh.call(this, geometry, material);
            this.animationsMap = {};
            this.animationsList = [];
            var numFrames = this.geometry.morphTargets.length;
            var name = "__default";
            var startFrame = 0;
            var endFrame = numFrames - 1;
            var fps = numFrames / 1;
            this.createAnimation(name, startFrame, endFrame, fps);
            this.setAnimationWeight(name, 1);
          }
          MorphBlendMesh.prototype = Object.create(Mesh.prototype);
          MorphBlendMesh.prototype.constructor = MorphBlendMesh;
          MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
            var animation = {
              start,
              end,
              length: end - start + 1,
              fps,
              duration: (end - start) / fps,
              lastFrame: 0,
              currentFrame: 0,
              active: false,
              time: 0,
              direction: 1,
              weight: 1,
              directionBackwards: false,
              mirroredLoop: false
            };
            this.animationsMap[name] = animation;
            this.animationsList.push(animation);
          };
          MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
            var pattern = /([a-z]+)_?(\d+)/i;
            var firstAnimation, frameRanges = {};
            var geometry = this.geometry;
            for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
              var morph = geometry.morphTargets[i];
              var chunks = morph.name.match(pattern);
              if (chunks && chunks.length > 1) {
                var name = chunks[1];
                if (!frameRanges[name])
                  frameRanges[name] = { start: Infinity, end: -Infinity };
                var range = frameRanges[name];
                if (i < range.start)
                  range.start = i;
                if (i > range.end)
                  range.end = i;
                if (!firstAnimation)
                  firstAnimation = name;
              }
            }
            for (var name in frameRanges) {
              var range = frameRanges[name];
              this.createAnimation(name, range.start, range.end, fps);
            }
            this.firstAnimation = firstAnimation;
          };
          MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.direction = 1;
              animation.directionBackwards = false;
            }
          };
          MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.direction = -1;
              animation.directionBackwards = true;
            }
          };
          MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.fps = fps;
              animation.duration = (animation.end - animation.start) / animation.fps;
            }
          };
          MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.duration = duration;
              animation.fps = (animation.end - animation.start) / animation.duration;
            }
          };
          MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.weight = weight;
            }
          };
          MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.time = time;
            }
          };
          MorphBlendMesh.prototype.getAnimationTime = function(name) {
            var time = 0;
            var animation = this.animationsMap[name];
            if (animation) {
              time = animation.time;
            }
            return time;
          };
          MorphBlendMesh.prototype.getAnimationDuration = function(name) {
            var duration = -1;
            var animation = this.animationsMap[name];
            if (animation) {
              duration = animation.duration;
            }
            return duration;
          };
          MorphBlendMesh.prototype.playAnimation = function(name) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.time = 0;
              animation.active = true;
            } else {
              console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
            }
          };
          MorphBlendMesh.prototype.stopAnimation = function(name) {
            var animation = this.animationsMap[name];
            if (animation) {
              animation.active = false;
            }
          };
          MorphBlendMesh.prototype.update = function(delta) {
            for (var i = 0, il = this.animationsList.length; i < il; i++) {
              var animation = this.animationsList[i];
              if (!animation.active)
                continue;
              var frameTime = animation.duration / animation.length;
              animation.time += animation.direction * delta;
              if (animation.mirroredLoop) {
                if (animation.time > animation.duration || animation.time < 0) {
                  animation.direction *= -1;
                  if (animation.time > animation.duration) {
                    animation.time = animation.duration;
                    animation.directionBackwards = true;
                  }
                  if (animation.time < 0) {
                    animation.time = 0;
                    animation.directionBackwards = false;
                  }
                }
              } else {
                animation.time = animation.time % animation.duration;
                if (animation.time < 0)
                  animation.time += animation.duration;
              }
              var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
              var weight = animation.weight;
              if (keyframe !== animation.currentFrame) {
                this.morphTargetInfluences[animation.lastFrame] = 0;
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
                this.morphTargetInfluences[keyframe] = 0;
                animation.lastFrame = animation.currentFrame;
                animation.currentFrame = keyframe;
              }
              var mix = animation.time % frameTime / frameTime;
              if (animation.directionBackwards)
                mix = 1 - mix;
              if (animation.currentFrame !== animation.lastFrame) {
                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
              } else {
                this.morphTargetInfluences[animation.currentFrame] = weight;
              }
            }
          };
          function ImmediateRenderObject(material) {
            Object3D.call(this);
            this.material = material;
            this.render = function(renderCallback) {
            };
          }
          ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
          ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
          ImmediateRenderObject.prototype.isImmediateRenderObject = true;
          function VertexNormalsHelper(object, size, hex, linewidth) {
            this.object = object;
            this.size = size !== void 0 ? size : 1;
            var color = hex !== void 0 ? hex : 16711680;
            var width = linewidth !== void 0 ? linewidth : 1;
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
              nNormals = objGeometry.faces.length * 3;
            } else if (objGeometry && objGeometry.isBufferGeometry) {
              nNormals = objGeometry.attributes.normal.count;
            }
            var geometry = new BufferGeometry();
            var positions = new Float32Attribute(nNormals * 2 * 3, 3);
            geometry.addAttribute("position", positions);
            LineSegments.call(this, geometry, new LineBasicMaterial({ color, linewidth: width }));
            this.matrixAutoUpdate = false;
            this.update();
          }
          VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
          VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
          VertexNormalsHelper.prototype.update = function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            var normalMatrix = new Matrix3();
            return function update() {
              var keys = ["a", "b", "c"];
              this.object.updateMatrixWorld(true);
              normalMatrix.getNormalMatrix(this.object.matrixWorld);
              var matrixWorld = this.object.matrixWorld;
              var position = this.geometry.attributes.position;
              var objGeometry = this.object.geometry;
              if (objGeometry && objGeometry.isGeometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                  var face = faces[i];
                  for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    var vertex = vertices[face[keys[j]]];
                    var normal = face.vertexNormals[j];
                    v1.copy(vertex).applyMatrix4(matrixWorld);
                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                  }
                }
              } else if (objGeometry && objGeometry.isBufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                for (var j = 0, jl = objPos.count; j < jl; j++) {
                  v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                  v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                  v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                  position.setXYZ(idx, v1.x, v1.y, v1.z);
                  idx = idx + 1;
                  position.setXYZ(idx, v2.x, v2.y, v2.z);
                  idx = idx + 1;
                }
              }
              position.needsUpdate = true;
              return this;
            };
          }();
          function SpotLightHelper(light) {
            Object3D.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            var geometry = new BufferGeometry();
            var positions = [
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              1,
              0,
              0,
              0,
              -1,
              0,
              1,
              0,
              0,
              0,
              0,
              1,
              1,
              0,
              0,
              0,
              0,
              -1,
              1
            ];
            for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
              var p1 = i / l * Math.PI * 2;
              var p2 = j / l * Math.PI * 2;
              positions.push(
                Math.cos(p1),
                Math.sin(p1),
                1,
                Math.cos(p2),
                Math.sin(p2),
                1
              );
            }
            geometry.addAttribute("position", new Float32Attribute(positions, 3));
            var material = new LineBasicMaterial({ fog: false });
            this.cone = new LineSegments(geometry, material);
            this.add(this.cone);
            this.update();
          }
          SpotLightHelper.prototype = Object.create(Object3D.prototype);
          SpotLightHelper.prototype.constructor = SpotLightHelper;
          SpotLightHelper.prototype.dispose = function() {
            this.cone.geometry.dispose();
            this.cone.material.dispose();
          };
          SpotLightHelper.prototype.update = function() {
            var vector = new Vector3();
            var vector2 = new Vector3();
            return function update() {
              var coneLength = this.light.distance ? this.light.distance : 1e3;
              var coneWidth = coneLength * Math.tan(this.light.angle);
              this.cone.scale.set(coneWidth, coneWidth, coneLength);
              vector.setFromMatrixPosition(this.light.matrixWorld);
              vector2.setFromMatrixPosition(this.light.target.matrixWorld);
              this.cone.lookAt(vector2.sub(vector));
              this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            };
          }();
          function SkeletonHelper(object) {
            this.bones = this.getBoneList(object);
            var geometry = new Geometry();
            for (var i = 0; i < this.bones.length; i++) {
              var bone = this.bones[i];
              if (bone.parent && bone.parent.isBone) {
                geometry.vertices.push(new Vector3());
                geometry.vertices.push(new Vector3());
                geometry.colors.push(new Color(0, 0, 1));
                geometry.colors.push(new Color(0, 1, 0));
              }
            }
            geometry.dynamic = true;
            var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });
            LineSegments.call(this, geometry, material);
            this.root = object;
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
            this.update();
          }
          SkeletonHelper.prototype = Object.create(LineSegments.prototype);
          SkeletonHelper.prototype.constructor = SkeletonHelper;
          SkeletonHelper.prototype.getBoneList = function(object) {
            var boneList = [];
            if (object && object.isBone) {
              boneList.push(object);
            }
            for (var i = 0; i < object.children.length; i++) {
              boneList.push.apply(boneList, this.getBoneList(object.children[i]));
            }
            return boneList;
          };
          SkeletonHelper.prototype.update = function() {
            var geometry = this.geometry;
            var matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld);
            var boneMatrix = new Matrix4();
            var j = 0;
            for (var i = 0; i < this.bones.length; i++) {
              var bone = this.bones[i];
              if (bone.parent && bone.parent.isBone) {
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                geometry.vertices[j].setFromMatrixPosition(boneMatrix);
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
                j += 2;
              }
            }
            geometry.verticesNeedUpdate = true;
            geometry.computeBoundingSphere();
          };
          function PointLightHelper(light, sphereSize) {
            this.light = light;
            this.light.updateMatrixWorld();
            var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
            var material = new MeshBasicMaterial({ wireframe: true, fog: false });
            material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            Mesh.call(this, geometry, material);
            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = false;
          }
          PointLightHelper.prototype = Object.create(Mesh.prototype);
          PointLightHelper.prototype.constructor = PointLightHelper;
          PointLightHelper.prototype.dispose = function() {
            this.geometry.dispose();
            this.material.dispose();
          };
          PointLightHelper.prototype.update = function() {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
          };
          function HemisphereLightHelper(light, sphereSize) {
            Object3D.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.colors = [new Color(), new Color()];
            var geometry = new SphereGeometry(sphereSize, 4, 2);
            geometry.rotateX(-Math.PI / 2);
            for (var i = 0, il = 8; i < il; i++) {
              geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
            }
            var material = new MeshBasicMaterial({ vertexColors: FaceColors, wireframe: true });
            this.lightSphere = new Mesh(geometry, material);
            this.add(this.lightSphere);
            this.update();
          }
          HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
          HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
          HemisphereLightHelper.prototype.dispose = function() {
            this.lightSphere.geometry.dispose();
            this.lightSphere.material.dispose();
          };
          HemisphereLightHelper.prototype.update = function() {
            var vector = new Vector3();
            return function update() {
              this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
              this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
              this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
              this.lightSphere.geometry.colorsNeedUpdate = true;
            };
          }();
          function GridHelper(size, divisions, color1, color2) {
            divisions = divisions || 1;
            color1 = new Color(color1 !== void 0 ? color1 : 4473924);
            color2 = new Color(color2 !== void 0 ? color2 : 8947848);
            var center = divisions / 2;
            var step = size * 2 / divisions;
            var vertices = [], colors = [];
            for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
              vertices.push(-size, 0, k, size, 0, k);
              vertices.push(k, 0, -size, k, 0, size);
              var color = i === center ? color1 : color2;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
              color.toArray(colors, j);
              j += 3;
            }
            var geometry = new BufferGeometry();
            geometry.addAttribute("position", new Float32Attribute(vertices, 3));
            geometry.addAttribute("color", new Float32Attribute(colors, 3));
            var material = new LineBasicMaterial({ vertexColors: VertexColors });
            LineSegments.call(this, geometry, material);
          }
          GridHelper.prototype = Object.create(LineSegments.prototype);
          GridHelper.prototype.constructor = GridHelper;
          GridHelper.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
          };
          function FaceNormalsHelper(object, size, hex, linewidth) {
            this.object = object;
            this.size = size !== void 0 ? size : 1;
            var color = hex !== void 0 ? hex : 16776960;
            var width = linewidth !== void 0 ? linewidth : 1;
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
              nNormals = objGeometry.faces.length;
            } else {
              console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            }
            var geometry = new BufferGeometry();
            var positions = new Float32Attribute(nNormals * 2 * 3, 3);
            geometry.addAttribute("position", positions);
            LineSegments.call(this, geometry, new LineBasicMaterial({ color, linewidth: width }));
            this.matrixAutoUpdate = false;
            this.update();
          }
          FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
          FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
          FaceNormalsHelper.prototype.update = function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            var normalMatrix = new Matrix3();
            return function update() {
              this.object.updateMatrixWorld(true);
              normalMatrix.getNormalMatrix(this.object.matrixWorld);
              var matrixWorld = this.object.matrixWorld;
              var position = this.geometry.attributes.position;
              var objGeometry = this.object.geometry;
              var vertices = objGeometry.vertices;
              var faces = objGeometry.faces;
              var idx = 0;
              for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
              }
              position.needsUpdate = true;
              return this;
            };
          }();
          function DirectionalLightHelper(light, size) {
            Object3D.call(this);
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            if (size === void 0)
              size = 1;
            var geometry = new BufferGeometry();
            geometry.addAttribute("position", new Float32Attribute([
              -size,
              size,
              0,
              size,
              size,
              0,
              size,
              -size,
              0,
              -size,
              -size,
              0,
              -size,
              size,
              0
            ], 3));
            var material = new LineBasicMaterial({ fog: false });
            this.add(new Line(geometry, material));
            geometry = new BufferGeometry();
            geometry.addAttribute("position", new Float32Attribute([0, 0, 0, 0, 0, 1], 3));
            this.add(new Line(geometry, material));
            this.update();
          }
          DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
          DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
          DirectionalLightHelper.prototype.dispose = function() {
            var lightPlane = this.children[0];
            var targetLine = this.children[1];
            lightPlane.geometry.dispose();
            lightPlane.material.dispose();
            targetLine.geometry.dispose();
            targetLine.material.dispose();
          };
          DirectionalLightHelper.prototype.update = function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            var v3 = new Vector3();
            return function update() {
              v1.setFromMatrixPosition(this.light.matrixWorld);
              v2.setFromMatrixPosition(this.light.target.matrixWorld);
              v3.subVectors(v2, v1);
              var lightPlane = this.children[0];
              var targetLine = this.children[1];
              lightPlane.lookAt(v3);
              lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
              targetLine.lookAt(v3);
              targetLine.scale.z = v3.length();
            };
          }();
          function CameraHelper(camera) {
            var geometry = new Geometry();
            var material = new LineBasicMaterial({ color: 16777215, vertexColors: FaceColors });
            var pointMap = {};
            var hexFrustum = 16755200;
            var hexCone = 16711680;
            var hexUp = 43775;
            var hexTarget = 16777215;
            var hexCross = 3355443;
            addLine("n1", "n2", hexFrustum);
            addLine("n2", "n4", hexFrustum);
            addLine("n4", "n3", hexFrustum);
            addLine("n3", "n1", hexFrustum);
            addLine("f1", "f2", hexFrustum);
            addLine("f2", "f4", hexFrustum);
            addLine("f4", "f3", hexFrustum);
            addLine("f3", "f1", hexFrustum);
            addLine("n1", "f1", hexFrustum);
            addLine("n2", "f2", hexFrustum);
            addLine("n3", "f3", hexFrustum);
            addLine("n4", "f4", hexFrustum);
            addLine("p", "n1", hexCone);
            addLine("p", "n2", hexCone);
            addLine("p", "n3", hexCone);
            addLine("p", "n4", hexCone);
            addLine("u1", "u2", hexUp);
            addLine("u2", "u3", hexUp);
            addLine("u3", "u1", hexUp);
            addLine("c", "t", hexTarget);
            addLine("p", "c", hexCross);
            addLine("cn1", "cn2", hexCross);
            addLine("cn3", "cn4", hexCross);
            addLine("cf1", "cf2", hexCross);
            addLine("cf3", "cf4", hexCross);
            function addLine(a, b, hex) {
              addPoint(a, hex);
              addPoint(b, hex);
            }
            function addPoint(id, hex) {
              geometry.vertices.push(new Vector3());
              geometry.colors.push(new Color(hex));
              if (pointMap[id] === void 0) {
                pointMap[id] = [];
              }
              pointMap[id].push(geometry.vertices.length - 1);
            }
            LineSegments.call(this, geometry, material);
            this.camera = camera;
            if (this.camera.updateProjectionMatrix)
              this.camera.updateProjectionMatrix();
            this.matrix = camera.matrixWorld;
            this.matrixAutoUpdate = false;
            this.pointMap = pointMap;
            this.update();
          }
          CameraHelper.prototype = Object.create(LineSegments.prototype);
          CameraHelper.prototype.constructor = CameraHelper;
          CameraHelper.prototype.update = function() {
            var geometry, pointMap;
            var vector = new Vector3();
            var camera = new Camera();
            function setPoint(point, x, y, z) {
              vector.set(x, y, z).unproject(camera);
              var points = pointMap[point];
              if (points !== void 0) {
                for (var i = 0, il = points.length; i < il; i++) {
                  geometry.vertices[points[i]].copy(vector);
                }
              }
            }
            return function update() {
              geometry = this.geometry;
              pointMap = this.pointMap;
              var w = 1, h = 1;
              camera.projectionMatrix.copy(this.camera.projectionMatrix);
              setPoint("c", 0, 0, -1);
              setPoint("t", 0, 0, 1);
              setPoint("n1", -w, -h, -1);
              setPoint("n2", w, -h, -1);
              setPoint("n3", -w, h, -1);
              setPoint("n4", w, h, -1);
              setPoint("f1", -w, -h, 1);
              setPoint("f2", w, -h, 1);
              setPoint("f3", -w, h, 1);
              setPoint("f4", w, h, 1);
              setPoint("u1", w * 0.7, h * 1.1, -1);
              setPoint("u2", -w * 0.7, h * 1.1, -1);
              setPoint("u3", 0, h * 2, -1);
              setPoint("cf1", -w, 0, 1);
              setPoint("cf2", w, 0, 1);
              setPoint("cf3", 0, -h, 1);
              setPoint("cf4", 0, h, 1);
              setPoint("cn1", -w, 0, -1);
              setPoint("cn2", w, 0, -1);
              setPoint("cn3", 0, -h, -1);
              setPoint("cn4", 0, h, -1);
              geometry.verticesNeedUpdate = true;
            };
          }();
          function BoundingBoxHelper(object, hex) {
            var color = hex !== void 0 ? hex : 8947848;
            this.object = object;
            this.box = new Box3();
            Mesh.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({ color, wireframe: true }));
          }
          BoundingBoxHelper.prototype = Object.create(Mesh.prototype);
          BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;
          BoundingBoxHelper.prototype.update = function() {
            this.box.setFromObject(this.object);
            this.box.getSize(this.scale);
            this.box.getCenter(this.position);
          };
          function BoxHelper(object, color) {
            if (color === void 0)
              color = 16776960;
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = new Float32Array(8 * 3);
            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.addAttribute("position", new BufferAttribute(positions, 3));
            LineSegments.call(this, geometry, new LineBasicMaterial({ color }));
            if (object !== void 0) {
              this.update(object);
            }
          }
          BoxHelper.prototype = Object.create(LineSegments.prototype);
          BoxHelper.prototype.constructor = BoxHelper;
          BoxHelper.prototype.update = function() {
            var box = new Box3();
            return function update(object) {
              if (object && object.isBox3) {
                box.copy(object);
              } else {
                box.setFromObject(object);
              }
              if (box.isEmpty())
                return;
              var min = box.min;
              var max = box.max;
              var position = this.geometry.attributes.position;
              var array = position.array;
              array[0] = max.x;
              array[1] = max.y;
              array[2] = max.z;
              array[3] = min.x;
              array[4] = max.y;
              array[5] = max.z;
              array[6] = min.x;
              array[7] = min.y;
              array[8] = max.z;
              array[9] = max.x;
              array[10] = min.y;
              array[11] = max.z;
              array[12] = max.x;
              array[13] = max.y;
              array[14] = min.z;
              array[15] = min.x;
              array[16] = max.y;
              array[17] = min.z;
              array[18] = min.x;
              array[19] = min.y;
              array[20] = min.z;
              array[21] = max.x;
              array[22] = min.y;
              array[23] = min.z;
              position.needsUpdate = true;
              this.geometry.computeBoundingSphere();
            };
          }();
          var lineGeometry = new BufferGeometry();
          lineGeometry.addAttribute("position", new Float32Attribute([0, 0, 0, 0, 1, 0], 3));
          var coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
          coneGeometry.translate(0, -0.5, 0);
          function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
            Object3D.call(this);
            if (color === void 0)
              color = 16776960;
            if (length === void 0)
              length = 1;
            if (headLength === void 0)
              headLength = 0.2 * length;
            if (headWidth === void 0)
              headWidth = 0.2 * headLength;
            this.position.copy(origin);
            this.line = new Line(lineGeometry, new LineBasicMaterial({ color }));
            this.line.matrixAutoUpdate = false;
            this.add(this.line);
            this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color }));
            this.cone.matrixAutoUpdate = false;
            this.add(this.cone);
            this.setDirection(dir);
            this.setLength(length, headLength, headWidth);
          }
          ArrowHelper.prototype = Object.create(Object3D.prototype);
          ArrowHelper.prototype.constructor = ArrowHelper;
          ArrowHelper.prototype.setDirection = function() {
            var axis = new Vector3();
            var radians;
            return function setDirection(dir) {
              if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
              } else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
              } else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
              }
            };
          }();
          ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
            if (headLength === void 0)
              headLength = 0.2 * length;
            if (headWidth === void 0)
              headWidth = 0.2 * headLength;
            this.line.scale.set(1, Math.max(0, length - headLength), 1);
            this.line.updateMatrix();
            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();
          };
          ArrowHelper.prototype.setColor = function(color) {
            this.line.material.color.copy(color);
            this.cone.material.color.copy(color);
          };
          function AxisHelper(size) {
            size = size || 1;
            var vertices = new Float32Array([
              0,
              0,
              0,
              size,
              0,
              0,
              0,
              0,
              0,
              0,
              size,
              0,
              0,
              0,
              0,
              0,
              0,
              size
            ]);
            var colors = new Float32Array([
              1,
              0,
              0,
              1,
              0.6,
              0,
              0,
              1,
              0,
              0.6,
              1,
              0,
              0,
              0,
              1,
              0,
              0.6,
              1
            ]);
            var geometry = new BufferGeometry();
            geometry.addAttribute("position", new BufferAttribute(vertices, 3));
            geometry.addAttribute("color", new BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({ vertexColors: VertexColors });
            LineSegments.call(this, geometry, material);
          }
          AxisHelper.prototype = Object.create(LineSegments.prototype);
          AxisHelper.prototype.constructor = AxisHelper;
          var CatmullRomCurve3 = function() {
            var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
            function CubicPoly() {
            }
            CubicPoly.prototype.init = function(x0, x1, t0, t1) {
              this.c0 = x0;
              this.c1 = t0;
              this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
              this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
            };
            CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
              var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
              var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
              t1 *= dt1;
              t2 *= dt1;
              this.init(x1, x2, t1, t2);
            };
            CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
              this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            };
            CubicPoly.prototype.calc = function(t) {
              var t2 = t * t;
              var t3 = t2 * t;
              return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
            };
            return Curve.create(
              function(p) {
                this.points = p || [];
                this.closed = false;
              },
              function(t) {
                var points = this.points, point, intPoint, weight, l;
                l = points.length;
                if (l < 2)
                  console.log("duh, you need at least 2 points");
                point = (l - (this.closed ? 0 : 1)) * t;
                intPoint = Math.floor(point);
                weight = point - intPoint;
                if (this.closed) {
                  intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
                } else if (weight === 0 && intPoint === l - 1) {
                  intPoint = l - 2;
                  weight = 1;
                }
                var p0, p1, p2, p3;
                if (this.closed || intPoint > 0) {
                  p0 = points[(intPoint - 1) % l];
                } else {
                  tmp.subVectors(points[0], points[1]).add(points[0]);
                  p0 = tmp;
                }
                p1 = points[intPoint % l];
                p2 = points[(intPoint + 1) % l];
                if (this.closed || intPoint + 2 < l) {
                  p3 = points[(intPoint + 2) % l];
                } else {
                  tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                  p3 = tmp;
                }
                if (this.type === void 0 || this.type === "centripetal" || this.type === "chordal") {
                  var pow = this.type === "chordal" ? 0.5 : 0.25;
                  var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                  var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                  var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                  if (dt1 < 1e-4)
                    dt1 = 1;
                  if (dt0 < 1e-4)
                    dt0 = dt1;
                  if (dt2 < 1e-4)
                    dt2 = dt1;
                  px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                  py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                  pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
                } else if (this.type === "catmullrom") {
                  var tension = this.tension !== void 0 ? this.tension : 0.5;
                  px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
                  py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
                  pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
                }
                var v = new Vector3(
                  px.calc(weight),
                  py.calc(weight),
                  pz.calc(weight)
                );
                return v;
              }
            );
          }();
          function ClosedSplineCurve3(points) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.");
            CatmullRomCurve3.call(this, points);
            this.type = "catmullrom";
            this.closed = true;
          }
          ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
          var SplineCurve3 = Curve.create(
            function(points) {
              console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3");
              this.points = points === void 0 ? [] : points;
            },
            function(t) {
              var points = this.points;
              var point = (points.length - 1) * t;
              var intPoint = Math.floor(point);
              var weight = point - intPoint;
              var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
              var point1 = points[intPoint];
              var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
              var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
              var interpolate = CurveUtils.interpolate;
              return new Vector3(
                interpolate(point0.x, point1.x, point2.x, point3.x, weight),
                interpolate(point0.y, point1.y, point2.y, point3.y, weight),
                interpolate(point0.z, point1.z, point2.z, point3.z, weight)
              );
            }
          );
          var CubicBezierCurve3 = Curve.create(
            function(v0, v1, v2, v3) {
              this.v0 = v0;
              this.v1 = v1;
              this.v2 = v2;
              this.v3 = v3;
            },
            function(t) {
              var b3 = ShapeUtils.b3;
              return new Vector3(
                b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
                b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y),
                b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z)
              );
            }
          );
          var QuadraticBezierCurve3 = Curve.create(
            function(v0, v1, v2) {
              this.v0 = v0;
              this.v1 = v1;
              this.v2 = v2;
            },
            function(t) {
              var b2 = ShapeUtils.b2;
              return new Vector3(
                b2(t, this.v0.x, this.v1.x, this.v2.x),
                b2(t, this.v0.y, this.v1.y, this.v2.y),
                b2(t, this.v0.z, this.v1.z, this.v2.z)
              );
            }
          );
          var LineCurve3 = Curve.create(
            function(v1, v2) {
              this.v1 = v1;
              this.v2 = v2;
            },
            function(t) {
              if (t === 1) {
                return this.v2.clone();
              }
              var vector = new Vector3();
              vector.subVectors(this.v2, this.v1);
              vector.multiplyScalar(t);
              vector.add(this.v1);
              return vector;
            }
          );
          function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          }
          ArcCurve.prototype = Object.create(EllipseCurve.prototype);
          ArcCurve.prototype.constructor = ArcCurve;
          var SceneUtils = {
            createMultiMaterialObject: function(geometry, materials) {
              var group = new Group();
              for (var i = 0, l = materials.length; i < l; i++) {
                group.add(new Mesh(geometry, materials[i]));
              }
              return group;
            },
            detach: function(child, parent, scene) {
              child.applyMatrix(parent.matrixWorld);
              parent.remove(child);
              scene.add(child);
            },
            attach: function(child, scene, parent) {
              var matrixWorldInverse = new Matrix4();
              matrixWorldInverse.getInverse(parent.matrixWorld);
              child.applyMatrix(matrixWorldInverse);
              scene.remove(child);
              parent.add(child);
            }
          };
          function Face4(a, b, c, d, normal, color, materialIndex) {
            console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
            return new Face3(a, b, c, normal, color, materialIndex);
          }
          var LineStrip = 0;
          var LinePieces = 1;
          function PointCloud(geometry, material) {
            console.warn("THREE.PointCloud has been renamed to THREE.Points.");
            return new Points(geometry, material);
          }
          function ParticleSystem(geometry, material) {
            console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
            return new Points(geometry, material);
          }
          function PointCloudMaterial(parameters) {
            console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
            return new PointsMaterial(parameters);
          }
          function ParticleBasicMaterial(parameters) {
            console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
            return new PointsMaterial(parameters);
          }
          function ParticleSystemMaterial(parameters) {
            console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
            return new PointsMaterial(parameters);
          }
          function Vertex(x, y, z) {
            console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
            return new Vector3(x, y, z);
          }
          function EdgesHelper(object, hex) {
            console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
            return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
          }
          function WireframeHelper(object, hex) {
            console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
            return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
          }
          Object.assign(Box2.prototype, {
            center: function(optionalTarget) {
              console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
              return this.getCenter(optionalTarget);
            },
            empty: function() {
              console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
              return this.isEmpty();
            },
            isIntersectionBox: function(box) {
              console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
              return this.intersectsBox(box);
            },
            size: function(optionalTarget) {
              console.warn("THREE.Box2: .size() has been renamed to .getSize().");
              return this.getSize(optionalTarget);
            }
          });
          Object.assign(Box3.prototype, {
            center: function(optionalTarget) {
              console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
              return this.getCenter(optionalTarget);
            },
            empty: function() {
              console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
              return this.isEmpty();
            },
            isIntersectionBox: function(box) {
              console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
              return this.intersectsBox(box);
            },
            isIntersectionSphere: function(sphere) {
              console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
              return this.intersectsSphere(sphere);
            },
            size: function(optionalTarget) {
              console.warn("THREE.Box3: .size() has been renamed to .getSize().");
              return this.getSize(optionalTarget);
            }
          });
          Object.assign(Line3.prototype, {
            center: function(optionalTarget) {
              console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
              return this.getCenter(optionalTarget);
            }
          });
          Object.assign(Matrix3.prototype, {
            multiplyVector3: function(vector) {
              console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
              return vector.applyMatrix3(this);
            },
            multiplyVector3Array: function(a) {
              console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
              return this.applyToVector3Array(a);
            }
          });
          Object.assign(Matrix4.prototype, {
            extractPosition: function(m) {
              console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
              return this.copyPosition(m);
            },
            setRotationFromQuaternion: function(q) {
              console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
              return this.makeRotationFromQuaternion(q);
            },
            multiplyVector3: function(vector) {
              console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
              return vector.applyProjection(this);
            },
            multiplyVector4: function(vector) {
              console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
              return vector.applyMatrix4(this);
            },
            multiplyVector3Array: function(a) {
              console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
              return this.applyToVector3Array(a);
            },
            rotateAxis: function(v) {
              console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
              v.transformDirection(this);
            },
            crossVector: function(vector) {
              console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
              return vector.applyMatrix4(this);
            },
            translate: function(v) {
              console.error("THREE.Matrix4: .translate() has been removed.");
            },
            rotateX: function(angle) {
              console.error("THREE.Matrix4: .rotateX() has been removed.");
            },
            rotateY: function(angle) {
              console.error("THREE.Matrix4: .rotateY() has been removed.");
            },
            rotateZ: function(angle) {
              console.error("THREE.Matrix4: .rotateZ() has been removed.");
            },
            rotateByAxis: function(axis, angle) {
              console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
            }
          });
          Object.assign(Plane.prototype, {
            isIntersectionLine: function(line) {
              console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
              return this.intersectsLine(line);
            }
          });
          Object.assign(Quaternion.prototype, {
            multiplyVector3: function(vector) {
              console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
              return vector.applyQuaternion(this);
            }
          });
          Object.assign(Ray.prototype, {
            isIntersectionBox: function(box) {
              console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
              return this.intersectsBox(box);
            },
            isIntersectionPlane: function(plane) {
              console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
              return this.intersectsPlane(plane);
            },
            isIntersectionSphere: function(sphere) {
              console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
              return this.intersectsSphere(sphere);
            }
          });
          Object.assign(Shape.prototype, {
            extrude: function(options) {
              console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
              return new ExtrudeGeometry(this, options);
            },
            makeGeometry: function(options) {
              console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
              return new ShapeGeometry(this, options);
            }
          });
          Object.assign(Vector3.prototype, {
            setEulerFromRotationMatrix: function() {
              console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
            },
            setEulerFromQuaternion: function() {
              console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
            },
            getPositionFromMatrix: function(m) {
              console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
              return this.setFromMatrixPosition(m);
            },
            getScaleFromMatrix: function(m) {
              console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
              return this.setFromMatrixScale(m);
            },
            getColumnFromMatrix: function(index, matrix) {
              console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
              return this.setFromMatrixColumn(matrix, index);
            }
          });
          Object.assign(Object3D.prototype, {
            getChildByName: function(name) {
              console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
              return this.getObjectByName(name);
            },
            renderDepth: function(value) {
              console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
            },
            translate: function(distance, axis) {
              console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
              return this.translateOnAxis(axis, distance);
            }
          });
          Object.defineProperties(Object3D.prototype, {
            eulerOrder: {
              get: function() {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                return this.rotation.order;
              },
              set: function(value) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
                this.rotation.order = value;
              }
            },
            useQuaternion: {
              get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
              },
              set: function(value) {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
              }
            }
          });
          Object.defineProperties(LOD.prototype, {
            objects: {
              get: function() {
                console.warn("THREE.LOD: .objects has been renamed to .levels.");
                return this.levels;
              }
            }
          });
          PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
            if (filmGauge !== void 0)
              this.filmGauge = filmGauge;
            this.setFocalLength(focalLength);
          };
          Object.defineProperties(Light.prototype, {
            onlyShadow: {
              set: function(value) {
                console.warn("THREE.Light: .onlyShadow has been removed.");
              }
            },
            shadowCameraFov: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
                this.shadow.camera.fov = value;
              }
            },
            shadowCameraLeft: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
                this.shadow.camera.left = value;
              }
            },
            shadowCameraRight: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
                this.shadow.camera.right = value;
              }
            },
            shadowCameraTop: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
                this.shadow.camera.top = value;
              }
            },
            shadowCameraBottom: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
                this.shadow.camera.bottom = value;
              }
            },
            shadowCameraNear: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
                this.shadow.camera.near = value;
              }
            },
            shadowCameraFar: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
                this.shadow.camera.far = value;
              }
            },
            shadowCameraVisible: {
              set: function(value) {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
              }
            },
            shadowBias: {
              set: function(value) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
                this.shadow.bias = value;
              }
            },
            shadowDarkness: {
              set: function(value) {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
              }
            },
            shadowMapWidth: {
              set: function(value) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
                this.shadow.mapSize.width = value;
              }
            },
            shadowMapHeight: {
              set: function(value) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
                this.shadow.mapSize.height = value;
              }
            }
          });
          Object.defineProperties(BufferAttribute.prototype, {
            length: {
              get: function() {
                console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");
                return this.array.length;
              }
            }
          });
          Object.assign(BufferGeometry.prototype, {
            addIndex: function(index) {
              console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
              this.setIndex(index);
            },
            addDrawCall: function(start, count2, indexOffset) {
              if (indexOffset !== void 0) {
                console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
              }
              console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
              this.addGroup(start, count2);
            },
            clearDrawCalls: function() {
              console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
              this.clearGroups();
            },
            computeTangents: function() {
              console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
            },
            computeOffsets: function() {
              console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
            }
          });
          Object.defineProperties(BufferGeometry.prototype, {
            drawcalls: {
              get: function() {
                console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
                return this.groups;
              }
            },
            offsets: {
              get: function() {
                console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
                return this.groups;
              }
            }
          });
          Object.defineProperties(Material.prototype, {
            wrapAround: {
              get: function() {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.");
              },
              set: function(value) {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.");
              }
            },
            wrapRGB: {
              get: function() {
                console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
                return new Color();
              }
            }
          });
          Object.defineProperties(MeshPhongMaterial.prototype, {
            metal: {
              get: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
                return false;
              },
              set: function(value) {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
              }
            }
          });
          Object.defineProperties(ShaderMaterial.prototype, {
            derivatives: {
              get: function() {
                console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                return this.extensions.derivatives;
              },
              set: function(value) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
                this.extensions.derivatives = value;
              }
            }
          });
          EventDispatcher.prototype = Object.assign(/* @__PURE__ */ Object.create({
            // Note: Extra base ensures these properties are not 'assign'ed.
            constructor: EventDispatcher,
            apply: function(target) {
              console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in.");
              Object.assign(target, this);
            }
          }), EventDispatcher.prototype);
          Object.defineProperties(Uniform.prototype, {
            dynamic: {
              set: function(value) {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
              }
            },
            onUpdate: {
              value: function() {
                console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
                return this;
              }
            }
          });
          Object.assign(WebGLRenderer.prototype, {
            supportsFloatTextures: function() {
              console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
              return this.extensions.get("OES_texture_float");
            },
            supportsHalfFloatTextures: function() {
              console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
              return this.extensions.get("OES_texture_half_float");
            },
            supportsStandardDerivatives: function() {
              console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
              return this.extensions.get("OES_standard_derivatives");
            },
            supportsCompressedTextureS3TC: function() {
              console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
              return this.extensions.get("WEBGL_compressed_texture_s3tc");
            },
            supportsCompressedTexturePVRTC: function() {
              console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
              return this.extensions.get("WEBGL_compressed_texture_pvrtc");
            },
            supportsBlendMinMax: function() {
              console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
              return this.extensions.get("EXT_blend_minmax");
            },
            supportsVertexTextures: function() {
              return this.capabilities.vertexTextures;
            },
            supportsInstancedArrays: function() {
              console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
              return this.extensions.get("ANGLE_instanced_arrays");
            },
            enableScissorTest: function(boolean) {
              console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
              this.setScissorTest(boolean);
            },
            initMaterial: function() {
              console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
            },
            addPrePlugin: function() {
              console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
            },
            addPostPlugin: function() {
              console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
            },
            updateShadowMap: function() {
              console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
            }
          });
          Object.defineProperties(WebGLRenderer.prototype, {
            shadowMapEnabled: {
              get: function() {
                return this.shadowMap.enabled;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
                this.shadowMap.enabled = value;
              }
            },
            shadowMapType: {
              get: function() {
                return this.shadowMap.type;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
                this.shadowMap.type = value;
              }
            },
            shadowMapCullFace: {
              get: function() {
                return this.shadowMap.cullFace;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
                this.shadowMap.cullFace = value;
              }
            }
          });
          Object.defineProperties(WebGLShadowMap.prototype, {
            cullFace: {
              get: function() {
                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
              },
              set: function(cullFace) {
                var value = cullFace !== CullFaceBack;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
                this.renderReverseSided = value;
              }
            }
          });
          Object.defineProperties(WebGLRenderTarget.prototype, {
            wrapS: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                return this.texture.wrapS;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
                this.texture.wrapS = value;
              }
            },
            wrapT: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                return this.texture.wrapT;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
                this.texture.wrapT = value;
              }
            },
            magFilter: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                return this.texture.magFilter;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
                this.texture.magFilter = value;
              }
            },
            minFilter: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                return this.texture.minFilter;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
                this.texture.minFilter = value;
              }
            },
            anisotropy: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                return this.texture.anisotropy;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
                this.texture.anisotropy = value;
              }
            },
            offset: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                return this.texture.offset;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
                this.texture.offset = value;
              }
            },
            repeat: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                return this.texture.repeat;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
                this.texture.repeat = value;
              }
            },
            format: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                return this.texture.format;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
                this.texture.format = value;
              }
            },
            type: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                return this.texture.type;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
                this.texture.type = value;
              }
            },
            generateMipmaps: {
              get: function() {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                return this.texture.generateMipmaps;
              },
              set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
                this.texture.generateMipmaps = value;
              }
            }
          });
          Object.assign(Audio.prototype, {
            load: function(file) {
              console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
              var scope = this;
              var audioLoader = new AudioLoader();
              audioLoader.load(file, function(buffer) {
                scope.setBuffer(buffer);
              });
              return this;
            }
          });
          Object.assign(AudioAnalyser.prototype, {
            getData: function(file) {
              console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
              return this.getFrequencyData();
            }
          });
          var GeometryUtils = {
            merge: function(geometry1, geometry2, materialIndexOffset) {
              console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
              var matrix;
              if (geometry2.isMesh) {
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
              }
              geometry1.merge(geometry2, matrix, materialIndexOffset);
            },
            center: function(geometry) {
              console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
              return geometry.center();
            }
          };
          var ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(url, mapping, onLoad, onError) {
              console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
              var loader = new TextureLoader();
              loader.setCrossOrigin(this.crossOrigin);
              var texture = loader.load(url, onLoad, void 0, onError);
              if (mapping)
                texture.mapping = mapping;
              return texture;
            },
            loadTextureCube: function(urls, mapping, onLoad, onError) {
              console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
              var loader = new CubeTextureLoader();
              loader.setCrossOrigin(this.crossOrigin);
              var texture = loader.load(urls, onLoad, void 0, onError);
              if (mapping)
                texture.mapping = mapping;
              return texture;
            },
            loadCompressedTexture: function() {
              console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
            },
            loadCompressedTextureCube: function() {
              console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
            }
          };
          function Projector() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
            this.projectVector = function(vector, camera) {
              console.warn("THREE.Projector: .projectVector() is now vector.project().");
              vector.project(camera);
            };
            this.unprojectVector = function(vector, camera) {
              console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
              vector.unproject(camera);
            };
            this.pickingRay = function(vector, camera) {
              console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
            };
          }
          function CanvasRenderer() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
            this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            this.clear = function() {
            };
            this.render = function() {
            };
            this.setClearColor = function() {
            };
            this.setSize = function() {
            };
          }
          exports4.WebGLRenderTargetCube = WebGLRenderTargetCube;
          exports4.WebGLRenderTarget = WebGLRenderTarget;
          exports4.WebGLRenderer = WebGLRenderer;
          exports4.ShaderLib = ShaderLib;
          exports4.UniformsLib = UniformsLib;
          exports4.UniformsUtils = UniformsUtils;
          exports4.ShaderChunk = ShaderChunk;
          exports4.FogExp2 = FogExp2;
          exports4.Fog = Fog;
          exports4.Scene = Scene;
          exports4.LensFlare = LensFlare;
          exports4.Sprite = Sprite;
          exports4.LOD = LOD;
          exports4.SkinnedMesh = SkinnedMesh;
          exports4.Skeleton = Skeleton;
          exports4.Bone = Bone;
          exports4.Mesh = Mesh;
          exports4.LineSegments = LineSegments;
          exports4.Line = Line;
          exports4.Points = Points;
          exports4.Group = Group;
          exports4.VideoTexture = VideoTexture;
          exports4.DataTexture = DataTexture;
          exports4.CompressedTexture = CompressedTexture;
          exports4.CubeTexture = CubeTexture;
          exports4.CanvasTexture = CanvasTexture;
          exports4.DepthTexture = DepthTexture;
          exports4.TextureIdCount = TextureIdCount;
          exports4.Texture = Texture;
          exports4.MaterialIdCount = MaterialIdCount;
          exports4.CompressedTextureLoader = CompressedTextureLoader;
          exports4.BinaryTextureLoader = BinaryTextureLoader;
          exports4.DataTextureLoader = DataTextureLoader;
          exports4.CubeTextureLoader = CubeTextureLoader;
          exports4.TextureLoader = TextureLoader;
          exports4.ObjectLoader = ObjectLoader;
          exports4.MaterialLoader = MaterialLoader;
          exports4.BufferGeometryLoader = BufferGeometryLoader;
          exports4.DefaultLoadingManager = DefaultLoadingManager;
          exports4.LoadingManager = LoadingManager;
          exports4.JSONLoader = JSONLoader;
          exports4.ImageLoader = ImageLoader;
          exports4.FontLoader = FontLoader;
          exports4.XHRLoader = XHRLoader;
          exports4.Loader = Loader;
          exports4.Cache = Cache;
          exports4.AudioLoader = AudioLoader;
          exports4.SpotLightShadow = SpotLightShadow;
          exports4.SpotLight = SpotLight;
          exports4.PointLight = PointLight;
          exports4.HemisphereLight = HemisphereLight;
          exports4.DirectionalLightShadow = DirectionalLightShadow;
          exports4.DirectionalLight = DirectionalLight;
          exports4.AmbientLight = AmbientLight;
          exports4.LightShadow = LightShadow;
          exports4.Light = Light;
          exports4.StereoCamera = StereoCamera;
          exports4.PerspectiveCamera = PerspectiveCamera;
          exports4.OrthographicCamera = OrthographicCamera;
          exports4.CubeCamera = CubeCamera;
          exports4.Camera = Camera;
          exports4.AudioListener = AudioListener;
          exports4.PositionalAudio = PositionalAudio;
          exports4.getAudioContext = getAudioContext;
          exports4.AudioAnalyser = AudioAnalyser;
          exports4.Audio = Audio;
          exports4.VectorKeyframeTrack = VectorKeyframeTrack;
          exports4.StringKeyframeTrack = StringKeyframeTrack;
          exports4.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
          exports4.NumberKeyframeTrack = NumberKeyframeTrack;
          exports4.ColorKeyframeTrack = ColorKeyframeTrack;
          exports4.BooleanKeyframeTrack = BooleanKeyframeTrack;
          exports4.PropertyMixer = PropertyMixer;
          exports4.PropertyBinding = PropertyBinding;
          exports4.KeyframeTrack = KeyframeTrack;
          exports4.AnimationUtils = AnimationUtils;
          exports4.AnimationObjectGroup = AnimationObjectGroup;
          exports4.AnimationMixer = AnimationMixer;
          exports4.AnimationClip = AnimationClip;
          exports4.Uniform = Uniform;
          exports4.InstancedBufferGeometry = InstancedBufferGeometry;
          exports4.BufferGeometry = BufferGeometry;
          exports4.GeometryIdCount = GeometryIdCount;
          exports4.Geometry = Geometry;
          exports4.InterleavedBufferAttribute = InterleavedBufferAttribute;
          exports4.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
          exports4.InterleavedBuffer = InterleavedBuffer;
          exports4.InstancedBufferAttribute = InstancedBufferAttribute;
          exports4.DynamicBufferAttribute = DynamicBufferAttribute;
          exports4.Float64Attribute = Float64Attribute;
          exports4.Float32Attribute = Float32Attribute;
          exports4.Uint32Attribute = Uint32Attribute;
          exports4.Int32Attribute = Int32Attribute;
          exports4.Uint16Attribute = Uint16Attribute;
          exports4.Int16Attribute = Int16Attribute;
          exports4.Uint8ClampedAttribute = Uint8ClampedAttribute;
          exports4.Uint8Attribute = Uint8Attribute;
          exports4.Int8Attribute = Int8Attribute;
          exports4.BufferAttribute = BufferAttribute;
          exports4.Face3 = Face3;
          exports4.Object3DIdCount = Object3DIdCount;
          exports4.Object3D = Object3D;
          exports4.Raycaster = Raycaster;
          exports4.Layers = Layers;
          exports4.EventDispatcher = EventDispatcher;
          exports4.Clock = Clock;
          exports4.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
          exports4.LinearInterpolant = LinearInterpolant;
          exports4.DiscreteInterpolant = DiscreteInterpolant;
          exports4.CubicInterpolant = CubicInterpolant;
          exports4.Interpolant = Interpolant;
          exports4.Triangle = Triangle;
          exports4.Spline = Spline;
          exports4.Math = _Math;
          exports4.Spherical = Spherical;
          exports4.Plane = Plane;
          exports4.Frustum = Frustum;
          exports4.Sphere = Sphere;
          exports4.Ray = Ray;
          exports4.Matrix4 = Matrix4;
          exports4.Matrix3 = Matrix3;
          exports4.Box3 = Box3;
          exports4.Box2 = Box2;
          exports4.Line3 = Line3;
          exports4.Euler = Euler;
          exports4.Vector4 = Vector4;
          exports4.Vector3 = Vector3;
          exports4.Vector2 = Vector2;
          exports4.Quaternion = Quaternion;
          exports4.ColorKeywords = ColorKeywords;
          exports4.Color = Color;
          exports4.MorphBlendMesh = MorphBlendMesh;
          exports4.ImmediateRenderObject = ImmediateRenderObject;
          exports4.VertexNormalsHelper = VertexNormalsHelper;
          exports4.SpotLightHelper = SpotLightHelper;
          exports4.SkeletonHelper = SkeletonHelper;
          exports4.PointLightHelper = PointLightHelper;
          exports4.HemisphereLightHelper = HemisphereLightHelper;
          exports4.GridHelper = GridHelper;
          exports4.FaceNormalsHelper = FaceNormalsHelper;
          exports4.DirectionalLightHelper = DirectionalLightHelper;
          exports4.CameraHelper = CameraHelper;
          exports4.BoundingBoxHelper = BoundingBoxHelper;
          exports4.BoxHelper = BoxHelper;
          exports4.ArrowHelper = ArrowHelper;
          exports4.AxisHelper = AxisHelper;
          exports4.ClosedSplineCurve3 = ClosedSplineCurve3;
          exports4.CatmullRomCurve3 = CatmullRomCurve3;
          exports4.SplineCurve3 = SplineCurve3;
          exports4.CubicBezierCurve3 = CubicBezierCurve3;
          exports4.QuadraticBezierCurve3 = QuadraticBezierCurve3;
          exports4.LineCurve3 = LineCurve3;
          exports4.ArcCurve = ArcCurve;
          exports4.EllipseCurve = EllipseCurve;
          exports4.SplineCurve = SplineCurve;
          exports4.CubicBezierCurve = CubicBezierCurve;
          exports4.QuadraticBezierCurve = QuadraticBezierCurve;
          exports4.LineCurve = LineCurve;
          exports4.Shape = Shape;
          exports4.ShapePath = ShapePath;
          exports4.Path = Path;
          exports4.Font = Font;
          exports4.CurvePath = CurvePath;
          exports4.Curve = Curve;
          exports4.ShapeUtils = ShapeUtils;
          exports4.SceneUtils = SceneUtils;
          exports4.CurveUtils = CurveUtils;
          exports4.WireframeGeometry = WireframeGeometry;
          exports4.ParametricGeometry = ParametricGeometry;
          exports4.ParametricBufferGeometry = ParametricBufferGeometry;
          exports4.TetrahedronGeometry = TetrahedronGeometry;
          exports4.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
          exports4.OctahedronGeometry = OctahedronGeometry;
          exports4.OctahedronBufferGeometry = OctahedronBufferGeometry;
          exports4.IcosahedronGeometry = IcosahedronGeometry;
          exports4.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
          exports4.DodecahedronGeometry = DodecahedronGeometry;
          exports4.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
          exports4.PolyhedronGeometry = PolyhedronGeometry;
          exports4.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
          exports4.TubeGeometry = TubeGeometry;
          exports4.TubeBufferGeometry = TubeBufferGeometry;
          exports4.TorusKnotGeometry = TorusKnotGeometry;
          exports4.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
          exports4.TorusGeometry = TorusGeometry;
          exports4.TorusBufferGeometry = TorusBufferGeometry;
          exports4.TextGeometry = TextGeometry;
          exports4.SphereBufferGeometry = SphereBufferGeometry;
          exports4.SphereGeometry = SphereGeometry;
          exports4.RingGeometry = RingGeometry;
          exports4.RingBufferGeometry = RingBufferGeometry;
          exports4.PlaneBufferGeometry = PlaneBufferGeometry;
          exports4.PlaneGeometry = PlaneGeometry;
          exports4.LatheGeometry = LatheGeometry;
          exports4.LatheBufferGeometry = LatheBufferGeometry;
          exports4.ShapeGeometry = ShapeGeometry;
          exports4.ExtrudeGeometry = ExtrudeGeometry;
          exports4.EdgesGeometry = EdgesGeometry;
          exports4.ConeGeometry = ConeGeometry;
          exports4.ConeBufferGeometry = ConeBufferGeometry;
          exports4.CylinderGeometry = CylinderGeometry;
          exports4.CylinderBufferGeometry = CylinderBufferGeometry;
          exports4.CircleBufferGeometry = CircleBufferGeometry;
          exports4.CircleGeometry = CircleGeometry;
          exports4.BoxBufferGeometry = BoxBufferGeometry;
          exports4.BoxGeometry = BoxGeometry;
          exports4.ShadowMaterial = ShadowMaterial;
          exports4.SpriteMaterial = SpriteMaterial;
          exports4.RawShaderMaterial = RawShaderMaterial;
          exports4.ShaderMaterial = ShaderMaterial;
          exports4.PointsMaterial = PointsMaterial;
          exports4.MultiMaterial = MultiMaterial;
          exports4.MeshPhysicalMaterial = MeshPhysicalMaterial;
          exports4.MeshStandardMaterial = MeshStandardMaterial;
          exports4.MeshPhongMaterial = MeshPhongMaterial;
          exports4.MeshNormalMaterial = MeshNormalMaterial;
          exports4.MeshLambertMaterial = MeshLambertMaterial;
          exports4.MeshDepthMaterial = MeshDepthMaterial;
          exports4.MeshBasicMaterial = MeshBasicMaterial;
          exports4.LineDashedMaterial = LineDashedMaterial;
          exports4.LineBasicMaterial = LineBasicMaterial;
          exports4.Material = Material;
          exports4.REVISION = REVISION;
          exports4.MOUSE = MOUSE;
          exports4.CullFaceNone = CullFaceNone;
          exports4.CullFaceBack = CullFaceBack;
          exports4.CullFaceFront = CullFaceFront;
          exports4.CullFaceFrontBack = CullFaceFrontBack;
          exports4.FrontFaceDirectionCW = FrontFaceDirectionCW;
          exports4.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
          exports4.BasicShadowMap = BasicShadowMap;
          exports4.PCFShadowMap = PCFShadowMap;
          exports4.PCFSoftShadowMap = PCFSoftShadowMap;
          exports4.FrontSide = FrontSide;
          exports4.BackSide = BackSide;
          exports4.DoubleSide = DoubleSide;
          exports4.FlatShading = FlatShading;
          exports4.SmoothShading = SmoothShading;
          exports4.NoColors = NoColors;
          exports4.FaceColors = FaceColors;
          exports4.VertexColors = VertexColors;
          exports4.NoBlending = NoBlending;
          exports4.NormalBlending = NormalBlending;
          exports4.AdditiveBlending = AdditiveBlending;
          exports4.SubtractiveBlending = SubtractiveBlending;
          exports4.MultiplyBlending = MultiplyBlending;
          exports4.CustomBlending = CustomBlending;
          exports4.BlendingMode = BlendingMode;
          exports4.AddEquation = AddEquation;
          exports4.SubtractEquation = SubtractEquation;
          exports4.ReverseSubtractEquation = ReverseSubtractEquation;
          exports4.MinEquation = MinEquation;
          exports4.MaxEquation = MaxEquation;
          exports4.ZeroFactor = ZeroFactor;
          exports4.OneFactor = OneFactor;
          exports4.SrcColorFactor = SrcColorFactor;
          exports4.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
          exports4.SrcAlphaFactor = SrcAlphaFactor;
          exports4.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
          exports4.DstAlphaFactor = DstAlphaFactor;
          exports4.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
          exports4.DstColorFactor = DstColorFactor;
          exports4.OneMinusDstColorFactor = OneMinusDstColorFactor;
          exports4.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
          exports4.NeverDepth = NeverDepth;
          exports4.AlwaysDepth = AlwaysDepth;
          exports4.LessDepth = LessDepth;
          exports4.LessEqualDepth = LessEqualDepth;
          exports4.EqualDepth = EqualDepth;
          exports4.GreaterEqualDepth = GreaterEqualDepth;
          exports4.GreaterDepth = GreaterDepth;
          exports4.NotEqualDepth = NotEqualDepth;
          exports4.MultiplyOperation = MultiplyOperation;
          exports4.MixOperation = MixOperation;
          exports4.AddOperation = AddOperation;
          exports4.NoToneMapping = NoToneMapping;
          exports4.LinearToneMapping = LinearToneMapping;
          exports4.ReinhardToneMapping = ReinhardToneMapping;
          exports4.Uncharted2ToneMapping = Uncharted2ToneMapping;
          exports4.CineonToneMapping = CineonToneMapping;
          exports4.UVMapping = UVMapping;
          exports4.CubeReflectionMapping = CubeReflectionMapping;
          exports4.CubeRefractionMapping = CubeRefractionMapping;
          exports4.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
          exports4.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
          exports4.SphericalReflectionMapping = SphericalReflectionMapping;
          exports4.CubeUVReflectionMapping = CubeUVReflectionMapping;
          exports4.CubeUVRefractionMapping = CubeUVRefractionMapping;
          exports4.TextureMapping = TextureMapping;
          exports4.RepeatWrapping = RepeatWrapping;
          exports4.ClampToEdgeWrapping = ClampToEdgeWrapping;
          exports4.MirroredRepeatWrapping = MirroredRepeatWrapping;
          exports4.TextureWrapping = TextureWrapping;
          exports4.NearestFilter = NearestFilter;
          exports4.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
          exports4.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
          exports4.LinearFilter = LinearFilter;
          exports4.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
          exports4.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
          exports4.TextureFilter = TextureFilter;
          exports4.UnsignedByteType = UnsignedByteType;
          exports4.ByteType = ByteType;
          exports4.ShortType = ShortType;
          exports4.UnsignedShortType = UnsignedShortType;
          exports4.IntType = IntType;
          exports4.UnsignedIntType = UnsignedIntType;
          exports4.FloatType = FloatType;
          exports4.HalfFloatType = HalfFloatType;
          exports4.UnsignedShort4444Type = UnsignedShort4444Type;
          exports4.UnsignedShort5551Type = UnsignedShort5551Type;
          exports4.UnsignedShort565Type = UnsignedShort565Type;
          exports4.UnsignedInt248Type = UnsignedInt248Type;
          exports4.AlphaFormat = AlphaFormat;
          exports4.RGBFormat = RGBFormat;
          exports4.RGBAFormat = RGBAFormat;
          exports4.LuminanceFormat = LuminanceFormat;
          exports4.LuminanceAlphaFormat = LuminanceAlphaFormat;
          exports4.RGBEFormat = RGBEFormat;
          exports4.DepthFormat = DepthFormat;
          exports4.DepthStencilFormat = DepthStencilFormat;
          exports4.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
          exports4.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
          exports4.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
          exports4.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
          exports4.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
          exports4.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
          exports4.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
          exports4.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
          exports4.RGB_ETC1_Format = RGB_ETC1_Format;
          exports4.LoopOnce = LoopOnce;
          exports4.LoopRepeat = LoopRepeat;
          exports4.LoopPingPong = LoopPingPong;
          exports4.InterpolateDiscrete = InterpolateDiscrete;
          exports4.InterpolateLinear = InterpolateLinear;
          exports4.InterpolateSmooth = InterpolateSmooth;
          exports4.ZeroCurvatureEnding = ZeroCurvatureEnding;
          exports4.ZeroSlopeEnding = ZeroSlopeEnding;
          exports4.WrapAroundEnding = WrapAroundEnding;
          exports4.TrianglesDrawMode = TrianglesDrawMode;
          exports4.TriangleStripDrawMode = TriangleStripDrawMode;
          exports4.TriangleFanDrawMode = TriangleFanDrawMode;
          exports4.LinearEncoding = LinearEncoding;
          exports4.sRGBEncoding = sRGBEncoding;
          exports4.GammaEncoding = GammaEncoding;
          exports4.RGBEEncoding = RGBEEncoding;
          exports4.LogLuvEncoding = LogLuvEncoding;
          exports4.RGBM7Encoding = RGBM7Encoding;
          exports4.RGBM16Encoding = RGBM16Encoding;
          exports4.RGBDEncoding = RGBDEncoding;
          exports4.BasicDepthPacking = BasicDepthPacking;
          exports4.RGBADepthPacking = RGBADepthPacking;
          exports4.CubeGeometry = BoxGeometry;
          exports4.Face4 = Face4;
          exports4.LineStrip = LineStrip;
          exports4.LinePieces = LinePieces;
          exports4.MeshFaceMaterial = MultiMaterial;
          exports4.PointCloud = PointCloud;
          exports4.Particle = Sprite;
          exports4.ParticleSystem = ParticleSystem;
          exports4.PointCloudMaterial = PointCloudMaterial;
          exports4.ParticleBasicMaterial = ParticleBasicMaterial;
          exports4.ParticleSystemMaterial = ParticleSystemMaterial;
          exports4.Vertex = Vertex;
          exports4.EdgesHelper = EdgesHelper;
          exports4.WireframeHelper = WireframeHelper;
          exports4.GeometryUtils = GeometryUtils;
          exports4.ImageUtils = ImageUtils;
          exports4.Projector = Projector;
          exports4.CanvasRenderer = CanvasRenderer;
          Object.defineProperty(exports4, "__esModule", { value: true });
          Object.defineProperty(exports4, "AudioContext", {
            get: function() {
              return exports4.getAudioContext();
            }
          });
        });
      }, {}], 14: [function(_dereq_, module3, exports3) {
        THREE.BlendCharacter = function() {
          this.weightSchedule = [];
          this.warpSchedule = [];
          this.load = function(url, onLoad) {
            var scope = this;
            var loader = new THREE.ObjectLoader();
            loader.load(url, function(loadedObject) {
              loadedObject.traverse(function(object) {
                if (object instanceof THREE.SkinnedMesh) {
                  scope.skinnedMesh = object;
                }
              });
              THREE.SkinnedMesh.call(scope, scope.skinnedMesh.geometry, scope.skinnedMesh.material);
              if (scope.skinnedMesh == void 0) {
                console.log("unable to find skinned mesh in " + url);
                return;
              }
              scope.material.skinning = true;
              scope.mixer = new THREE.AnimationMixer(scope);
              scope.mixer = scope.mixer;
              for (var i = 0; i < scope.geometry.animations.length; ++i) {
                scope.mixer.clipAction(scope.geometry.animations[i]);
              }
              if (onLoad !== void 0)
                onLoad();
            });
          };
          this.loadJSON = function(url, onLoad) {
            var scope = this;
            var loader = new THREE.JSONLoader();
            loader.load(url, function(geometry, materials) {
              var originalMaterial = materials[0];
              originalMaterial.skinning = true;
              THREE.SkinnedMesh.call(scope, geometry, originalMaterial);
              var mixer = new THREE.AnimationMixer(scope);
              scope.mixer = mixer;
              for (var i = 0; i < geometry.animations.length; ++i) {
                mixer.clipAction(geometry.animations[i]);
              }
              if (onLoad !== void 0)
                onLoad();
            });
          };
          this.update = function(dt) {
            this.mixer.update(dt);
          };
          this.play = function(animName, weight) {
            return this.mixer.clipAction(animName).setEffectiveWeight(weight).play();
          };
          this.crossfade = function(fromAnimName, toAnimName, duration) {
            this.mixer.stopAllAction();
            var fromAction = this.play(fromAnimName, 1);
            var toAction = this.play(toAnimName, 1);
            fromAction.crossFadeTo(toAction, duration, false);
          };
          this.warp = function(fromAnimName, toAnimName, duration) {
            this.mixer.stopAllAction();
            var fromAction = this.play(fromAnimName, 1);
            var toAction = this.play(toAnimName, 1);
            fromAction.crossFadeTo(toAction, duration, true);
          };
          this.applyWeight = function(animName, weight) {
            this.mixer.clipAction(animName).setEffectiveWeight(weight);
          };
          this.getWeight = function(animName) {
            return this.mixer.clipAction(animName).getEffectiveWeight();
          };
          this.pauseAll = function() {
            this.mixer.timeScale = 0;
          };
          this.unPauseAll = function() {
            this.mixer.timeScale = 1;
          };
          this.stopAll = function() {
            this.mixer.stopAllAction();
          };
          this.showModel = function(boolean) {
            this.visible = boolean;
          };
        };
        THREE.BlendCharacter.prototype = Object.create(THREE.SkinnedMesh.prototype);
        THREE.BlendCharacter.prototype.constructor = THREE.BlendCharacter;
        THREE.BlendCharacter.prototype.getForward = function() {
          var forward = new THREE.Vector3();
          return function() {
            forward.set(
              -this.matrix.elements[8],
              -this.matrix.elements[9],
              -this.matrix.elements[10]
            );
            return forward;
          };
        };
      }, {}], 15: [function(_dereq_, module3, exports3) {
        THREE.ColladaLoader = function() {
          var COLLADA = null;
          var scene = null;
          var visualScene;
          var kinematicsModel;
          var readyCallbackFunc = null;
          var sources = {};
          var images = {};
          var animations = {};
          var controllers = {};
          var geometries = {};
          var materials = {};
          var effects = {};
          var cameras = {};
          var lights = {};
          var animData;
          var kinematics;
          var visualScenes;
          var kinematicsModels;
          var baseUrl;
          var morphs;
          var skins;
          var flip_uv = true;
          var preferredShading = THREE.SmoothShading;
          var options = {
            // Force Geometry to always be centered at the local origin of the
            // containing Mesh.
            centerGeometry: false,
            // Axis conversion is done for geometries, animations, and controllers.
            // If we ever pull cameras or lights out of the COLLADA file, they'll
            // need extra work.
            convertUpAxis: false,
            subdivideFaces: true,
            upAxis: "Y",
            // For reflective or refractive materials we'll use this cubemap
            defaultEnvMap: null
          };
          var colladaUnit = 1;
          var colladaUp = "Y";
          var upConversion = null;
          function load(url, readyCallback, progressCallback, failCallback) {
            var length = 0;
            if (document.implementation && document.implementation.createDocument) {
              var request = new XMLHttpRequest();
              request.onreadystatechange = function() {
                if (request.readyState === 4) {
                  if (request.status === 0 || request.status === 200) {
                    if (request.response) {
                      readyCallbackFunc = readyCallback;
                      parse(request.response, void 0, url);
                    } else {
                      if (failCallback) {
                        failCallback({ type: "error", url });
                      } else {
                        console.error("ColladaLoader: Empty or non-existing file (" + url + ")");
                      }
                    }
                  } else {
                    if (failCallback) {
                      failCallback({ type: "error", url });
                    } else {
                      console.error(`ColladaLoader: Couldn't load "` + url + '" (' + request.status + ")");
                    }
                  }
                } else if (request.readyState === 3) {
                  if (progressCallback) {
                    if (length === 0) {
                      length = request.getResponseHeader("Content-Length");
                    }
                    progressCallback({ total: length, loaded: request.responseText.length });
                  }
                }
              };
              request.open("GET", url, true);
              request.send(null);
            } else {
              alert("Don't know how to parse XML!");
            }
          }
          function parse(text, callBack, url) {
            COLLADA = new DOMParser().parseFromString(text, "text/xml");
            callBack = callBack || readyCallbackFunc;
            if (url !== void 0) {
              var parts = url.split("/");
              parts.pop();
              baseUrl = (parts.length < 1 ? "." : parts.join("/")) + "/";
            }
            parseAsset();
            setUpConversion();
            images = parseLib("library_images image", _Image, "image");
            materials = parseLib("library_materials material", Material, "material");
            effects = parseLib("library_effects effect", Effect, "effect");
            geometries = parseLib("library_geometries geometry", Geometry, "geometry");
            cameras = parseLib("library_cameras camera", Camera, "camera");
            lights = parseLib("library_lights light", Light, "light");
            controllers = parseLib("library_controllers controller", Controller, "controller");
            animations = parseLib("library_animations animation", Animation, "animation");
            visualScenes = parseLib("library_visual_scenes visual_scene", VisualScene, "visual_scene");
            kinematicsModels = parseLib("library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model");
            morphs = [];
            skins = [];
            visualScene = parseScene();
            scene = new THREE.Group();
            for (var i = 0; i < visualScene.nodes.length; i++) {
              scene.add(createSceneGraph(visualScene.nodes[i]));
            }
            scene.scale.multiplyScalar(colladaUnit);
            createAnimations();
            kinematicsModel = parseKinematicsModel();
            createKinematics();
            var result = {
              scene,
              morphs,
              skins,
              animations: animData,
              kinematics,
              dae: {
                images,
                materials,
                cameras,
                lights,
                effects,
                geometries,
                controllers,
                animations,
                visualScenes,
                visualScene,
                scene: visualScene,
                kinematicsModels,
                kinematicsModel
              }
            };
            if (callBack) {
              callBack(result);
            }
            return result;
          }
          function setPreferredShading(shading) {
            preferredShading = shading;
          }
          function parseAsset() {
            var elements = COLLADA.querySelectorAll("asset");
            var element = elements[0];
            if (element && element.childNodes) {
              for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                switch (child.nodeName) {
                  case "unit":
                    var meter = child.getAttribute("meter");
                    if (meter) {
                      colladaUnit = parseFloat(meter);
                    }
                    break;
                  case "up_axis":
                    colladaUp = child.textContent.charAt(0);
                    break;
                }
              }
            }
          }
          function parseLib(q, classSpec, prefix) {
            var elements = COLLADA.querySelectorAll(q);
            var lib = {};
            var i = 0;
            var elementsLength = elements.length;
            for (var j = 0; j < elementsLength; j++) {
              var element = elements[j];
              var daeElement = new classSpec().parse(element);
              if (!daeElement.id || daeElement.id.length === 0)
                daeElement.id = prefix + i++;
              lib[daeElement.id] = daeElement;
            }
            return lib;
          }
          function parseScene() {
            var sceneElement = COLLADA.querySelectorAll("scene instance_visual_scene")[0];
            if (sceneElement) {
              var url = sceneElement.getAttribute("url").replace(/^#/, "");
              return visualScenes[url.length > 0 ? url : "visual_scene0"];
            } else {
              return null;
            }
          }
          function parseKinematicsModel() {
            var kinematicsModelElement = COLLADA.querySelectorAll("instance_kinematics_model")[0];
            if (kinematicsModelElement) {
              var url = kinematicsModelElement.getAttribute("url").replace(/^#/, "");
              return kinematicsModels[url.length > 0 ? url : "kinematics_model0"];
            } else {
              return null;
            }
          }
          function createAnimations() {
            animData = [];
            recurseHierarchy(scene);
          }
          function recurseHierarchy(node) {
            var n = visualScene.getChildById(node.colladaId, true), newData = null;
            if (n && n.keys) {
              newData = {
                fps: 60,
                hierarchy: [{
                  node: n,
                  keys: n.keys,
                  sids: n.sids
                }],
                node,
                name: "animation_" + node.name,
                length: 0
              };
              animData.push(newData);
              for (var i = 0, il = n.keys.length; i < il; i++) {
                newData.length = Math.max(newData.length, n.keys[i].time);
              }
            } else {
              newData = {
                hierarchy: [{
                  keys: [],
                  sids: []
                }]
              };
            }
            for (var i = 0, il = node.children.length; i < il; i++) {
              var d = recurseHierarchy(node.children[i]);
              for (var j = 0, jl = d.hierarchy.length; j < jl; j++) {
                newData.hierarchy.push({
                  keys: [],
                  sids: []
                });
              }
            }
            return newData;
          }
          function calcAnimationBounds() {
            var start = 1e6;
            var end = -start;
            var frames = 0;
            var ID;
            for (var id in animations) {
              var animation = animations[id];
              ID = ID || animation.id;
              for (var i = 0; i < animation.sampler.length; i++) {
                var sampler = animation.sampler[i];
                sampler.create();
                start = Math.min(start, sampler.startTime);
                end = Math.max(end, sampler.endTime);
                frames = Math.max(frames, sampler.input.length);
              }
            }
            return { start, end, frames, ID };
          }
          function createMorph(geometry, ctrl) {
            var morphCtrl = ctrl instanceof InstanceController ? controllers[ctrl.url] : ctrl;
            if (!morphCtrl || !morphCtrl.morph) {
              console.log("could not find morph controller!");
              return;
            }
            var morph = morphCtrl.morph;
            for (var i = 0; i < morph.targets.length; i++) {
              var target_id = morph.targets[i];
              var daeGeometry = geometries[target_id];
              if (!daeGeometry.mesh || !daeGeometry.mesh.primitives || !daeGeometry.mesh.primitives.length) {
                continue;
              }
              var target = daeGeometry.mesh.primitives[0].geometry;
              if (target.vertices.length === geometry.vertices.length) {
                geometry.morphTargets.push({ name: "target_1", vertices: target.vertices });
              }
            }
            geometry.morphTargets.push({ name: "target_Z", vertices: geometry.vertices });
          }
          function createSkin(geometry, ctrl, applyBindShape) {
            var skinCtrl = controllers[ctrl.url];
            if (!skinCtrl || !skinCtrl.skin) {
              console.log("could not find skin controller!");
              return;
            }
            if (!ctrl.skeleton || !ctrl.skeleton.length) {
              console.log("could not find the skeleton for the skin!");
              return;
            }
            var skin = skinCtrl.skin;
            var skeleton = visualScene.getChildById(ctrl.skeleton[0]);
            var hierarchy = [];
            applyBindShape = applyBindShape !== void 0 ? applyBindShape : true;
            var bones = [];
            geometry.skinWeights = [];
            geometry.skinIndices = [];
            if (applyBindShape) {
              for (var i = 0; i < geometry.vertices.length; i++) {
                geometry.vertices[i].applyMatrix4(skin.bindShapeMatrix);
              }
            }
          }
          function setupSkeleton(node, bones, frame, parent) {
            node.world = node.world || new THREE.Matrix4();
            node.localworld = node.localworld || new THREE.Matrix4();
            node.world.copy(node.matrix);
            node.localworld.copy(node.matrix);
            if (node.channels && node.channels.length) {
              var channel = node.channels[0];
              var m = channel.sampler.output[frame];
              if (m instanceof THREE.Matrix4) {
                node.world.copy(m);
                node.localworld.copy(m);
                if (frame === 0)
                  node.matrix.copy(m);
              }
            }
            if (parent) {
              node.world.multiplyMatrices(parent, node.world);
            }
            bones.push(node);
            for (var i = 0; i < node.nodes.length; i++) {
              setupSkeleton(node.nodes[i], bones, frame, node.world);
            }
          }
          function setupSkinningMatrices(bones, skin) {
            for (var i = 0; i < bones.length; i++) {
              var bone = bones[i];
              var found = -1;
              if (bone.type != "JOINT")
                continue;
              for (var j = 0; j < skin.joints.length; j++) {
                if (bone.sid === skin.joints[j]) {
                  found = j;
                  break;
                }
              }
              if (found >= 0) {
                var inv = skin.invBindMatrices[found];
                bone.invBindMatrix = inv;
                bone.skinningMatrix = new THREE.Matrix4();
                bone.skinningMatrix.multiplyMatrices(bone.world, inv);
                bone.animatrix = new THREE.Matrix4();
                bone.animatrix.copy(bone.localworld);
                bone.weights = [];
                for (var j = 0; j < skin.weights.length; j++) {
                  for (var k = 0; k < skin.weights[j].length; k++) {
                    var w = skin.weights[j][k];
                    if (w.joint === found) {
                      bone.weights.push(w);
                    }
                  }
                }
              } else {
                console.warn("ColladaLoader: Could not find joint '" + bone.sid + "'.");
                bone.skinningMatrix = new THREE.Matrix4();
                bone.weights = [];
              }
            }
          }
          function flattenSkeleton(skeleton) {
            var list = [];
            var walk = function(parentid, node, list2) {
              var bone = {};
              bone.name = node.sid;
              bone.parent = parentid;
              bone.matrix = node.matrix;
              var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
              bone.matrix.decompose(data[0], data[1], data[2]);
              bone.pos = [data[0].x, data[0].y, data[0].z];
              bone.scl = [data[2].x, data[2].y, data[2].z];
              bone.rotq = [data[1].x, data[1].y, data[1].z, data[1].w];
              list2.push(bone);
              for (var i in node.nodes) {
                walk(node.sid, node.nodes[i], list2);
              }
            };
            walk(-1, skeleton, list);
            return list;
          }
          function skinToBindPose(geometry, skeleton, skinController) {
            var bones = [];
            setupSkeleton(skeleton, bones, -1);
            setupSkinningMatrices(bones, skinController.skin);
            var v = new THREE.Vector3();
            var skinned = [];
            for (var i = 0; i < geometry.vertices.length; i++) {
              skinned.push(new THREE.Vector3());
            }
            for (i = 0; i < bones.length; i++) {
              if (bones[i].type != "JOINT")
                continue;
              for (var j = 0; j < bones[i].weights.length; j++) {
                var w = bones[i].weights[j];
                var vidx = w.index;
                var weight = w.weight;
                var o = geometry.vertices[vidx];
                var s = skinned[vidx];
                v.x = o.x;
                v.y = o.y;
                v.z = o.z;
                v.applyMatrix4(bones[i].skinningMatrix);
                s.x += v.x * weight;
                s.y += v.y * weight;
                s.z += v.z * weight;
              }
            }
            for (var i = 0; i < geometry.vertices.length; i++) {
              geometry.vertices[i] = skinned[i];
            }
          }
          function applySkin(geometry, instanceCtrl, frame) {
            var skinController = controllers[instanceCtrl.url];
            frame = frame !== void 0 ? frame : 40;
            if (!skinController || !skinController.skin) {
              console.log("ColladaLoader: Could not find skin controller.");
              return;
            }
            if (!instanceCtrl.skeleton || !instanceCtrl.skeleton.length) {
              console.log("ColladaLoader: Could not find the skeleton for the skin. ");
              return;
            }
            var animationBounds = calcAnimationBounds();
            var skeleton = visualScene.getChildById(instanceCtrl.skeleton[0], true) || visualScene.getChildBySid(instanceCtrl.skeleton[0], true);
            var bonelist = flattenSkeleton(skeleton);
            var joints = skinController.skin.joints;
            var sortedbones = [];
            for (var i = 0; i < joints.length; i++) {
              for (var j = 0; j < bonelist.length; j++) {
                if (bonelist[j].name === joints[i]) {
                  sortedbones[i] = bonelist[j];
                }
              }
            }
            for (var i = 0; i < sortedbones.length; i++) {
              for (var j = 0; j < sortedbones.length; j++) {
                if (sortedbones[i].parent === sortedbones[j].name) {
                  sortedbones[i].parent = j;
                }
              }
            }
            var i, j, w, vidx, weight;
            var v = new THREE.Vector3(), o, s;
            for (i = 0; i < geometry.vertices.length; i++) {
              geometry.vertices[i].applyMatrix4(skinController.skin.bindShapeMatrix);
            }
            var skinIndices = [];
            var skinWeights = [];
            var weights = skinController.skin.weights;
            for (var i = 0; i < weights.length; i++) {
              var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0, weights[i][1] ? weights[i][1].joint : 0, weights[i][2] ? weights[i][2].joint : 0, weights[i][3] ? weights[i][3].joint : 0);
              var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0, weights[i][1] ? weights[i][1].weight : 0, weights[i][2] ? weights[i][2].weight : 0, weights[i][3] ? weights[i][3].weight : 0);
              skinIndices.push(indicies);
              skinWeights.push(weight);
            }
            geometry.skinIndices = skinIndices;
            geometry.skinWeights = skinWeights;
            geometry.bones = sortedbones;
            var animationdata = { "name": animationBounds.ID, "fps": 30, "length": animationBounds.frames / 30, "hierarchy": [] };
            for (var j = 0; j < sortedbones.length; j++) {
              animationdata.hierarchy.push({ parent: sortedbones[j].parent, name: sortedbones[j].name, keys: [] });
            }
            console.log("ColladaLoader:", animationBounds.ID + " has " + sortedbones.length + " bones.");
            skinToBindPose(geometry, skeleton, skinController);
            for (frame = 0; frame < animationBounds.frames; frame++) {
              var bones = [];
              var skinned = [];
              setupSkeleton(skeleton, bones, frame);
              setupSkinningMatrices(bones, skinController.skin);
              for (var i = 0; i < bones.length; i++) {
                for (var j = 0; j < animationdata.hierarchy.length; j++) {
                  if (animationdata.hierarchy[j].name === bones[i].sid) {
                    var key = {};
                    key.time = frame / 30;
                    key.matrix = bones[i].animatrix;
                    if (frame === 0)
                      bones[i].matrix = key.matrix;
                    var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
                    key.matrix.decompose(data[0], data[1], data[2]);
                    key.pos = [data[0].x, data[0].y, data[0].z];
                    key.scl = [data[2].x, data[2].y, data[2].z];
                    key.rot = data[1];
                    animationdata.hierarchy[j].keys.push(key);
                  }
                }
              }
              geometry.animation = animationdata;
            }
          }
          function createKinematics() {
            if (kinematicsModel && kinematicsModel.joints.length === 0) {
              kinematics = void 0;
              return;
            }
            var jointMap = {};
            var _addToMap = function(jointIndex2, parentVisualElement2) {
              var parentVisualElementId = parentVisualElement2.getAttribute("id");
              var colladaNode = visualScene.getChildById(parentVisualElementId, true);
              var joint = kinematicsModel.joints[jointIndex2];
              scene.traverse(function(node) {
                if (node.colladaId == parentVisualElementId) {
                  jointMap[jointIndex2] = {
                    node,
                    transforms: colladaNode.transforms,
                    joint,
                    position: joint.zeroPosition
                  };
                }
              });
            };
            kinematics = {
              joints: kinematicsModel && kinematicsModel.joints,
              getJointValue: function(jointIndex2) {
                var jointData = jointMap[jointIndex2];
                if (jointData) {
                  return jointData.position;
                } else {
                  console.log("getJointValue: joint " + jointIndex2 + " doesn't exist");
                }
              },
              setJointValue: function(jointIndex2, value) {
                var jointData = jointMap[jointIndex2];
                if (jointData) {
                  var joint = jointData.joint;
                  if (value > joint.limits.max || value < joint.limits.min) {
                    console.log("setJointValue: joint " + jointIndex2 + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ")");
                  } else if (joint.static) {
                    console.log("setJointValue: joint " + jointIndex2 + " is static");
                  } else {
                    var threejsNode = jointData.node;
                    var axis2 = joint.axis;
                    var transforms = jointData.transforms;
                    var matrix = new THREE.Matrix4();
                    for (i = 0; i < transforms.length; i++) {
                      var transform = transforms[i];
                      if (transform.sid && transform.sid.indexOf("joint" + jointIndex2) !== -1) {
                        switch (joint.type) {
                          case "revolute":
                            matrix.multiply(m1.makeRotationAxis(axis2, THREE.Math.degToRad(value)));
                            break;
                          case "prismatic":
                            matrix.multiply(m1.makeTranslation(axis2.x * value, axis2.y * value, axis2.z * value));
                            break;
                          default:
                            console.warn("setJointValue: unknown joint type: " + joint.type);
                            break;
                        }
                      } else {
                        var m1 = new THREE.Matrix4();
                        switch (transform.type) {
                          case "matrix":
                            matrix.multiply(transform.obj);
                            break;
                          case "translate":
                            matrix.multiply(m1.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                            break;
                          case "rotate":
                            matrix.multiply(m1.makeRotationAxis(transform.obj, transform.angle));
                            break;
                        }
                      }
                    }
                    var elementsFloat32Arr = matrix.elements;
                    var elements = Array.prototype.slice.call(elementsFloat32Arr);
                    var elementsRowMajor = [
                      elements[0],
                      elements[4],
                      elements[8],
                      elements[12],
                      elements[1],
                      elements[5],
                      elements[9],
                      elements[13],
                      elements[2],
                      elements[6],
                      elements[10],
                      elements[14],
                      elements[3],
                      elements[7],
                      elements[11],
                      elements[15]
                    ];
                    threejsNode.matrix.set.apply(threejsNode.matrix, elementsRowMajor);
                    threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
                  }
                } else {
                  console.log("setJointValue: joint " + jointIndex2 + " doesn't exist");
                }
              }
            };
            var element = COLLADA.querySelector("scene instance_kinematics_scene");
            if (element) {
              for (var i = 0; i < element.childNodes.length; i++) {
                var child = element.childNodes[i];
                if (child.nodeType != 1)
                  continue;
                switch (child.nodeName) {
                  case "bind_joint_axis":
                    var visualTarget = child.getAttribute("target").split("/").pop();
                    var axis = child.querySelector("axis param").textContent;
                    var jointIndex = parseInt(axis.split("joint").pop().split(".")[0]);
                    var visualTargetElement = COLLADA.querySelector('[sid="' + visualTarget + '"]');
                    if (visualTargetElement) {
                      var parentVisualElement = visualTargetElement.parentElement;
                      _addToMap(jointIndex, parentVisualElement);
                    }
                    break;
                  default:
                    break;
                }
              }
            }
          }
          function createSceneGraph(node, parent) {
            var obj = new THREE.Object3D();
            var skinned = false;
            var skinController;
            var morphController;
            var i, j;
            for (i = 0; i < node.controllers.length; i++) {
              var controller = controllers[node.controllers[i].url];
              switch (controller.type) {
                case "skin":
                  if (geometries[controller.skin.source]) {
                    var inst_geom = new InstanceGeometry();
                    inst_geom.url = controller.skin.source;
                    inst_geom.instance_material = node.controllers[i].instance_material;
                    node.geometries.push(inst_geom);
                    skinned = true;
                    skinController = node.controllers[i];
                  } else if (controllers[controller.skin.source]) {
                    var second = controllers[controller.skin.source];
                    morphController = second;
                    if (second.morph && geometries[second.morph.source]) {
                      var inst_geom = new InstanceGeometry();
                      inst_geom.url = second.morph.source;
                      inst_geom.instance_material = node.controllers[i].instance_material;
                      node.geometries.push(inst_geom);
                    }
                  }
                  break;
                case "morph":
                  if (geometries[controller.morph.source]) {
                    var inst_geom = new InstanceGeometry();
                    inst_geom.url = controller.morph.source;
                    inst_geom.instance_material = node.controllers[i].instance_material;
                    node.geometries.push(inst_geom);
                    morphController = node.controllers[i];
                  }
                  console.log("ColladaLoader: Morph-controller partially supported.");
                default:
                  break;
              }
            }
            var double_sided_materials = {};
            for (i = 0; i < node.geometries.length; i++) {
              var instance_geometry = node.geometries[i];
              var instance_materials = instance_geometry.instance_material;
              var geometry = geometries[instance_geometry.url];
              var used_materials = {};
              var used_materials_array = [];
              var num_materials = 0;
              var first_material;
              if (geometry) {
                if (!geometry.mesh || !geometry.mesh.primitives)
                  continue;
                if (obj.name.length === 0) {
                  obj.name = geometry.id;
                }
                if (instance_materials) {
                  for (j = 0; j < instance_materials.length; j++) {
                    var instance_material = instance_materials[j];
                    var mat = materials[instance_material.target];
                    var effect_id = mat.instance_effect.url;
                    var shader = effects[effect_id].shader;
                    var material3js = shader.material;
                    if (geometry.doubleSided) {
                      if (!(instance_material.symbol in double_sided_materials)) {
                        var _copied_material = material3js.clone();
                        _copied_material.side = THREE.DoubleSide;
                        double_sided_materials[instance_material.symbol] = _copied_material;
                      }
                      material3js = double_sided_materials[instance_material.symbol];
                    }
                    material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
                    used_materials[instance_material.symbol] = num_materials;
                    used_materials_array.push(material3js);
                    first_material = material3js;
                    first_material.name = mat.name === null || mat.name === "" ? mat.id : mat.name;
                    num_materials++;
                  }
                }
                var mesh;
                var material = first_material || new THREE.MeshLambertMaterial({ color: 14540253, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide });
                var geom = geometry.mesh.geometry3js;
                if (num_materials > 1) {
                  material = new THREE.MultiMaterial(used_materials_array);
                  for (j = 0; j < geom.faces.length; j++) {
                    var face = geom.faces[j];
                    face.materialIndex = used_materials[face.daeMaterial];
                  }
                }
                if (skinController !== void 0) {
                  applySkin(geom, skinController);
                  if (geom.morphTargets.length > 0) {
                    material.morphTargets = true;
                    material.skinning = false;
                  } else {
                    material.morphTargets = false;
                    material.skinning = true;
                  }
                  mesh = new THREE.SkinnedMesh(geom, material, false);
                  mesh.name = "skin_" + skins.length;
                  skins.push(mesh);
                } else if (morphController !== void 0) {
                  createMorph(geom, morphController);
                  material.morphTargets = true;
                  mesh = new THREE.Mesh(geom, material);
                  mesh.name = "morph_" + morphs.length;
                  morphs.push(mesh);
                } else {
                  if (geom.isLineStrip === true) {
                    mesh = new THREE.Line(geom);
                  } else {
                    mesh = new THREE.Mesh(geom, material);
                  }
                }
                obj.add(mesh);
              }
            }
            for (i = 0; i < node.cameras.length; i++) {
              var instance_camera = node.cameras[i];
              var cparams = cameras[instance_camera.url];
              var cam = new THREE.PerspectiveCamera(
                cparams.yfov,
                parseFloat(cparams.aspect_ratio),
                parseFloat(cparams.znear),
                parseFloat(cparams.zfar)
              );
              obj.add(cam);
            }
            for (i = 0; i < node.lights.length; i++) {
              var light = null;
              var instance_light = node.lights[i];
              var lparams = lights[instance_light.url];
              if (lparams && lparams.technique) {
                var color = lparams.color.getHex();
                var intensity = lparams.intensity;
                var distance = lparams.distance;
                var angle = lparams.falloff_angle;
                switch (lparams.technique) {
                  case "directional":
                    light = new THREE.DirectionalLight(color, intensity, distance);
                    light.position.set(0, 0, 1);
                    break;
                  case "point":
                    light = new THREE.PointLight(color, intensity, distance);
                    break;
                  case "spot":
                    light = new THREE.SpotLight(color, intensity, distance, angle);
                    light.position.set(0, 0, 1);
                    break;
                  case "ambient":
                    light = new THREE.AmbientLight(color);
                    break;
                }
              }
              if (light) {
                obj.add(light);
              }
            }
            obj.name = node.name || node.id || "";
            obj.colladaId = node.id || "";
            obj.layer = node.layer || "";
            obj.matrix = node.matrix;
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
            if (options.centerGeometry && obj.geometry) {
              var delta = obj.geometry.center();
              delta.multiply(obj.scale);
              delta.applyQuaternion(obj.quaternion);
              obj.position.sub(delta);
            }
            for (i = 0; i < node.nodes.length; i++) {
              obj.add(createSceneGraph(node.nodes[i], node));
            }
            return obj;
          }
          function getJointId(skin, id) {
            for (var i = 0; i < skin.joints.length; i++) {
              if (skin.joints[i] === id) {
                return i;
              }
            }
          }
          function getLibraryNode(id) {
            var nodes = COLLADA.querySelectorAll("library_nodes node");
            for (var i = 0; i < nodes.length; i++) {
              var attObj = nodes[i].attributes.getNamedItem("id");
              if (attObj && attObj.value === id) {
                return nodes[i];
              }
            }
            return void 0;
          }
          function getChannelsForNode(node) {
            var channels = [];
            var startTime = 1e6;
            var endTime = -1e6;
            for (var id in animations) {
              var animation = animations[id];
              for (var i = 0; i < animation.channel.length; i++) {
                var channel = animation.channel[i];
                var sampler = animation.sampler[i];
                var id = channel.target.split("/")[0];
                if (id == node.id) {
                  sampler.create();
                  channel.sampler = sampler;
                  startTime = Math.min(startTime, sampler.startTime);
                  endTime = Math.max(endTime, sampler.endTime);
                  channels.push(channel);
                }
              }
            }
            if (channels.length) {
              node.startTime = startTime;
              node.endTime = endTime;
            }
            return channels;
          }
          function calcFrameDuration(node) {
            var minT = 1e7;
            for (var i = 0; i < node.channels.length; i++) {
              var sampler = node.channels[i].sampler;
              for (var j = 0; j < sampler.input.length - 1; j++) {
                var t0 = sampler.input[j];
                var t1 = sampler.input[j + 1];
                minT = Math.min(minT, t1 - t0);
              }
            }
            return minT;
          }
          function calcMatrixAt(node, t) {
            var animated = {};
            var i, j;
            for (i = 0; i < node.channels.length; i++) {
              var channel = node.channels[i];
              animated[channel.sid] = channel;
            }
            var matrix = new THREE.Matrix4();
            for (i = 0; i < node.transforms.length; i++) {
              var transform = node.transforms[i];
              var channel = animated[transform.sid];
              if (channel !== void 0) {
                var sampler = channel.sampler;
                var value;
                for (j = 0; j < sampler.input.length - 1; j++) {
                  if (sampler.input[j + 1] > t) {
                    value = sampler.output[j];
                    break;
                  }
                }
                if (value !== void 0) {
                  if (value instanceof THREE.Matrix4) {
                    matrix.multiplyMatrices(matrix, value);
                  } else {
                    matrix.multiplyMatrices(matrix, transform.matrix);
                  }
                } else {
                  matrix.multiplyMatrices(matrix, transform.matrix);
                }
              } else {
                matrix.multiplyMatrices(matrix, transform.matrix);
              }
            }
            return matrix;
          }
          function bakeAnimations(node) {
            if (node.channels && node.channels.length) {
              var keys = [], sids = [];
              for (var i = 0, il = node.channels.length; i < il; i++) {
                var channel = node.channels[i], fullSid = channel.fullSid, sampler = channel.sampler, input = sampler.input, transform = node.getTransformBySid(channel.sid), member;
                if (channel.arrIndices) {
                  member = [];
                  for (var j = 0, jl = channel.arrIndices.length; j < jl; j++) {
                    member[j] = getConvertedIndex(channel.arrIndices[j]);
                  }
                } else {
                  member = getConvertedMember(channel.member);
                }
                if (transform) {
                  if (sids.indexOf(fullSid) === -1) {
                    sids.push(fullSid);
                  }
                  for (var j = 0, jl = input.length; j < jl; j++) {
                    var time = input[j], data = sampler.getData(transform.type, j, member), key = findKey(keys, time);
                    if (!key) {
                      key = new Key(time);
                      var timeNdx = findTimeNdx(keys, time);
                      keys.splice(timeNdx === -1 ? keys.length : timeNdx, 0, key);
                    }
                    key.addTarget(fullSid, transform, member, data);
                  }
                } else {
                  console.log('Could not find transform "' + channel.sid + '" in node ' + node.id);
                }
              }
              for (var i = 0; i < sids.length; i++) {
                var sid = sids[i];
                for (var j = 0; j < keys.length; j++) {
                  var key = keys[j];
                  if (!key.hasTarget(sid)) {
                    interpolateKeys(keys, key, j, sid);
                  }
                }
              }
              node.keys = keys;
              node.sids = sids;
            }
          }
          function findKey(keys, time) {
            var retVal = null;
            for (var i = 0, il = keys.length; i < il && retVal === null; i++) {
              var key = keys[i];
              if (key.time === time) {
                retVal = key;
              } else if (key.time > time) {
                break;
              }
            }
            return retVal;
          }
          function findTimeNdx(keys, time) {
            var ndx = -1;
            for (var i = 0, il = keys.length; i < il && ndx === -1; i++) {
              var key = keys[i];
              if (key.time >= time) {
                ndx = i;
              }
            }
            return ndx;
          }
          function interpolateKeys(keys, key, ndx, fullSid) {
            var prevKey = getPrevKeyWith(keys, fullSid, ndx ? ndx - 1 : 0), nextKey = getNextKeyWith(keys, fullSid, ndx + 1);
            if (prevKey && nextKey) {
              var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time), prevTarget = prevKey.getTarget(fullSid), nextData = nextKey.getTarget(fullSid).data, prevData = prevTarget.data, data;
              if (prevTarget.type === "matrix") {
                data = prevData;
              } else if (prevData.length) {
                data = [];
                for (var i = 0; i < prevData.length; ++i) {
                  data[i] = prevData[i] + (nextData[i] - prevData[i]) * scale;
                }
              } else {
                data = prevData + (nextData - prevData) * scale;
              }
              key.addTarget(fullSid, prevTarget.transform, prevTarget.member, data);
            }
          }
          function getNextKeyWith(keys, fullSid, ndx) {
            for (; ndx < keys.length; ndx++) {
              var key = keys[ndx];
              if (key.hasTarget(fullSid)) {
                return key;
              }
            }
            return null;
          }
          function getPrevKeyWith(keys, fullSid, ndx) {
            ndx = ndx >= 0 ? ndx : ndx + keys.length;
            for (; ndx >= 0; ndx--) {
              var key = keys[ndx];
              if (key.hasTarget(fullSid)) {
                return key;
              }
            }
            return null;
          }
          function _Image() {
            this.id = "";
            this.init_from = "";
          }
          _Image.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeName === "init_from") {
                this.init_from = child.textContent;
              }
            }
            return this;
          };
          function Controller() {
            this.id = "";
            this.name = "";
            this.type = "";
            this.skin = null;
            this.morph = null;
          }
          Controller.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.type = "none";
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "skin":
                  this.skin = new Skin().parse(child);
                  this.type = child.nodeName;
                  break;
                case "morph":
                  this.morph = new Morph().parse(child);
                  this.type = child.nodeName;
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Morph() {
            this.method = null;
            this.source = null;
            this.targets = null;
            this.weights = null;
          }
          Morph.prototype.parse = function(element) {
            var sources2 = {};
            var inputs = [];
            var i;
            this.method = element.getAttribute("method");
            this.source = element.getAttribute("source").replace(/^#/, "");
            for (i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "source":
                  var source = new Source().parse(child);
                  sources2[source.id] = source;
                  break;
                case "targets":
                  inputs = this.parseInputs(child);
                  break;
                default:
                  console.log(child.nodeName);
                  break;
              }
            }
            for (i = 0; i < inputs.length; i++) {
              var input = inputs[i];
              var source = sources2[input.source];
              switch (input.semantic) {
                case "MORPH_TARGET":
                  this.targets = source.read();
                  break;
                case "MORPH_WEIGHT":
                  this.weights = source.read();
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Morph.prototype.parseInputs = function(element) {
            var inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  inputs.push(new Input().parse(child));
                  break;
                default:
                  break;
              }
            }
            return inputs;
          };
          function Skin() {
            this.source = "";
            this.bindShapeMatrix = null;
            this.invBindMatrices = [];
            this.joints = [];
            this.weights = [];
          }
          Skin.prototype.parse = function(element) {
            var sources2 = {};
            var joints, weights;
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.invBindMatrices = [];
            this.joints = [];
            this.weights = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "bind_shape_matrix":
                  var f = _floats(child.textContent);
                  this.bindShapeMatrix = getConvertedMat4(f);
                  break;
                case "source":
                  var src = new Source().parse(child);
                  sources2[src.id] = src;
                  break;
                case "joints":
                  joints = child;
                  break;
                case "vertex_weights":
                  weights = child;
                  break;
                default:
                  console.log(child.nodeName);
                  break;
              }
            }
            this.parseJoints(joints, sources2);
            this.parseWeights(weights, sources2);
            return this;
          };
          Skin.prototype.parseJoints = function(element, sources2) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  var input = new Input().parse(child);
                  var source = sources2[input.source];
                  if (input.semantic === "JOINT") {
                    this.joints = source.read();
                  } else if (input.semantic === "INV_BIND_MATRIX") {
                    this.invBindMatrices = source.read();
                  }
                  break;
                default:
                  break;
              }
            }
          };
          Skin.prototype.parseWeights = function(element, sources2) {
            var v, vcount, inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  inputs.push(new Input().parse(child));
                  break;
                case "v":
                  v = _ints(child.textContent);
                  break;
                case "vcount":
                  vcount = _ints(child.textContent);
                  break;
                default:
                  break;
              }
            }
            var index = 0;
            for (var i = 0; i < vcount.length; i++) {
              var numBones = vcount[i];
              var vertex_weights = [];
              for (var j = 0; j < numBones; j++) {
                var influence = {};
                for (var k = 0; k < inputs.length; k++) {
                  var input = inputs[k];
                  var value = v[index + input.offset];
                  switch (input.semantic) {
                    case "JOINT":
                      influence.joint = value;
                      break;
                    case "WEIGHT":
                      influence.weight = sources2[input.source].data[value];
                      break;
                    default:
                      break;
                  }
                }
                vertex_weights.push(influence);
                index += inputs.length;
              }
              for (var j = 0; j < vertex_weights.length; j++) {
                vertex_weights[j].index = i;
              }
              this.weights.push(vertex_weights);
            }
          };
          function VisualScene() {
            this.id = "";
            this.name = "";
            this.nodes = [];
            this.scene = new THREE.Group();
          }
          VisualScene.prototype.getChildById = function(id, recursive) {
            for (var i = 0; i < this.nodes.length; i++) {
              var node = this.nodes[i].getChildById(id, recursive);
              if (node) {
                return node;
              }
            }
            return null;
          };
          VisualScene.prototype.getChildBySid = function(sid, recursive) {
            for (var i = 0; i < this.nodes.length; i++) {
              var node = this.nodes[i].getChildBySid(sid, recursive);
              if (node) {
                return node;
              }
            }
            return null;
          };
          VisualScene.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.nodes = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "node":
                  this.nodes.push(new Node().parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Node() {
            this.id = "";
            this.name = "";
            this.sid = "";
            this.nodes = [];
            this.controllers = [];
            this.transforms = [];
            this.geometries = [];
            this.channels = [];
            this.matrix = new THREE.Matrix4();
          }
          Node.prototype.getChannelForTransform = function(transformSid) {
            for (var i = 0; i < this.channels.length; i++) {
              var channel = this.channels[i];
              var parts = channel.target.split("/");
              var id = parts.shift();
              var sid = parts.shift();
              var dotSyntax = sid.indexOf(".") >= 0;
              var arrSyntax = sid.indexOf("(") >= 0;
              var arrIndices;
              var member;
              if (dotSyntax) {
                parts = sid.split(".");
                sid = parts.shift();
                member = parts.shift();
              } else if (arrSyntax) {
                arrIndices = sid.split("(");
                sid = arrIndices.shift();
                for (var j = 0; j < arrIndices.length; j++) {
                  arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""));
                }
              }
              if (sid === transformSid) {
                channel.info = { sid, dotSyntax, arrSyntax, arrIndices };
                return channel;
              }
            }
            return null;
          };
          Node.prototype.getChildById = function(id, recursive) {
            if (this.id === id) {
              return this;
            }
            if (recursive) {
              for (var i = 0; i < this.nodes.length; i++) {
                var n = this.nodes[i].getChildById(id, recursive);
                if (n) {
                  return n;
                }
              }
            }
            return null;
          };
          Node.prototype.getChildBySid = function(sid, recursive) {
            if (this.sid === sid) {
              return this;
            }
            if (recursive) {
              for (var i = 0; i < this.nodes.length; i++) {
                var n = this.nodes[i].getChildBySid(sid, recursive);
                if (n) {
                  return n;
                }
              }
            }
            return null;
          };
          Node.prototype.getTransformBySid = function(sid) {
            for (var i = 0; i < this.transforms.length; i++) {
              if (this.transforms[i].sid === sid)
                return this.transforms[i];
            }
            return null;
          };
          Node.prototype.parse = function(element) {
            var url;
            this.id = element.getAttribute("id");
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.type = element.getAttribute("type");
            this.layer = element.getAttribute("layer");
            this.type = this.type === "JOINT" ? this.type : "NODE";
            this.nodes = [];
            this.transforms = [];
            this.geometries = [];
            this.cameras = [];
            this.lights = [];
            this.controllers = [];
            this.matrix = new THREE.Matrix4();
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "node":
                  this.nodes.push(new Node().parse(child));
                  break;
                case "instance_camera":
                  this.cameras.push(new InstanceCamera().parse(child));
                  break;
                case "instance_controller":
                  this.controllers.push(new InstanceController().parse(child));
                  break;
                case "instance_geometry":
                  this.geometries.push(new InstanceGeometry().parse(child));
                  break;
                case "instance_light":
                  this.lights.push(new InstanceLight().parse(child));
                  break;
                case "instance_node":
                  url = child.getAttribute("url").replace(/^#/, "");
                  var iNode = getLibraryNode(url);
                  if (iNode) {
                    this.nodes.push(new Node().parse(iNode));
                  }
                  break;
                case "rotate":
                case "translate":
                case "scale":
                case "matrix":
                case "lookat":
                case "skew":
                  this.transforms.push(new Transform().parse(child));
                  break;
                case "extra":
                  break;
                default:
                  console.log(child.nodeName);
                  break;
              }
            }
            this.channels = getChannelsForNode(this);
            bakeAnimations(this);
            this.updateMatrix();
            return this;
          };
          Node.prototype.updateMatrix = function() {
            this.matrix.identity();
            for (var i = 0; i < this.transforms.length; i++) {
              this.transforms[i].apply(this.matrix);
            }
          };
          function Transform() {
            this.sid = "";
            this.type = "";
            this.data = [];
            this.obj = null;
          }
          Transform.prototype.parse = function(element) {
            this.sid = element.getAttribute("sid");
            this.type = element.nodeName;
            this.data = _floats(element.textContent);
            this.convert();
            return this;
          };
          Transform.prototype.convert = function() {
            switch (this.type) {
              case "matrix":
                this.obj = getConvertedMat4(this.data);
                break;
              case "rotate":
                this.angle = THREE.Math.degToRad(this.data[3]);
              case "translate":
                fixCoords(this.data, -1);
                this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
                break;
              case "scale":
                fixCoords(this.data, 1);
                this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
                break;
              default:
                console.log("Can not convert Transform of type " + this.type);
                break;
            }
          };
          Transform.prototype.apply = function() {
            var m1 = new THREE.Matrix4();
            return function(matrix) {
              switch (this.type) {
                case "matrix":
                  matrix.multiply(this.obj);
                  break;
                case "translate":
                  matrix.multiply(m1.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
                  break;
                case "rotate":
                  matrix.multiply(m1.makeRotationAxis(this.obj, this.angle));
                  break;
                case "scale":
                  matrix.scale(this.obj);
                  break;
              }
            };
          }();
          Transform.prototype.update = function(data, member) {
            var members = ["X", "Y", "Z", "ANGLE"];
            switch (this.type) {
              case "matrix":
                if (!member) {
                  this.obj.copy(data);
                } else if (member.length === 1) {
                  switch (member[0]) {
                    case 0:
                      this.obj.n11 = data[0];
                      this.obj.n21 = data[1];
                      this.obj.n31 = data[2];
                      this.obj.n41 = data[3];
                      break;
                    case 1:
                      this.obj.n12 = data[0];
                      this.obj.n22 = data[1];
                      this.obj.n32 = data[2];
                      this.obj.n42 = data[3];
                      break;
                    case 2:
                      this.obj.n13 = data[0];
                      this.obj.n23 = data[1];
                      this.obj.n33 = data[2];
                      this.obj.n43 = data[3];
                      break;
                    case 3:
                      this.obj.n14 = data[0];
                      this.obj.n24 = data[1];
                      this.obj.n34 = data[2];
                      this.obj.n44 = data[3];
                      break;
                  }
                } else if (member.length === 2) {
                  var propName = "n" + (member[0] + 1) + (member[1] + 1);
                  this.obj[propName] = data;
                } else {
                  console.log("Incorrect addressing of matrix in transform.");
                }
                break;
              case "translate":
              case "scale":
                if (Object.prototype.toString.call(member) === "[object Array]") {
                  member = members[member[0]];
                }
                switch (member) {
                  case "X":
                    this.obj.x = data;
                    break;
                  case "Y":
                    this.obj.y = data;
                    break;
                  case "Z":
                    this.obj.z = data;
                    break;
                  default:
                    this.obj.x = data[0];
                    this.obj.y = data[1];
                    this.obj.z = data[2];
                    break;
                }
                break;
              case "rotate":
                if (Object.prototype.toString.call(member) === "[object Array]") {
                  member = members[member[0]];
                }
                switch (member) {
                  case "X":
                    this.obj.x = data;
                    break;
                  case "Y":
                    this.obj.y = data;
                    break;
                  case "Z":
                    this.obj.z = data;
                    break;
                  case "ANGLE":
                    this.angle = THREE.Math.degToRad(data);
                    break;
                  default:
                    this.obj.x = data[0];
                    this.obj.y = data[1];
                    this.obj.z = data[2];
                    this.angle = THREE.Math.degToRad(data[3]);
                    break;
                }
                break;
            }
          };
          function InstanceController() {
            this.url = "";
            this.skeleton = [];
            this.instance_material = [];
          }
          InstanceController.prototype.parse = function(element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            this.skeleton = [];
            this.instance_material = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "skeleton":
                  this.skeleton.push(child.textContent.replace(/^#/, ""));
                  break;
                case "bind_material":
                  var instances = child.querySelectorAll("instance_material");
                  for (var j = 0; j < instances.length; j++) {
                    var instance = instances[j];
                    this.instance_material.push(new InstanceMaterial().parse(instance));
                  }
                  break;
                case "extra":
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function InstanceMaterial() {
            this.symbol = "";
            this.target = "";
          }
          InstanceMaterial.prototype.parse = function(element) {
            this.symbol = element.getAttribute("symbol");
            this.target = element.getAttribute("target").replace(/^#/, "");
            return this;
          };
          function InstanceGeometry() {
            this.url = "";
            this.instance_material = [];
          }
          InstanceGeometry.prototype.parse = function(element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            this.instance_material = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              if (child.nodeName === "bind_material") {
                var instances = child.querySelectorAll("instance_material");
                for (var j = 0; j < instances.length; j++) {
                  var instance = instances[j];
                  this.instance_material.push(new InstanceMaterial().parse(instance));
                }
                break;
              }
            }
            return this;
          };
          function Geometry() {
            this.id = "";
            this.mesh = null;
          }
          Geometry.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            extractDoubleSided(this, element);
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "mesh":
                  this.mesh = new Mesh(this).parse(child);
                  break;
                case "extra":
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Mesh(geometry) {
            this.geometry = geometry.id;
            this.primitives = [];
            this.vertices = null;
            this.geometry3js = null;
          }
          Mesh.prototype.parse = function(element) {
            this.primitives = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "source":
                  _source(child);
                  break;
                case "vertices":
                  this.vertices = new Vertices().parse(child);
                  break;
                case "linestrips":
                  this.primitives.push(new LineStrips().parse(child));
                  break;
                case "triangles":
                  this.primitives.push(new Triangles().parse(child));
                  break;
                case "polygons":
                  this.primitives.push(new Polygons().parse(child));
                  break;
                case "polylist":
                  this.primitives.push(new Polylist().parse(child));
                  break;
                default:
                  break;
              }
            }
            this.geometry3js = new THREE.Geometry();
            if (this.vertices === null) {
              return this;
            }
            var vertexData = sources[this.vertices.input["POSITION"].source].data;
            for (var i = 0; i < vertexData.length; i += 3) {
              this.geometry3js.vertices.push(getConvertedVec3(vertexData, i).clone());
            }
            for (var i = 0; i < this.primitives.length; i++) {
              var primitive = this.primitives[i];
              primitive.setVertices(this.vertices);
              this.handlePrimitive(primitive, this.geometry3js);
            }
            if (this.geometry3js.calcNormals) {
              this.geometry3js.computeVertexNormals();
              delete this.geometry3js.calcNormals;
            }
            return this;
          };
          Mesh.prototype.handlePrimitive = function(primitive, geom) {
            if (primitive instanceof LineStrips) {
              geom.isLineStrip = true;
              return;
            }
            var j, k, pList = primitive.p, inputs = primitive.inputs;
            var input, index, idx32;
            var source, numParams;
            var vcIndex = 0, vcount = 3, maxOffset = 0;
            var texture_sets = [];
            for (j = 0; j < inputs.length; j++) {
              input = inputs[j];
              var offset = input.offset + 1;
              maxOffset = maxOffset < offset ? offset : maxOffset;
              switch (input.semantic) {
                case "TEXCOORD":
                  texture_sets.push(input.set);
                  break;
              }
            }
            for (var pCount = 0; pCount < pList.length; ++pCount) {
              var p = pList[pCount], i = 0;
              while (i < p.length) {
                var vs = [];
                var ns = [];
                var ts = null;
                var cs = [];
                if (primitive.vcount) {
                  vcount = primitive.vcount.length ? primitive.vcount[vcIndex++] : primitive.vcount;
                } else {
                  vcount = p.length / maxOffset;
                }
                for (j = 0; j < vcount; j++) {
                  for (k = 0; k < inputs.length; k++) {
                    input = inputs[k];
                    source = sources[input.source];
                    index = p[i + j * maxOffset + input.offset];
                    numParams = source.accessor.params.length;
                    idx32 = index * numParams;
                    switch (input.semantic) {
                      case "VERTEX":
                        vs.push(index);
                        break;
                      case "NORMAL":
                        ns.push(getConvertedVec3(source.data, idx32));
                        break;
                      case "TEXCOORD":
                        ts = ts || {};
                        if (ts[input.set] === void 0)
                          ts[input.set] = [];
                        ts[input.set].push(new THREE.Vector2(source.data[idx32], source.data[idx32 + 1]));
                        break;
                      case "COLOR":
                        cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                        break;
                      default:
                        break;
                    }
                  }
                }
                if (ns.length === 0) {
                  input = this.vertices.input.NORMAL;
                  if (input) {
                    source = sources[input.source];
                    numParams = source.accessor.params.length;
                    for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                      ns.push(getConvertedVec3(source.data, vs[ndx] * numParams));
                    }
                  } else {
                    geom.calcNormals = true;
                  }
                }
                if (!ts) {
                  ts = {};
                  input = this.vertices.input.TEXCOORD;
                  if (input) {
                    texture_sets.push(input.set);
                    source = sources[input.source];
                    numParams = source.accessor.params.length;
                    for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                      idx32 = vs[ndx] * numParams;
                      if (ts[input.set] === void 0)
                        ts[input.set] = [];
                      ts[input.set].push(new THREE.Vector2(source.data[idx32], 1 - source.data[idx32 + 1]));
                    }
                  }
                }
                if (cs.length === 0) {
                  input = this.vertices.input.COLOR;
                  if (input) {
                    source = sources[input.source];
                    numParams = source.accessor.params.length;
                    for (var ndx = 0, len = vs.length; ndx < len; ndx++) {
                      idx32 = vs[ndx] * numParams;
                      cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                    }
                  }
                }
                var face = null, faces = [], uv, uvArr;
                if (vcount === 3) {
                  faces.push(new THREE.Face3(vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color()));
                } else if (vcount === 4) {
                  faces.push(new THREE.Face3(vs[0], vs[1], vs[3], ns.length ? [ns[0].clone(), ns[1].clone(), ns[3].clone()] : [], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color()));
                  faces.push(new THREE.Face3(vs[1], vs[2], vs[3], ns.length ? [ns[1].clone(), ns[2].clone(), ns[3].clone()] : [], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color()));
                } else if (vcount > 4 && options.subdivideFaces) {
                  var clr = cs.length ? cs : new THREE.Color(), vec1, vec2, vec3, v1, v2, norm;
                  for (k = 1; k < vcount - 1; ) {
                    faces.push(new THREE.Face3(vs[0], vs[k], vs[k + 1], ns.length ? [ns[0].clone(), ns[k++].clone(), ns[k].clone()] : [], clr));
                  }
                }
                if (faces.length) {
                  for (var ndx = 0, len = faces.length; ndx < len; ndx++) {
                    face = faces[ndx];
                    face.daeMaterial = primitive.material;
                    geom.faces.push(face);
                    for (k = 0; k < texture_sets.length; k++) {
                      uv = ts[texture_sets[k]];
                      if (vcount > 4) {
                        uvArr = [uv[0], uv[ndx + 1], uv[ndx + 2]];
                      } else if (vcount === 4) {
                        if (ndx === 0) {
                          uvArr = [uv[0], uv[1], uv[3]];
                        } else {
                          uvArr = [uv[1].clone(), uv[2], uv[3].clone()];
                        }
                      } else {
                        uvArr = [uv[0], uv[1], uv[2]];
                      }
                      if (geom.faceVertexUvs[k] === void 0) {
                        geom.faceVertexUvs[k] = [];
                      }
                      geom.faceVertexUvs[k].push(uvArr);
                    }
                  }
                } else {
                  console.log("dropped face with vcount " + vcount + " for geometry with id: " + geom.id);
                }
                i += maxOffset * vcount;
              }
            }
          };
          function Polygons() {
            this.material = "";
            this.count = 0;
            this.inputs = [];
            this.vcount = null;
            this.p = [];
            this.geometry = new THREE.Geometry();
          }
          Polygons.prototype.setVertices = function(vertices) {
            for (var i = 0; i < this.inputs.length; i++) {
              if (this.inputs[i].source === vertices.id) {
                this.inputs[i].source = vertices.input["POSITION"].source;
              }
            }
          };
          Polygons.prototype.parse = function(element) {
            this.material = element.getAttribute("material");
            this.count = _attr_as_int(element, "count", 0);
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "input":
                  this.inputs.push(new Input().parse(element.childNodes[i]));
                  break;
                case "vcount":
                  this.vcount = _ints(child.textContent);
                  break;
                case "p":
                  this.p.push(_ints(child.textContent));
                  break;
                case "ph":
                  console.warn("polygon holes not yet supported!");
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Polylist() {
            Polygons.call(this);
            this.vcount = [];
          }
          Polylist.prototype = Object.create(Polygons.prototype);
          Polylist.prototype.constructor = Polylist;
          function LineStrips() {
            Polygons.call(this);
            this.vcount = 1;
          }
          LineStrips.prototype = Object.create(Polygons.prototype);
          LineStrips.prototype.constructor = LineStrips;
          function Triangles() {
            Polygons.call(this);
            this.vcount = 3;
          }
          Triangles.prototype = Object.create(Polygons.prototype);
          Triangles.prototype.constructor = Triangles;
          function Accessor() {
            this.source = "";
            this.count = 0;
            this.stride = 0;
            this.params = [];
          }
          Accessor.prototype.parse = function(element) {
            this.params = [];
            this.source = element.getAttribute("source");
            this.count = _attr_as_int(element, "count", 0);
            this.stride = _attr_as_int(element, "stride", 0);
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeName === "param") {
                var param = {};
                param["name"] = child.getAttribute("name");
                param["type"] = child.getAttribute("type");
                this.params.push(param);
              }
            }
            return this;
          };
          function Vertices() {
            this.input = {};
          }
          Vertices.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
              if (element.childNodes[i].nodeName === "input") {
                var input = new Input().parse(element.childNodes[i]);
                this.input[input.semantic] = input;
              }
            }
            return this;
          };
          function Input() {
            this.semantic = "";
            this.offset = 0;
            this.source = "";
            this.set = 0;
          }
          Input.prototype.parse = function(element) {
            this.semantic = element.getAttribute("semantic");
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.set = _attr_as_int(element, "set", -1);
            this.offset = _attr_as_int(element, "offset", 0);
            if (this.semantic === "TEXCOORD" && this.set < 0) {
              this.set = 0;
            }
            return this;
          };
          function Source(id) {
            this.id = id;
            this.type = null;
          }
          Source.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "bool_array":
                  this.data = _bools(child.textContent);
                  this.type = child.nodeName;
                  break;
                case "float_array":
                  this.data = _floats(child.textContent);
                  this.type = child.nodeName;
                  break;
                case "int_array":
                  this.data = _ints(child.textContent);
                  this.type = child.nodeName;
                  break;
                case "IDREF_array":
                case "Name_array":
                  this.data = _strings(child.textContent);
                  this.type = child.nodeName;
                  break;
                case "technique_common":
                  for (var j = 0; j < child.childNodes.length; j++) {
                    if (child.childNodes[j].nodeName === "accessor") {
                      this.accessor = new Accessor().parse(child.childNodes[j]);
                      break;
                    }
                  }
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Source.prototype.read = function() {
            var result = [];
            var param = this.accessor.params[0];
            switch (param.type) {
              case "IDREF":
              case "Name":
              case "name":
              case "float":
                return this.data;
              case "float4x4":
                for (var j = 0; j < this.data.length; j += 16) {
                  var s = this.data.slice(j, j + 16);
                  var m = getConvertedMat4(s);
                  result.push(m);
                }
                break;
              default:
                console.log("ColladaLoader: Source: Read dont know how to read " + param.type + ".");
                break;
            }
            return result;
          };
          function Material() {
            this.id = "";
            this.name = "";
            this.instance_effect = null;
          }
          Material.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
              if (element.childNodes[i].nodeName === "instance_effect") {
                this.instance_effect = new InstanceEffect().parse(element.childNodes[i]);
                break;
              }
            }
            return this;
          };
          function ColorOrTexture() {
            this.color = new THREE.Color();
            this.color.setRGB(Math.random(), Math.random(), Math.random());
            this.color.a = 1;
            this.texture = null;
            this.texcoord = null;
            this.texOpts = null;
          }
          ColorOrTexture.prototype.isColor = function() {
            return this.texture === null;
          };
          ColorOrTexture.prototype.isTexture = function() {
            return this.texture != null;
          };
          ColorOrTexture.prototype.parse = function(element) {
            if (element.nodeName === "transparent") {
              this.opaque = element.getAttribute("opaque");
            }
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "color":
                  var rgba = _floats(child.textContent);
                  this.color = new THREE.Color();
                  this.color.setRGB(rgba[0], rgba[1], rgba[2]);
                  this.color.a = rgba[3];
                  break;
                case "texture":
                  this.texture = child.getAttribute("texture");
                  this.texcoord = child.getAttribute("texcoord");
                  this.texOpts = {
                    offsetU: 0,
                    offsetV: 0,
                    repeatU: 1,
                    repeatV: 1,
                    wrapU: 1,
                    wrapV: 1
                  };
                  this.parseTexture(child);
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          ColorOrTexture.prototype.parseTexture = function(element) {
            if (!element.childNodes)
              return this;
            if (element.childNodes[1] && element.childNodes[1].nodeName === "extra") {
              element = element.childNodes[1];
              if (element.childNodes[1] && element.childNodes[1].nodeName === "technique") {
                element = element.childNodes[1];
              }
            }
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "offsetU":
                case "offsetV":
                case "repeatU":
                case "repeatV":
                  this.texOpts[child.nodeName] = parseFloat(child.textContent);
                  break;
                case "wrapU":
                case "wrapV":
                  if (child.textContent.toUpperCase() === "TRUE") {
                    this.texOpts[child.nodeName] = 1;
                  } else {
                    this.texOpts[child.nodeName] = parseInt(child.textContent);
                  }
                  break;
                default:
                  this.texOpts[child.nodeName] = child.textContent;
                  break;
              }
            }
            return this;
          };
          function Shader(type, effect) {
            this.type = type;
            this.effect = effect;
            this.material = null;
          }
          Shader.prototype.parse = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "emission":
                case "diffuse":
                case "specular":
                case "transparent":
                  this[child.nodeName] = new ColorOrTexture().parse(child);
                  break;
                case "bump":
                  var bumpType = child.getAttribute("bumptype");
                  if (bumpType) {
                    if (bumpType.toLowerCase() === "heightfield") {
                      this["bump"] = new ColorOrTexture().parse(child);
                    } else if (bumpType.toLowerCase() === "normalmap") {
                      this["normal"] = new ColorOrTexture().parse(child);
                    } else {
                      console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'");
                      this["bump"] = new ColorOrTexture().parse(child);
                    }
                  } else {
                    console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'");
                    this["bump"] = new ColorOrTexture().parse(child);
                  }
                  break;
                case "shininess":
                case "reflectivity":
                case "index_of_refraction":
                case "transparency":
                  var f = child.querySelectorAll("float");
                  if (f.length > 0)
                    this[child.nodeName] = parseFloat(f[0].textContent);
                  break;
                default:
                  break;
              }
            }
            this.create();
            return this;
          };
          Shader.prototype.create = function() {
            var props = {};
            var transparent = false;
            if (this["transparency"] !== void 0 && this["transparent"] !== void 0) {
              var transparentColor = this["transparent"];
              var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;
              if (transparencyLevel > 0) {
                transparent = true;
                props["transparent"] = true;
                props["opacity"] = 1 - transparencyLevel;
              }
            }
            var keys = {
              "diffuse": "map",
              "ambient": "lightMap",
              "specular": "specularMap",
              "emission": "emissionMap",
              "bump": "bumpMap",
              "normal": "normalMap"
            };
            for (var prop in this) {
              switch (prop) {
                case "ambient":
                case "emission":
                case "diffuse":
                case "specular":
                case "bump":
                case "normal":
                  var cot = this[prop];
                  if (cot instanceof ColorOrTexture) {
                    if (cot.isTexture()) {
                      var samplerId = cot.texture;
                      var surfaceId = this.effect.sampler[samplerId];
                      if (surfaceId !== void 0 && surfaceId.source !== void 0) {
                        var surface = this.effect.surface[surfaceId.source];
                        if (surface !== void 0) {
                          var image = images[surface.init_from];
                          if (image) {
                            var url = baseUrl + image.init_from;
                            var texture;
                            var loader = THREE.Loader.Handlers.get(url);
                            if (loader !== null) {
                              texture = loader.load(url);
                            } else {
                              texture = new THREE.Texture();
                              loadTextureImage(texture, url);
                            }
                            texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                            texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                            texture.offset.x = cot.texOpts.offsetU;
                            texture.offset.y = cot.texOpts.offsetV;
                            texture.repeat.x = cot.texOpts.repeatU;
                            texture.repeat.y = cot.texOpts.repeatV;
                            props[keys[prop]] = texture;
                            if (prop === "emission")
                              props["emissive"] = 16777215;
                          }
                        }
                      }
                    } else if (prop === "diffuse" || !transparent) {
                      if (prop === "emission") {
                        props["emissive"] = cot.color.getHex();
                      } else {
                        props[prop] = cot.color.getHex();
                      }
                    }
                  }
                  break;
                case "shininess":
                  props[prop] = this[prop];
                  break;
                case "reflectivity":
                  props[prop] = this[prop];
                  if (props[prop] > 0)
                    props["envMap"] = options.defaultEnvMap;
                  props["combine"] = THREE.MixOperation;
                  break;
                case "index_of_refraction":
                  props["refractionRatio"] = this[prop];
                  if (this[prop] !== 1)
                    props["envMap"] = options.defaultEnvMap;
                  break;
                case "transparency":
                  break;
                default:
                  break;
              }
            }
            props["shading"] = preferredShading;
            props["side"] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
            if (props.diffuse !== void 0) {
              props.color = props.diffuse;
              delete props.diffuse;
            }
            switch (this.type) {
              case "constant":
                if (props.emissive != void 0)
                  props.color = props.emissive;
                this.material = new THREE.MeshBasicMaterial(props);
                break;
              case "phong":
              case "blinn":
                this.material = new THREE.MeshPhongMaterial(props);
                break;
              case "lambert":
              default:
                this.material = new THREE.MeshLambertMaterial(props);
                break;
            }
            return this.material;
          };
          function Surface(effect) {
            this.effect = effect;
            this.init_from = null;
            this.format = null;
          }
          Surface.prototype.parse = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "init_from":
                  this.init_from = child.textContent;
                  break;
                case "format":
                  this.format = child.textContent;
                  break;
                default:
                  console.log("unhandled Surface prop: " + child.nodeName);
                  break;
              }
            }
            return this;
          };
          function Sampler2D(effect) {
            this.effect = effect;
            this.source = null;
            this.wrap_s = null;
            this.wrap_t = null;
            this.minfilter = null;
            this.magfilter = null;
            this.mipfilter = null;
          }
          Sampler2D.prototype.parse = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "source":
                  this.source = child.textContent;
                  break;
                case "minfilter":
                  this.minfilter = child.textContent;
                  break;
                case "magfilter":
                  this.magfilter = child.textContent;
                  break;
                case "mipfilter":
                  this.mipfilter = child.textContent;
                  break;
                case "wrap_s":
                  this.wrap_s = child.textContent;
                  break;
                case "wrap_t":
                  this.wrap_t = child.textContent;
                  break;
                default:
                  console.log("unhandled Sampler2D prop: " + child.nodeName);
                  break;
              }
            }
            return this;
          };
          function Effect() {
            this.id = "";
            this.name = "";
            this.shader = null;
            this.surface = {};
            this.sampler = {};
          }
          Effect.prototype.create = function() {
            if (this.shader === null) {
              return null;
            }
          };
          Effect.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            extractDoubleSided(this, element);
            this.shader = null;
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "profile_COMMON":
                  this.parseTechnique(this.parseProfileCOMMON(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Effect.prototype.parseNewparam = function(element) {
            var sid = element.getAttribute("sid");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "surface":
                  this.surface[sid] = new Surface(this).parse(child);
                  break;
                case "sampler2D":
                  this.sampler[sid] = new Sampler2D(this).parse(child);
                  break;
                case "extra":
                  break;
                default:
                  console.log(child.nodeName);
                  break;
              }
            }
          };
          Effect.prototype.parseProfileCOMMON = function(element) {
            var technique;
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "profile_COMMON":
                  this.parseProfileCOMMON(child);
                  break;
                case "technique":
                  technique = child;
                  break;
                case "newparam":
                  this.parseNewparam(child);
                  break;
                case "image":
                  var _image = new _Image().parse(child);
                  images[_image.id] = _image;
                  break;
                case "extra":
                  break;
                default:
                  console.log(child.nodeName);
                  break;
              }
            }
            return technique;
          };
          Effect.prototype.parseTechnique = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "constant":
                case "lambert":
                case "blinn":
                case "phong":
                  this.shader = new Shader(child.nodeName, this).parse(child);
                  break;
                case "extra":
                  this.parseExtra(child);
                  break;
                default:
                  break;
              }
            }
          };
          Effect.prototype.parseExtra = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "technique":
                  this.parseExtraTechnique(child);
                  break;
                default:
                  break;
              }
            }
          };
          Effect.prototype.parseExtraTechnique = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "bump":
                  this.shader.parse(element);
                  break;
                default:
                  break;
              }
            }
          };
          function InstanceEffect() {
            this.url = "";
          }
          InstanceEffect.prototype.parse = function(element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
          };
          function Animation() {
            this.id = "";
            this.name = "";
            this.source = {};
            this.sampler = [];
            this.channel = [];
          }
          Animation.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.source = {};
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "animation":
                  var anim = new Animation().parse(child);
                  for (var src in anim.source) {
                    this.source[src] = anim.source[src];
                  }
                  for (var j = 0; j < anim.channel.length; j++) {
                    this.channel.push(anim.channel[j]);
                    this.sampler.push(anim.sampler[j]);
                  }
                  break;
                case "source":
                  var src = new Source().parse(child);
                  this.source[src.id] = src;
                  break;
                case "sampler":
                  this.sampler.push(new Sampler(this).parse(child));
                  break;
                case "channel":
                  this.channel.push(new Channel(this).parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Channel(animation) {
            this.animation = animation;
            this.source = "";
            this.target = "";
            this.fullSid = null;
            this.sid = null;
            this.dotSyntax = null;
            this.arrSyntax = null;
            this.arrIndices = null;
            this.member = null;
          }
          Channel.prototype.parse = function(element) {
            this.source = element.getAttribute("source").replace(/^#/, "");
            this.target = element.getAttribute("target");
            var parts = this.target.split("/");
            var id = parts.shift();
            var sid = parts.shift();
            var dotSyntax = sid.indexOf(".") >= 0;
            var arrSyntax = sid.indexOf("(") >= 0;
            if (dotSyntax) {
              parts = sid.split(".");
              this.sid = parts.shift();
              this.member = parts.shift();
            } else if (arrSyntax) {
              var arrIndices = sid.split("(");
              this.sid = arrIndices.shift();
              for (var j = 0; j < arrIndices.length; j++) {
                arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ""));
              }
              this.arrIndices = arrIndices;
            } else {
              this.sid = sid;
            }
            this.fullSid = sid;
            this.dotSyntax = dotSyntax;
            this.arrSyntax = arrSyntax;
            return this;
          };
          function Sampler(animation) {
            this.id = "";
            this.animation = animation;
            this.inputs = [];
            this.input = null;
            this.output = null;
            this.strideOut = null;
            this.interpolation = null;
            this.startTime = null;
            this.endTime = null;
            this.duration = 0;
          }
          Sampler.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.inputs = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  this.inputs.push(new Input().parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Sampler.prototype.create = function() {
            for (var i = 0; i < this.inputs.length; i++) {
              var input = this.inputs[i];
              var source = this.animation.source[input.source];
              switch (input.semantic) {
                case "INPUT":
                  this.input = source.read();
                  break;
                case "OUTPUT":
                  this.output = source.read();
                  this.strideOut = source.accessor.stride;
                  break;
                case "INTERPOLATION":
                  this.interpolation = source.read();
                  break;
                case "IN_TANGENT":
                  break;
                case "OUT_TANGENT":
                  break;
                default:
                  console.log(input.semantic);
                  break;
              }
            }
            this.startTime = 0;
            this.endTime = 0;
            this.duration = 0;
            if (this.input.length) {
              this.startTime = 1e8;
              this.endTime = -1e8;
              for (var i = 0; i < this.input.length; i++) {
                this.startTime = Math.min(this.startTime, this.input[i]);
                this.endTime = Math.max(this.endTime, this.input[i]);
              }
              this.duration = this.endTime - this.startTime;
            }
          };
          Sampler.prototype.getData = function(type, ndx, member) {
            var data;
            if (type === "matrix" && this.strideOut === 16) {
              data = this.output[ndx];
            } else if (this.strideOut > 1) {
              data = [];
              ndx *= this.strideOut;
              for (var i = 0; i < this.strideOut; ++i) {
                data[i] = this.output[ndx + i];
              }
              if (this.strideOut === 3) {
                switch (type) {
                  case "rotate":
                  case "translate":
                    fixCoords(data, -1);
                    break;
                  case "scale":
                    fixCoords(data, 1);
                    break;
                }
              } else if (this.strideOut === 4 && type === "matrix") {
                fixCoords(data, -1);
              }
            } else {
              data = this.output[ndx];
              if (member && type === "translate") {
                data = getConvertedTranslation(member, data);
              }
            }
            return data;
          };
          function Key(time) {
            this.targets = [];
            this.time = time;
          }
          Key.prototype.addTarget = function(fullSid, transform, member, data) {
            this.targets.push({
              sid: fullSid,
              member,
              transform,
              data
            });
          };
          Key.prototype.apply = function(opt_sid) {
            for (var i = 0; i < this.targets.length; ++i) {
              var target = this.targets[i];
              if (!opt_sid || target.sid === opt_sid) {
                target.transform.update(target.data, target.member);
              }
            }
          };
          Key.prototype.getTarget = function(fullSid) {
            for (var i = 0; i < this.targets.length; ++i) {
              if (this.targets[i].sid === fullSid) {
                return this.targets[i];
              }
            }
            return null;
          };
          Key.prototype.hasTarget = function(fullSid) {
            for (var i = 0; i < this.targets.length; ++i) {
              if (this.targets[i].sid === fullSid) {
                return true;
              }
            }
            return false;
          };
          Key.prototype.interpolate = function(nextKey, time) {
            for (var i = 0, l = this.targets.length; i < l; i++) {
              var target = this.targets[i], nextTarget = nextKey.getTarget(target.sid), data;
              if (target.transform.type !== "matrix" && nextTarget) {
                var scale = (time - this.time) / (nextKey.time - this.time), nextData = nextTarget.data, prevData = target.data;
                if (scale < 0)
                  scale = 0;
                if (scale > 1)
                  scale = 1;
                if (prevData.length) {
                  data = [];
                  for (var j = 0; j < prevData.length; ++j) {
                    data[j] = prevData[j] + (nextData[j] - prevData[j]) * scale;
                  }
                } else {
                  data = prevData + (nextData - prevData) * scale;
                }
              } else {
                data = target.data;
              }
              target.transform.update(data, target.member);
            }
          };
          function Camera() {
            this.id = "";
            this.name = "";
            this.technique = "";
          }
          Camera.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "optics":
                  this.parseOptics(child);
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Camera.prototype.parseOptics = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              if (element.childNodes[i].nodeName === "technique_common") {
                var technique = element.childNodes[i];
                for (var j = 0; j < technique.childNodes.length; j++) {
                  this.technique = technique.childNodes[j].nodeName;
                  if (this.technique === "perspective") {
                    var perspective = technique.childNodes[j];
                    for (var k = 0; k < perspective.childNodes.length; k++) {
                      var param = perspective.childNodes[k];
                      switch (param.nodeName) {
                        case "yfov":
                          this.yfov = param.textContent;
                          break;
                        case "xfov":
                          this.xfov = param.textContent;
                          break;
                        case "znear":
                          this.znear = param.textContent;
                          break;
                        case "zfar":
                          this.zfar = param.textContent;
                          break;
                        case "aspect_ratio":
                          this.aspect_ratio = param.textContent;
                          break;
                      }
                    }
                  } else if (this.technique === "orthographic") {
                    var orthographic = technique.childNodes[j];
                    for (var k = 0; k < orthographic.childNodes.length; k++) {
                      var param = orthographic.childNodes[k];
                      switch (param.nodeName) {
                        case "xmag":
                          this.xmag = param.textContent;
                          break;
                        case "ymag":
                          this.ymag = param.textContent;
                          break;
                        case "znear":
                          this.znear = param.textContent;
                          break;
                        case "zfar":
                          this.zfar = param.textContent;
                          break;
                        case "aspect_ratio":
                          this.aspect_ratio = param.textContent;
                          break;
                      }
                    }
                  }
                }
              }
            }
            return this;
          };
          function InstanceCamera() {
            this.url = "";
          }
          InstanceCamera.prototype.parse = function(element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
          };
          function Light() {
            this.id = "";
            this.name = "";
            this.technique = "";
          }
          Light.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "technique_common":
                  this.parseCommon(child);
                  break;
                case "technique":
                  this.parseTechnique(child);
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          Light.prototype.parseCommon = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              switch (element.childNodes[i].nodeName) {
                case "directional":
                case "point":
                case "spot":
                case "ambient":
                  this.technique = element.childNodes[i].nodeName;
                  var light = element.childNodes[i];
                  for (var j = 0; j < light.childNodes.length; j++) {
                    var child = light.childNodes[j];
                    switch (child.nodeName) {
                      case "color":
                        var rgba = _floats(child.textContent);
                        this.color = new THREE.Color(0);
                        this.color.setRGB(rgba[0], rgba[1], rgba[2]);
                        this.color.a = rgba[3];
                        break;
                      case "falloff_angle":
                        this.falloff_angle = parseFloat(child.textContent);
                        break;
                      case "quadratic_attenuation":
                        var f = parseFloat(child.textContent);
                        this.distance = f ? Math.sqrt(1 / f) : 0;
                    }
                  }
              }
            }
            return this;
          };
          Light.prototype.parseTechnique = function(element) {
            this.profile = element.getAttribute("profile");
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case "intensity":
                  this.intensity = parseFloat(child.textContent);
                  break;
              }
            }
            return this;
          };
          function InstanceLight() {
            this.url = "";
          }
          InstanceLight.prototype.parse = function(element) {
            this.url = element.getAttribute("url").replace(/^#/, "");
            return this;
          };
          function KinematicsModel() {
            this.id = "";
            this.name = "";
            this.joints = [];
            this.links = [];
          }
          KinematicsModel.prototype.parse = function(element) {
            this.id = element.getAttribute("id");
            this.name = element.getAttribute("name");
            this.joints = [];
            this.links = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "technique_common":
                  this.parseCommon(child);
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          KinematicsModel.prototype.parseCommon = function(element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (element.childNodes[i].nodeName) {
                case "joint":
                  this.joints.push(new Joint().parse(child));
                  break;
                case "link":
                  this.links.push(new Link().parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Joint() {
            this.sid = "";
            this.name = "";
            this.axis = new THREE.Vector3();
            this.limits = {
              min: 0,
              max: 0
            };
            this.type = "";
            this.static = false;
            this.zeroPosition = 0;
            this.middlePosition = 0;
          }
          Joint.prototype.parse = function(element) {
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.axis = new THREE.Vector3();
            this.limits = {
              min: 0,
              max: 0
            };
            this.type = "";
            this.static = false;
            this.zeroPosition = 0;
            this.middlePosition = 0;
            var axisElement = element.querySelector("axis");
            var _axis = _floats(axisElement.textContent);
            this.axis = getConvertedVec3(_axis, 0);
            var min = element.querySelector("limits min") ? parseFloat(element.querySelector("limits min").textContent) : -360;
            var max = element.querySelector("limits max") ? parseFloat(element.querySelector("limits max").textContent) : 360;
            this.limits = {
              min,
              max
            };
            var jointTypes = ["prismatic", "revolute"];
            for (var i = 0; i < jointTypes.length; i++) {
              var type = jointTypes[i];
              var jointElement = element.querySelector(type);
              if (jointElement) {
                this.type = type;
              }
            }
            if (this.limits.min >= this.limits.max) {
              this.static = true;
            }
            this.middlePosition = (this.limits.min + this.limits.max) / 2;
            return this;
          };
          function Link() {
            this.sid = "";
            this.name = "";
            this.transforms = [];
            this.attachments = [];
          }
          Link.prototype.parse = function(element) {
            this.sid = element.getAttribute("sid");
            this.name = element.getAttribute("name");
            this.transforms = [];
            this.attachments = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "attachment_full":
                  this.attachments.push(new Attachment().parse(child));
                  break;
                case "rotate":
                case "translate":
                case "matrix":
                  this.transforms.push(new Transform().parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function Attachment() {
            this.joint = "";
            this.transforms = [];
            this.links = [];
          }
          Attachment.prototype.parse = function(element) {
            this.joint = element.getAttribute("joint").split("/").pop();
            this.links = [];
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case "link":
                  this.links.push(new Link().parse(child));
                  break;
                case "rotate":
                case "translate":
                case "matrix":
                  this.transforms.push(new Transform().parse(child));
                  break;
                default:
                  break;
              }
            }
            return this;
          };
          function _source(element) {
            var id = element.getAttribute("id");
            if (sources[id] != void 0) {
              return sources[id];
            }
            sources[id] = new Source(id).parse(element);
            return sources[id];
          }
          function _nsResolver(nsPrefix) {
            if (nsPrefix === "dae") {
              return "http://www.collada.org/2005/11/COLLADASchema";
            }
            return null;
          }
          function _bools(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
              data.push(raw[i] === "true" || raw[i] === "1" ? true : false);
            }
            return data;
          }
          function _floats(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
              data.push(parseFloat(raw[i]));
            }
            return data;
          }
          function _ints(str) {
            var raw = _strings(str);
            var data = [];
            for (var i = 0, l = raw.length; i < l; i++) {
              data.push(parseInt(raw[i], 10));
            }
            return data;
          }
          function _strings(str) {
            return str.length > 0 ? _trimString(str).split(/\s+/) : [];
          }
          function _trimString(str) {
            return str.replace(/^\s+/, "").replace(/\s+$/, "");
          }
          function _attr_as_float(element, name, defaultValue) {
            if (element.hasAttribute(name)) {
              return parseFloat(element.getAttribute(name));
            } else {
              return defaultValue;
            }
          }
          function _attr_as_int(element, name, defaultValue) {
            if (element.hasAttribute(name)) {
              return parseInt(element.getAttribute(name), 10);
            } else {
              return defaultValue;
            }
          }
          function _attr_as_string(element, name, defaultValue) {
            if (element.hasAttribute(name)) {
              return element.getAttribute(name);
            } else {
              return defaultValue;
            }
          }
          function _format_float(f, num) {
            if (f === void 0) {
              var s = "0.";
              while (s.length < num + 2) {
                s += "0";
              }
              return s;
            }
            num = num || 2;
            var parts = f.toString().split(".");
            parts[1] = parts.length > 1 ? parts[1].substr(0, num) : "0";
            while (parts[1].length < num) {
              parts[1] += "0";
            }
            return parts.join(".");
          }
          function loadTextureImage(texture, url) {
            var loader = new THREE.ImageLoader();
            loader.load(url, function(image) {
              texture.image = image;
              texture.needsUpdate = true;
            });
          }
          function extractDoubleSided(obj, element) {
            obj.doubleSided = false;
            var node = element.querySelectorAll("extra double_sided")[0];
            if (node) {
              if (node && parseInt(node.textContent, 10) === 1) {
                obj.doubleSided = true;
              }
            }
          }
          function setUpConversion() {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
              upConversion = null;
            } else {
              switch (colladaUp) {
                case "X":
                  upConversion = options.upAxis === "Y" ? "XtoY" : "XtoZ";
                  break;
                case "Y":
                  upConversion = options.upAxis === "X" ? "YtoX" : "YtoZ";
                  break;
                case "Z":
                  upConversion = options.upAxis === "X" ? "ZtoX" : "ZtoY";
                  break;
              }
            }
          }
          function fixCoords(data, sign) {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
              return;
            }
            switch (upConversion) {
              case "XtoY":
                var tmp = data[0];
                data[0] = sign * data[1];
                data[1] = tmp;
                break;
              case "XtoZ":
                var tmp = data[2];
                data[2] = data[1];
                data[1] = data[0];
                data[0] = tmp;
                break;
              case "YtoX":
                var tmp = data[0];
                data[0] = data[1];
                data[1] = sign * tmp;
                break;
              case "YtoZ":
                var tmp = data[1];
                data[1] = sign * data[2];
                data[2] = tmp;
                break;
              case "ZtoX":
                var tmp = data[0];
                data[0] = data[1];
                data[1] = data[2];
                data[2] = tmp;
                break;
              case "ZtoY":
                var tmp = data[1];
                data[1] = data[2];
                data[2] = sign * tmp;
                break;
            }
          }
          function getConvertedTranslation(axis, data) {
            if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
              return data;
            }
            switch (axis) {
              case "X":
                data = upConversion === "XtoY" ? data * -1 : data;
                break;
              case "Y":
                data = upConversion === "YtoZ" || upConversion === "YtoX" ? data * -1 : data;
                break;
              case "Z":
                data = upConversion === "ZtoY" ? data * -1 : data;
                break;
              default:
                break;
            }
            return data;
          }
          function getConvertedVec3(data, offset) {
            var arr = [data[offset], data[offset + 1], data[offset + 2]];
            fixCoords(arr, -1);
            return new THREE.Vector3(arr[0], arr[1], arr[2]);
          }
          function getConvertedMat4(data) {
            if (options.convertUpAxis) {
              var arr = [data[0], data[4], data[8]];
              fixCoords(arr, -1);
              data[0] = arr[0];
              data[4] = arr[1];
              data[8] = arr[2];
              arr = [data[1], data[5], data[9]];
              fixCoords(arr, -1);
              data[1] = arr[0];
              data[5] = arr[1];
              data[9] = arr[2];
              arr = [data[2], data[6], data[10]];
              fixCoords(arr, -1);
              data[2] = arr[0];
              data[6] = arr[1];
              data[10] = arr[2];
              arr = [data[0], data[1], data[2]];
              fixCoords(arr, -1);
              data[0] = arr[0];
              data[1] = arr[1];
              data[2] = arr[2];
              arr = [data[4], data[5], data[6]];
              fixCoords(arr, -1);
              data[4] = arr[0];
              data[5] = arr[1];
              data[6] = arr[2];
              arr = [data[8], data[9], data[10]];
              fixCoords(arr, -1);
              data[8] = arr[0];
              data[9] = arr[1];
              data[10] = arr[2];
              arr = [data[3], data[7], data[11]];
              fixCoords(arr, -1);
              data[3] = arr[0];
              data[7] = arr[1];
              data[11] = arr[2];
            }
            return new THREE.Matrix4().set(
              data[0],
              data[1],
              data[2],
              data[3],
              data[4],
              data[5],
              data[6],
              data[7],
              data[8],
              data[9],
              data[10],
              data[11],
              data[12],
              data[13],
              data[14],
              data[15]
            );
          }
          function getConvertedIndex(index) {
            if (index > -1 && index < 3) {
              var members = ["X", "Y", "Z"], indices = { X: 0, Y: 1, Z: 2 };
              index = getConvertedMember(members[index]);
              index = indices[index];
            }
            return index;
          }
          function getConvertedMember(member) {
            if (options.convertUpAxis) {
              switch (member) {
                case "X":
                  switch (upConversion) {
                    case "XtoY":
                    case "XtoZ":
                    case "YtoX":
                      member = "Y";
                      break;
                    case "ZtoX":
                      member = "Z";
                      break;
                  }
                  break;
                case "Y":
                  switch (upConversion) {
                    case "XtoY":
                    case "YtoX":
                    case "ZtoX":
                      member = "X";
                      break;
                    case "XtoZ":
                    case "YtoZ":
                    case "ZtoY":
                      member = "Z";
                      break;
                  }
                  break;
                case "Z":
                  switch (upConversion) {
                    case "XtoZ":
                      member = "X";
                      break;
                    case "YtoZ":
                    case "ZtoX":
                    case "ZtoY":
                      member = "Y";
                      break;
                  }
                  break;
              }
            }
            return member;
          }
          return {
            load,
            parse,
            setPreferredShading,
            applySkin,
            geometries,
            options
          };
        };
      }, {}], 16: [function(_dereq_, module3, exports3) {
        THREE.MTLLoader = function(manager) {
          this.manager = manager !== void 0 ? manager : THREE.DefaultLoadingManager;
        };
        Object.assign(THREE.MTLLoader.prototype, THREE.EventDispatcher.prototype, {
          /**
           * Loads and parses a MTL asset from a URL.
           *
           * @param {String} url - URL to the MTL file.
           * @param {Function} [onLoad] - Callback invoked with the loaded object.
           * @param {Function} [onProgress] - Callback for download progress.
           * @param {Function} [onError] - Callback for download errors.
           *
           * @see setPath setTexturePath
           *
           * @note In order for relative texture references to resolve correctly
           * you must call setPath and/or setTexturePath explicitly prior to load.
           */
          load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(this.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
              onLoad(scope.parse(text));
            }, onProgress, onError);
          },
          /**
           * Set base path for resolving references.
           * If set this path will be prepended to each loaded and found reference.
           *
           * @see setTexturePath
           * @param {String} path
           *
           * @example
           *     mtlLoader.setPath( 'assets/obj/' );
           *     mtlLoader.load( 'my.mtl', ... );
           */
          setPath: function(path) {
            this.path = path;
          },
          /**
           * Set base path for resolving texture references.
           * If set this path will be prepended found texture reference.
           * If not set and setPath is, it will be used as texture base path.
           *
           * @see setPath
           * @param {String} path
           *
           * @example
           *     mtlLoader.setPath( 'assets/obj/' );
           *     mtlLoader.setTexturePath( 'assets/textures/' );
           *     mtlLoader.load( 'my.mtl', ... );
           */
          setTexturePath: function(path) {
            this.texturePath = path;
          },
          setBaseUrl: function(path) {
            console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.");
            this.setTexturePath(path);
          },
          setCrossOrigin: function(value) {
            this.crossOrigin = value;
          },
          setMaterialOptions: function(value) {
            this.materialOptions = value;
          },
          /**
           * Parses a MTL file.
           *
           * @param {String} text - Content of MTL file
           * @return {THREE.MTLLoader.MaterialCreator}
           *
           * @see setPath setTexturePath
           *
           * @note In order for relative texture references to resolve correctly
           * you must call setPath and/or setTexturePath explicitly prior to parse.
           */
          parse: function(text) {
            var lines = text.split("\n");
            var info = {};
            var delimiter_pattern = /\s+/;
            var materialsInfo = {};
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i];
              line = line.trim();
              if (line.length === 0 || line.charAt(0) === "#") {
                continue;
              }
              var pos = line.indexOf(" ");
              var key = pos >= 0 ? line.substring(0, pos) : line;
              key = key.toLowerCase();
              var value = pos >= 0 ? line.substring(pos + 1) : "";
              value = value.trim();
              if (key === "newmtl") {
                info = { name: value };
                materialsInfo[value] = info;
              } else if (info) {
                if (key === "ka" || key === "kd" || key === "ks") {
                  var ss = value.split(delimiter_pattern, 3);
                  info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
                } else {
                  info[key] = value;
                }
              }
            }
            var materialCreator = new THREE.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
            materialCreator.setCrossOrigin(this.crossOrigin);
            materialCreator.setManager(this.manager);
            materialCreator.setMaterials(materialsInfo);
            return materialCreator;
          }
        });
        THREE.MTLLoader.MaterialCreator = function(baseUrl, options) {
          this.baseUrl = baseUrl || "";
          this.options = options;
          this.materialsInfo = {};
          this.materials = {};
          this.materialsArray = [];
          this.nameLookup = {};
          this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;
          this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;
        };
        THREE.MTLLoader.MaterialCreator.prototype = {
          constructor: THREE.MTLLoader.MaterialCreator,
          setCrossOrigin: function(value) {
            this.crossOrigin = value;
          },
          setManager: function(value) {
            this.manager = value;
          },
          setMaterials: function(materialsInfo) {
            this.materialsInfo = this.convert(materialsInfo);
            this.materials = {};
            this.materialsArray = [];
            this.nameLookup = {};
          },
          convert: function(materialsInfo) {
            if (!this.options)
              return materialsInfo;
            var converted = {};
            for (var mn in materialsInfo) {
              var mat = materialsInfo[mn];
              var covmat = {};
              converted[mn] = covmat;
              for (var prop in mat) {
                var save = true;
                var value = mat[prop];
                var lprop = prop.toLowerCase();
                switch (lprop) {
                  case "kd":
                  case "ka":
                  case "ks":
                    if (this.options && this.options.normalizeRGB) {
                      value = [value[0] / 255, value[1] / 255, value[2] / 255];
                    }
                    if (this.options && this.options.ignoreZeroRGBs) {
                      if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                        save = false;
                      }
                    }
                    break;
                  default:
                    break;
                }
                if (save) {
                  covmat[lprop] = value;
                }
              }
            }
            return converted;
          },
          preload: function() {
            for (var mn in this.materialsInfo) {
              this.create(mn);
            }
          },
          getIndex: function(materialName) {
            return this.nameLookup[materialName];
          },
          getAsArray: function() {
            var index = 0;
            for (var mn in this.materialsInfo) {
              this.materialsArray[index] = this.create(mn);
              this.nameLookup[mn] = index;
              index++;
            }
            return this.materialsArray;
          },
          create: function(materialName) {
            if (this.materials[materialName] === void 0) {
              this.createMaterial_(materialName);
            }
            return this.materials[materialName];
          },
          createMaterial_: function(materialName) {
            var scope = this;
            var mat = this.materialsInfo[materialName];
            var params = {
              name: materialName,
              side: this.side
            };
            var resolveURL = function(baseUrl, url) {
              if (typeof url !== "string" || url === "")
                return "";
              if (/^https?:\/\//i.test(url)) {
                return url;
              }
              return baseUrl + url;
            };
            function setMapForType(mapType, value2) {
              if (params[mapType])
                return;
              var texParams = scope.getTextureParams(value2, params);
              var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
              map.repeat.copy(texParams.scale);
              map.offset.copy(texParams.offset);
              map.wrapS = scope.wrap;
              map.wrapT = scope.wrap;
              params[mapType] = map;
            }
            for (var prop in mat) {
              var value = mat[prop];
              if (value === "")
                continue;
              switch (prop.toLowerCase()) {
                case "kd":
                  params.color = new THREE.Color().fromArray(value);
                  break;
                case "ks":
                  params.specular = new THREE.Color().fromArray(value);
                  break;
                case "map_kd":
                  setMapForType("map", value);
                  break;
                case "map_ks":
                  setMapForType("specularMap", value);
                  break;
                case "map_bump":
                case "bump":
                  setMapForType("bumpMap", value);
                  break;
                case "ns":
                  params.shininess = parseFloat(value);
                  break;
                case "d":
                  if (value < 1) {
                    params.opacity = value;
                    params.transparent = true;
                  }
                  break;
                case "Tr":
                  if (value > 0) {
                    params.opacity = 1 - value;
                    params.transparent = true;
                  }
                  break;
                default:
                  break;
              }
            }
            this.materials[materialName] = new THREE.MeshPhongMaterial(params);
            return this.materials[materialName];
          },
          getTextureParams: function(value, matParams) {
            var texParams = {
              scale: new THREE.Vector2(1, 1),
              offset: new THREE.Vector2(0, 0)
            };
            var items = value.split(/\s+/);
            var pos;
            pos = items.indexOf("-bm");
            if (pos >= 0) {
              matParams.bumpScale = parseFloat(items[pos + 1]);
              items.splice(pos, 2);
            }
            pos = items.indexOf("-s");
            if (pos >= 0) {
              texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
              items.splice(pos, 4);
            }
            pos = items.indexOf("-o");
            if (pos >= 0) {
              texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
              items.splice(pos, 4);
            }
            texParams.url = items.join(" ").trim();
            return texParams;
          },
          loadTexture: function(url, mapping, onLoad, onProgress, onError) {
            var texture;
            var loader = THREE.Loader.Handlers.get(url);
            var manager = this.manager !== void 0 ? this.manager : THREE.DefaultLoadingManager;
            if (loader === null) {
              loader = new THREE.TextureLoader(manager);
            }
            if (loader.setCrossOrigin)
              loader.setCrossOrigin(this.crossOrigin);
            texture = loader.load(url, onLoad, onProgress, onError);
            if (mapping !== void 0)
              texture.mapping = mapping;
            return texture;
          }
        };
      }, {}], 17: [function(_dereq_, module3, exports3) {
        THREE.OBJLoader = function(manager) {
          this.manager = manager !== void 0 ? manager : THREE.DefaultLoadingManager;
          this.materials = null;
          this.regexp = {
            // v float float float
            vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // vn float float float
            normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // vt float float
            uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            // f vertex vertex vertex
            face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
            // f vertex/uv vertex/uv vertex/uv
            face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
            face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
            // f vertex//normal vertex//normal vertex//normal
            face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
            // o object_name | g group_name
            object_pattern: /^[og]\s*(.+)?/,
            // s boolean
            smoothing_pattern: /^s\s+(\d+|on|off)/,
            // mtllib file_reference
            material_library_pattern: /^mtllib /,
            // usemtl material_name
            material_use_pattern: /^usemtl /
          };
        };
        THREE.OBJLoader.prototype = {
          constructor: THREE.OBJLoader,
          load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.XHRLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
              onLoad(scope.parse(text));
            }, onProgress, onError);
          },
          setPath: function(value) {
            this.path = value;
          },
          setMaterials: function(materials) {
            this.materials = materials;
          },
          _createParserState: function() {
            var state = {
              objects: [],
              object: {},
              vertices: [],
              normals: [],
              uvs: [],
              materialLibraries: [],
              startObject: function(name, fromDeclaration) {
                if (this.object && this.object.fromDeclaration === false) {
                  this.object.name = name;
                  this.object.fromDeclaration = fromDeclaration !== false;
                  return;
                }
                var previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
                if (this.object && typeof this.object._finalize === "function") {
                  this.object._finalize(true);
                }
                this.object = {
                  name: name || "",
                  fromDeclaration: fromDeclaration !== false,
                  geometry: {
                    vertices: [],
                    normals: [],
                    uvs: []
                  },
                  materials: [],
                  smooth: true,
                  startMaterial: function(name2, libraries) {
                    var previous = this._finalize(false);
                    if (previous && (previous.inherited || previous.groupCount <= 0)) {
                      this.materials.splice(previous.index, 1);
                    }
                    var material = {
                      index: this.materials.length,
                      name: name2 || "",
                      mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                      smooth: previous !== void 0 ? previous.smooth : this.smooth,
                      groupStart: previous !== void 0 ? previous.groupEnd : 0,
                      groupEnd: -1,
                      groupCount: -1,
                      inherited: false,
                      clone: function(index) {
                        var cloned = {
                          index: typeof index === "number" ? index : this.index,
                          name: this.name,
                          mtllib: this.mtllib,
                          smooth: this.smooth,
                          groupStart: 0,
                          groupEnd: -1,
                          groupCount: -1,
                          inherited: false
                        };
                        cloned.clone = this.clone.bind(cloned);
                        return cloned;
                      }
                    };
                    this.materials.push(material);
                    return material;
                  },
                  currentMaterial: function() {
                    if (this.materials.length > 0) {
                      return this.materials[this.materials.length - 1];
                    }
                    return void 0;
                  },
                  _finalize: function(end) {
                    var lastMultiMaterial = this.currentMaterial();
                    if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                      lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                      lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                      lastMultiMaterial.inherited = false;
                    }
                    if (end && this.materials.length > 1) {
                      for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                        if (this.materials[mi].groupCount <= 0) {
                          this.materials.splice(mi, 1);
                        }
                      }
                    }
                    if (end && this.materials.length === 0) {
                      this.materials.push({
                        name: "",
                        smooth: this.smooth
                      });
                    }
                    return lastMultiMaterial;
                  }
                };
                if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
                  var declared = previousMaterial.clone(0);
                  declared.inherited = true;
                  this.object.materials.push(declared);
                }
                this.objects.push(this.object);
              },
              finalize: function() {
                if (this.object && typeof this.object._finalize === "function") {
                  this.object._finalize(true);
                }
              },
              parseVertexIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
              },
              parseNormalIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
              },
              parseUVIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;
              },
              addVertex: function(a, b, c) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[b + 2]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);
                dst.push(src[c + 2]);
              },
              addVertexLine: function(a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);
              },
              addNormal: function(a, b, c) {
                var src = this.normals;
                var dst = this.object.geometry.normals;
                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[a + 2]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[b + 2]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);
                dst.push(src[c + 2]);
              },
              addUV: function(a, b, c) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
                dst.push(src[b + 0]);
                dst.push(src[b + 1]);
                dst.push(src[c + 0]);
                dst.push(src[c + 1]);
              },
              addUVLine: function(a) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0]);
                dst.push(src[a + 1]);
              },
              addFace: function(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
                var vLen = this.vertices.length;
                var ia = this.parseVertexIndex(a, vLen);
                var ib = this.parseVertexIndex(b, vLen);
                var ic = this.parseVertexIndex(c, vLen);
                var id;
                if (d === void 0) {
                  this.addVertex(ia, ib, ic);
                } else {
                  id = this.parseVertexIndex(d, vLen);
                  this.addVertex(ia, ib, id);
                  this.addVertex(ib, ic, id);
                }
                if (ua !== void 0) {
                  var uvLen = this.uvs.length;
                  ia = this.parseUVIndex(ua, uvLen);
                  ib = this.parseUVIndex(ub, uvLen);
                  ic = this.parseUVIndex(uc, uvLen);
                  if (d === void 0) {
                    this.addUV(ia, ib, ic);
                  } else {
                    id = this.parseUVIndex(ud, uvLen);
                    this.addUV(ia, ib, id);
                    this.addUV(ib, ic, id);
                  }
                }
                if (na !== void 0) {
                  var nLen = this.normals.length;
                  ia = this.parseNormalIndex(na, nLen);
                  ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
                  ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
                  if (d === void 0) {
                    this.addNormal(ia, ib, ic);
                  } else {
                    id = this.parseNormalIndex(nd, nLen);
                    this.addNormal(ia, ib, id);
                    this.addNormal(ib, ic, id);
                  }
                }
              },
              addLineGeometry: function(vertices, uvs) {
                this.object.geometry.type = "Line";
                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;
                for (var vi = 0, l = vertices.length; vi < l; vi++) {
                  this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                }
                for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
                  this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
                }
              }
            };
            state.startObject("", false);
            return state;
          },
          parse: function(text) {
            console.time("OBJLoader");
            var state = this._createParserState();
            if (text.indexOf("\r\n") !== -1) {
              text = text.replace(/\r\n/g, "\n");
            }
            if (text.indexOf("\\\n") !== -1) {
              text = text.replace(/\\\n/g, "");
            }
            var lines = text.split("\n");
            var line = "", lineFirstChar = "", lineSecondChar = "";
            var lineLength = 0;
            var result = [];
            var trimLeft = typeof "".trimLeft === "function";
            for (var i = 0, l = lines.length; i < l; i++) {
              line = lines[i];
              line = trimLeft ? line.trimLeft() : line.trim();
              lineLength = line.length;
              if (lineLength === 0)
                continue;
              lineFirstChar = line.charAt(0);
              if (lineFirstChar === "#")
                continue;
              if (lineFirstChar === "v") {
                lineSecondChar = line.charAt(1);
                if (lineSecondChar === " " && (result = this.regexp.vertex_pattern.exec(line)) !== null) {
                  state.vertices.push(
                    parseFloat(result[1]),
                    parseFloat(result[2]),
                    parseFloat(result[3])
                  );
                } else if (lineSecondChar === "n" && (result = this.regexp.normal_pattern.exec(line)) !== null) {
                  state.normals.push(
                    parseFloat(result[1]),
                    parseFloat(result[2]),
                    parseFloat(result[3])
                  );
                } else if (lineSecondChar === "t" && (result = this.regexp.uv_pattern.exec(line)) !== null) {
                  state.uvs.push(
                    parseFloat(result[1]),
                    parseFloat(result[2])
                  );
                } else {
                  throw new Error("Unexpected vertex/normal/uv line: '" + line + "'");
                }
              } else if (lineFirstChar === "f") {
                if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {
                  state.addFace(
                    result[1],
                    result[4],
                    result[7],
                    result[10],
                    result[2],
                    result[5],
                    result[8],
                    result[11],
                    result[3],
                    result[6],
                    result[9],
                    result[12]
                  );
                } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {
                  state.addFace(
                    result[1],
                    result[3],
                    result[5],
                    result[7],
                    result[2],
                    result[4],
                    result[6],
                    result[8]
                  );
                } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {
                  state.addFace(
                    result[1],
                    result[3],
                    result[5],
                    result[7],
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    result[2],
                    result[4],
                    result[6],
                    result[8]
                  );
                } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {
                  state.addFace(
                    result[1],
                    result[2],
                    result[3],
                    result[4]
                  );
                } else {
                  throw new Error("Unexpected face line: '" + line + "'");
                }
              } else if (lineFirstChar === "l") {
                var lineParts = line.substring(1).trim().split(" ");
                var lineVertices = [], lineUVs = [];
                if (line.indexOf("/") === -1) {
                  lineVertices = lineParts;
                } else {
                  for (var li = 0, llen = lineParts.length; li < llen; li++) {
                    var parts = lineParts[li].split("/");
                    if (parts[0] !== "")
                      lineVertices.push(parts[0]);
                    if (parts[1] !== "")
                      lineUVs.push(parts[1]);
                  }
                }
                state.addLineGeometry(lineVertices, lineUVs);
              } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {
                var name = (" " + result[0].substr(1).trim()).substr(1);
                state.startObject(name);
              } else if (this.regexp.material_use_pattern.test(line)) {
                state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
              } else if (this.regexp.material_library_pattern.test(line)) {
                state.materialLibraries.push(line.substring(7).trim());
              } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {
                var value = result[1].trim().toLowerCase();
                state.object.smooth = value === "1" || value === "on";
                var material = state.object.currentMaterial();
                if (material) {
                  material.smooth = state.object.smooth;
                }
              } else {
                if (line === "\0")
                  continue;
                throw new Error("Unexpected line: '" + line + "'");
              }
            }
            state.finalize();
            var container = new THREE.Group();
            container.materialLibraries = [].concat(state.materialLibraries);
            for (var i = 0, l = state.objects.length; i < l; i++) {
              var object = state.objects[i];
              var geometry = object.geometry;
              var materials = object.materials;
              var isLine = geometry.type === "Line";
              if (geometry.vertices.length === 0)
                continue;
              var buffergeometry = new THREE.BufferGeometry();
              buffergeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));
              if (geometry.normals.length > 0) {
                buffergeometry.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));
              } else {
                buffergeometry.computeVertexNormals();
              }
              if (geometry.uvs.length > 0) {
                buffergeometry.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));
              }
              var createdMaterials = [];
              for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                var sourceMaterial = materials[mi];
                var material = void 0;
                if (this.materials !== null) {
                  material = this.materials.create(sourceMaterial.name);
                  if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
                    var materialLine = new THREE.LineBasicMaterial();
                    materialLine.copy(material);
                    material = materialLine;
                  }
                }
                if (!material) {
                  material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();
                  material.name = sourceMaterial.name;
                }
                material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;
                createdMaterials.push(material);
              }
              var mesh;
              if (createdMaterials.length > 1) {
                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                  var sourceMaterial = materials[mi];
                  buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                }
                var multiMaterial = new THREE.MultiMaterial(createdMaterials);
                mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);
              } else {
                mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);
              }
              mesh.name = object.name;
              container.add(mesh);
            }
            console.timeEnd("OBJLoader");
            return container;
          }
        };
      }, {}], 18: [function(_dereq_, module3, exports3) {
        (function(root) {
          if ("performance" in root === false) {
            root.performance = {};
          }
          Date.now = Date.now || function() {
            return (/* @__PURE__ */ new Date()).getTime();
          };
          if ("now" in root.performance === false) {
            var offset = root.performance.timing && root.performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();
            root.performance.now = function() {
              return Date.now() - offset;
            };
          }
        })(this);
        var TWEEN = TWEEN || /* @__PURE__ */ function() {
          var _tweens = [];
          return {
            REVISION: "14",
            getAll: function() {
              return _tweens;
            },
            removeAll: function() {
              _tweens = [];
            },
            add: function(tween) {
              _tweens.push(tween);
            },
            remove: function(tween) {
              var i = _tweens.indexOf(tween);
              if (i !== -1) {
                _tweens.splice(i, 1);
              }
            },
            update: function(time) {
              if (_tweens.length === 0)
                return false;
              var i = 0;
              time = time !== void 0 ? time : window.performance.now();
              while (i < _tweens.length) {
                if (_tweens[i].update(time)) {
                  i++;
                } else {
                  _tweens.splice(i, 1);
                }
              }
              return true;
            }
          };
        }();
        TWEEN.Tween = function(object) {
          var _object = object;
          var _valuesStart = {};
          var _valuesEnd = {};
          var _valuesStartRepeat = {};
          var _duration = 1e3;
          var _repeat = 0;
          var _yoyo = false;
          var _isPlaying = false;
          var _reversed = false;
          var _delayTime = 0;
          var _startTime = null;
          var _easingFunction = TWEEN.Easing.Linear.None;
          var _interpolationFunction = TWEEN.Interpolation.Linear;
          var _chainedTweens = [];
          var _onStartCallback = null;
          var _onStartCallbackFired = false;
          var _onUpdateCallback = null;
          var _onCompleteCallback = null;
          var _onStopCallback = null;
          for (var field in object) {
            _valuesStart[field] = parseFloat(object[field], 10);
          }
          this.to = function(properties, duration) {
            if (duration !== void 0) {
              _duration = duration;
            }
            _valuesEnd = properties;
            return this;
          };
          this.start = function(time) {
            TWEEN.add(this);
            _isPlaying = true;
            _onStartCallbackFired = false;
            _startTime = time !== void 0 ? time : window.performance.now();
            _startTime += _delayTime;
            for (var property in _valuesEnd) {
              if (_valuesEnd[property] instanceof Array) {
                if (_valuesEnd[property].length === 0) {
                  continue;
                }
                _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
              }
              _valuesStart[property] = _object[property];
              if (_valuesStart[property] instanceof Array === false) {
                _valuesStart[property] *= 1;
              }
              _valuesStartRepeat[property] = _valuesStart[property] || 0;
            }
            return this;
          };
          this.stop = function() {
            if (!_isPlaying) {
              return this;
            }
            TWEEN.remove(this);
            _isPlaying = false;
            if (_onStopCallback !== null) {
              _onStopCallback.call(_object);
            }
            this.stopChainedTweens();
            return this;
          };
          this.stopChainedTweens = function() {
            for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
              _chainedTweens[i].stop();
            }
          };
          this.delay = function(amount) {
            _delayTime = amount;
            return this;
          };
          this.repeat = function(times) {
            _repeat = times;
            return this;
          };
          this.yoyo = function(yoyo) {
            _yoyo = yoyo;
            return this;
          };
          this.easing = function(easing) {
            _easingFunction = easing;
            return this;
          };
          this.interpolation = function(interpolation) {
            _interpolationFunction = interpolation;
            return this;
          };
          this.chain = function() {
            _chainedTweens = arguments;
            return this;
          };
          this.onStart = function(callback) {
            _onStartCallback = callback;
            return this;
          };
          this.onUpdate = function(callback) {
            _onUpdateCallback = callback;
            return this;
          };
          this.onComplete = function(callback) {
            _onCompleteCallback = callback;
            return this;
          };
          this.onStop = function(callback) {
            _onStopCallback = callback;
            return this;
          };
          this.update = function(time) {
            var property;
            if (time < _startTime) {
              return true;
            }
            if (_onStartCallbackFired === false) {
              if (_onStartCallback !== null) {
                _onStartCallback.call(_object);
              }
              _onStartCallbackFired = true;
            }
            var elapsed = (time - _startTime) / _duration;
            elapsed = elapsed > 1 ? 1 : elapsed;
            var value = _easingFunction(elapsed);
            for (property in _valuesEnd) {
              var start = _valuesStart[property] || 0;
              var end = _valuesEnd[property];
              if (end instanceof Array) {
                _object[property] = _interpolationFunction(end, value);
              } else {
                if (typeof end === "string") {
                  end = start + parseFloat(end, 10);
                }
                if (typeof end === "number") {
                  _object[property] = start + (end - start) * value;
                }
              }
            }
            if (_onUpdateCallback !== null) {
              _onUpdateCallback.call(_object, value);
            }
            if (elapsed == 1) {
              if (_repeat > 0) {
                if (isFinite(_repeat)) {
                  _repeat--;
                }
                for (property in _valuesStartRepeat) {
                  if (typeof _valuesEnd[property] === "string") {
                    _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
                  }
                  if (_yoyo) {
                    var tmp = _valuesStartRepeat[property];
                    _valuesStartRepeat[property] = _valuesEnd[property];
                    _valuesEnd[property] = tmp;
                  }
                  _valuesStart[property] = _valuesStartRepeat[property];
                }
                if (_yoyo) {
                  _reversed = !_reversed;
                }
                _startTime = time + _delayTime;
                return true;
              } else {
                if (_onCompleteCallback !== null) {
                  _onCompleteCallback.call(_object);
                }
                for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
                  _chainedTweens[i].start(time);
                }
                return false;
              }
            }
            return true;
          };
        };
        TWEEN.Easing = {
          Linear: {
            None: function(k) {
              return k;
            }
          },
          Quadratic: {
            In: function(k) {
              return k * k;
            },
            Out: function(k) {
              return k * (2 - k);
            },
            InOut: function(k) {
              if ((k *= 2) < 1)
                return 0.5 * k * k;
              return -0.5 * (--k * (k - 2) - 1);
            }
          },
          Cubic: {
            In: function(k) {
              return k * k * k;
            },
            Out: function(k) {
              return --k * k * k + 1;
            },
            InOut: function(k) {
              if ((k *= 2) < 1)
                return 0.5 * k * k * k;
              return 0.5 * ((k -= 2) * k * k + 2);
            }
          },
          Quartic: {
            In: function(k) {
              return k * k * k * k;
            },
            Out: function(k) {
              return 1 - --k * k * k * k;
            },
            InOut: function(k) {
              if ((k *= 2) < 1)
                return 0.5 * k * k * k * k;
              return -0.5 * ((k -= 2) * k * k * k - 2);
            }
          },
          Quintic: {
            In: function(k) {
              return k * k * k * k * k;
            },
            Out: function(k) {
              return --k * k * k * k * k + 1;
            },
            InOut: function(k) {
              if ((k *= 2) < 1)
                return 0.5 * k * k * k * k * k;
              return 0.5 * ((k -= 2) * k * k * k * k + 2);
            }
          },
          Sinusoidal: {
            In: function(k) {
              return 1 - Math.cos(k * Math.PI / 2);
            },
            Out: function(k) {
              return Math.sin(k * Math.PI / 2);
            },
            InOut: function(k) {
              return 0.5 * (1 - Math.cos(Math.PI * k));
            }
          },
          Exponential: {
            In: function(k) {
              return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            Out: function(k) {
              return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            InOut: function(k) {
              if (k === 0)
                return 0;
              if (k === 1)
                return 1;
              if ((k *= 2) < 1)
                return 0.5 * Math.pow(1024, k - 1);
              return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
          },
          Circular: {
            In: function(k) {
              return 1 - Math.sqrt(1 - k * k);
            },
            Out: function(k) {
              return Math.sqrt(1 - --k * k);
            },
            InOut: function(k) {
              if ((k *= 2) < 1)
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
              return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
          },
          Elastic: {
            In: function(k) {
              var s, a = 0.1, p = 0.4;
              if (k === 0)
                return 0;
              if (k === 1)
                return 1;
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            },
            Out: function(k) {
              var s, a = 0.1, p = 0.4;
              if (k === 0)
                return 0;
              if (k === 1)
                return 1;
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            },
            InOut: function(k) {
              var s, a = 0.1, p = 0.4;
              if (k === 0)
                return 0;
              if (k === 1)
                return 1;
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              if ((k *= 2) < 1)
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
              return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
            }
          },
          Back: {
            In: function(k) {
              var s = 1.70158;
              return k * k * ((s + 1) * k - s);
            },
            Out: function(k) {
              var s = 1.70158;
              return --k * k * ((s + 1) * k + s) + 1;
            },
            InOut: function(k) {
              var s = 1.70158 * 1.525;
              if ((k *= 2) < 1)
                return 0.5 * (k * k * ((s + 1) * k - s));
              return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
          },
          Bounce: {
            In: function(k) {
              return 1 - TWEEN.Easing.Bounce.Out(1 - k);
            },
            Out: function(k) {
              if (k < 1 / 2.75) {
                return 7.5625 * k * k;
              } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
              } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
              } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
              }
            },
            InOut: function(k) {
              if (k < 0.5)
                return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
              return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
            }
          }
        };
        TWEEN.Interpolation = {
          Linear: function(v, k) {
            var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.Linear;
            if (k < 0)
              return fn(v[0], v[1], f);
            if (k > 1)
              return fn(v[m], v[m - 1], m - f);
            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
          },
          Bezier: function(v, k) {
            var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;
            for (i = 0; i <= n; i++) {
              b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
            }
            return b;
          },
          CatmullRom: function(v, k) {
            var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.CatmullRom;
            if (v[0] === v[m]) {
              if (k < 0)
                i = Math.floor(f = m * (1 + k));
              return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            } else {
              if (k < 0)
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
              if (k > 1)
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
              return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
          },
          Utils: {
            Linear: function(p0, p1, t) {
              return (p1 - p0) * t + p0;
            },
            Bernstein: function(n, i) {
              var fc = TWEEN.Interpolation.Utils.Factorial;
              return fc(n) / fc(i) / fc(n - i);
            },
            Factorial: /* @__PURE__ */ function() {
              var a = [1];
              return function(n) {
                var s = 1, i;
                if (a[n])
                  return a[n];
                for (i = n; i > 1; i--)
                  s *= i;
                return a[n] = s;
              };
            }(),
            CatmullRom: function(p0, p1, p2, p3, t) {
              var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
              return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
          }
        };
        (function(root) {
          if (typeof define2 === "function" && define2.amd) {
            define2([], function() {
              return TWEEN;
            });
          } else if (typeof exports3 === "object") {
            module3.exports = TWEEN;
          } else {
            root.TWEEN = TWEEN;
          }
        })(this);
      }, {}], 19: [function(_dereq_, module3, exports3) {
        (function e2(t, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t[o2]) {
                var a = typeof _dereq_ == "function" && _dereq_;
                if (!u && a)
                  return a(o2, true);
                if (i)
                  return i(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t[o2][0].call(l.exports, function(e3) {
                var n2 = t[o2][1][e3];
                return s(n2 ? n2 : e3);
              }, l, l.exports, e2, t, n, r);
            }
            return n[o2].exports;
          }
          var i = typeof _dereq_ == "function" && _dereq_;
          for (var o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        })({ 1: [function(_dereq_2, module4, exports4) {
          "use strict";
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String("abc");
              test1[5] = "de";
              if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
              }
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2["_" + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
              });
              if (order2.join("") !== "0123456789") {
                return false;
              }
              var test3 = {};
              "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
              }
              return true;
            } catch (e2) {
              return false;
            }
          }
          module4.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
              from = Object(arguments[s]);
              for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                  to[key] = from[key];
                }
              }
              if (Object.getOwnPropertySymbols) {
                symbols = Object.getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                  }
                }
              }
            }
            return to;
          };
        }, {}], 2: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          var WakeLock = _dereq_2("./wakelock.js");
          var nextDisplayId = 1e3;
          var hasShowDeprecationWarning = false;
          var defaultLeftBounds = [0, 0, 0.5, 1];
          var defaultRightBounds = [0.5, 0, 0.5, 1];
          function VRFrameData2() {
            this.leftProjectionMatrix = new Float32Array(16);
            this.leftViewMatrix = new Float32Array(16);
            this.rightProjectionMatrix = new Float32Array(16);
            this.rightViewMatrix = new Float32Array(16);
            this.pose = null;
          }
          ;
          function VRDisplay() {
            this.isPolyfilled = true;
            this.displayId = nextDisplayId++;
            this.displayName = "webvr-polyfill displayName";
            this.depthNear = 0.01;
            this.depthFar = 1e4;
            this.isConnected = true;
            this.isPresenting = false;
            this.capabilities = {
              hasPosition: false,
              hasOrientation: false,
              hasExternalDisplay: false,
              canPresent: false,
              maxLayers: 1
            };
            this.stageParameters = null;
            this.waitingForPresent_ = false;
            this.layer_ = null;
            this.fullscreenElement_ = null;
            this.fullscreenWrapper_ = null;
            this.fullscreenElementCachedStyle_ = null;
            this.fullscreenEventTarget_ = null;
            this.fullscreenChangeHandler_ = null;
            this.fullscreenErrorHandler_ = null;
            this.wakelock_ = new WakeLock();
          }
          VRDisplay.prototype.getFrameData = function(frameData) {
            return Util.frameDataFromPose(frameData, this.getPose(), this);
          };
          VRDisplay.prototype.getPose = function() {
            return this.getImmediatePose();
          };
          VRDisplay.prototype.requestAnimationFrame = function(callback) {
            return window.requestAnimationFrame(callback);
          };
          VRDisplay.prototype.cancelAnimationFrame = function(id) {
            return window.cancelAnimationFrame(id);
          };
          VRDisplay.prototype.wrapForFullscreen = function(element) {
            if (Util.isIOS()) {
              return element;
            }
            if (!this.fullscreenWrapper_) {
              this.fullscreenWrapper_ = document.createElement("div");
              var cssProperties = [
                "height: " + Math.min(screen.height, screen.width) + "px !important",
                "top: 0 !important",
                "left: 0 !important",
                "right: 0 !important",
                "border: 0",
                "margin: 0",
                "padding: 0",
                "z-index: 999999 !important",
                "position: fixed"
              ];
              this.fullscreenWrapper_.setAttribute("style", cssProperties.join("; ") + ";");
              this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
            }
            if (this.fullscreenElement_ == element) {
              return this.fullscreenWrapper_;
            }
            this.removeFullscreenWrapper();
            this.fullscreenElement_ = element;
            var parent = this.fullscreenElement_.parentElement;
            parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
            parent.removeChild(this.fullscreenElement_);
            this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
            this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
            var self2 = this;
            function applyFullscreenElementStyle() {
              if (!self2.fullscreenElement_) {
                return;
              }
              var cssProperties2 = [
                "position: absolute",
                "top: 0",
                "left: 0",
                "width: " + Math.max(screen.width, screen.height) + "px",
                "height: " + Math.min(screen.height, screen.width) + "px",
                "border: 0",
                "margin: 0",
                "padding: 0"
              ];
              self2.fullscreenElement_.setAttribute("style", cssProperties2.join("; ") + ";");
            }
            applyFullscreenElementStyle();
            return this.fullscreenWrapper_;
          };
          VRDisplay.prototype.removeFullscreenWrapper = function() {
            if (!this.fullscreenElement_) {
              return;
            }
            var element = this.fullscreenElement_;
            if (this.fullscreenElementCachedStyle_) {
              element.setAttribute("style", this.fullscreenElementCachedStyle_);
            } else {
              element.removeAttribute("style");
            }
            this.fullscreenElement_ = null;
            this.fullscreenElementCachedStyle_ = null;
            var parent = this.fullscreenWrapper_.parentElement;
            this.fullscreenWrapper_.removeChild(element);
            parent.insertBefore(element, this.fullscreenWrapper_);
            parent.removeChild(this.fullscreenWrapper_);
            return element;
          };
          VRDisplay.prototype.requestPresent = function(layers) {
            var wasPresenting = this.isPresenting;
            var self2 = this;
            if (!(layers instanceof Array)) {
              if (!hasShowDeprecationWarning) {
                console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
                hasShowDeprecationWarning = true;
              }
              layers = [layers];
            }
            return new Promise(function(resolve, reject) {
              if (!self2.capabilities.canPresent) {
                reject(new Error("VRDisplay is not capable of presenting."));
                return;
              }
              if (layers.length == 0 || layers.length > self2.capabilities.maxLayers) {
                reject(new Error("Invalid number of layers."));
                return;
              }
              var incomingLayer = layers[0];
              if (!incomingLayer.source) {
                resolve();
                return;
              }
              var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
              var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
              if (wasPresenting) {
                var layer = self2.layer_;
                if (layer.source !== incomingLayer.source) {
                  layer.source = incomingLayer.source;
                }
                for (var i = 0; i < 4; i++) {
                  if (layer.leftBounds[i] !== leftBounds[i]) {
                    layer.leftBounds[i] = leftBounds[i];
                  }
                  if (layer.rightBounds[i] !== rightBounds[i]) {
                    layer.rightBounds[i] = rightBounds[i];
                  }
                }
                resolve();
                return;
              }
              self2.layer_ = {
                predistorted: incomingLayer.predistorted,
                source: incomingLayer.source,
                leftBounds: leftBounds.slice(0),
                rightBounds: rightBounds.slice(0)
              };
              self2.waitingForPresent_ = false;
              if (self2.layer_ && self2.layer_.source) {
                let onFullscreenChange2 = function() {
                  var actualFullscreenElement = Util.getFullscreenElement();
                  self2.isPresenting = fullscreenElement === actualFullscreenElement;
                  if (self2.isPresenting) {
                    if (screen.orientation && screen.orientation.lock) {
                      screen.orientation.lock("landscape-primary").catch(function(error) {
                        console.error("screen.orientation.lock() failed due to", error.message);
                      });
                    }
                    self2.waitingForPresent_ = false;
                    self2.beginPresent_();
                    resolve();
                  } else {
                    if (screen.orientation && screen.orientation.unlock) {
                      screen.orientation.unlock();
                    }
                    self2.removeFullscreenWrapper();
                    self2.wakelock_.release();
                    self2.endPresent_();
                    self2.removeFullscreenListeners_();
                  }
                  self2.fireVRDisplayPresentChange_();
                }, onFullscreenError2 = function() {
                  if (!self2.waitingForPresent_) {
                    return;
                  }
                  self2.removeFullscreenWrapper();
                  self2.removeFullscreenListeners_();
                  self2.wakelock_.release();
                  self2.waitingForPresent_ = false;
                  self2.isPresenting = false;
                  reject(new Error("Unable to present."));
                };
                var onFullscreenChange = onFullscreenChange2, onFullscreenError = onFullscreenError2;
                var fullscreenElement = self2.wrapForFullscreen(self2.layer_.source);
                self2.addFullscreenListeners_(
                  fullscreenElement,
                  onFullscreenChange2,
                  onFullscreenError2
                );
                if (Util.requestFullscreen(fullscreenElement)) {
                  self2.wakelock_.request();
                  self2.waitingForPresent_ = true;
                } else if (Util.isIOS()) {
                  self2.wakelock_.request();
                  self2.isPresenting = true;
                  self2.beginPresent_();
                  self2.fireVRDisplayPresentChange_();
                  resolve();
                }
              }
              if (!self2.waitingForPresent_ && !Util.isIOS()) {
                Util.exitFullscreen();
                reject(new Error("Unable to present."));
              }
            });
          };
          VRDisplay.prototype.exitPresent = function() {
            var wasPresenting = this.isPresenting;
            var self2 = this;
            this.isPresenting = false;
            this.layer_ = null;
            this.wakelock_.release();
            return new Promise(function(resolve, reject) {
              if (wasPresenting) {
                if (!Util.exitFullscreen() && Util.isIOS()) {
                  self2.endPresent_();
                  self2.fireVRDisplayPresentChange_();
                }
                resolve();
              } else {
                reject(new Error("Was not presenting to VRDisplay."));
              }
            });
          };
          VRDisplay.prototype.getLayers = function() {
            if (this.layer_) {
              return [this.layer_];
            }
            return [];
          };
          VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
            var event = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
            window.dispatchEvent(event);
          };
          VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
            this.removeFullscreenListeners_();
            this.fullscreenEventTarget_ = element;
            this.fullscreenChangeHandler_ = changeHandler;
            this.fullscreenErrorHandler_ = errorHandler;
            if (changeHandler) {
              if (document.fullscreenEnabled) {
                element.addEventListener("fullscreenchange", changeHandler, false);
              } else if (document.webkitFullscreenEnabled) {
                element.addEventListener("webkitfullscreenchange", changeHandler, false);
              } else if (document.mozFullScreenEnabled) {
                document.addEventListener("mozfullscreenchange", changeHandler, false);
              } else if (document.msFullscreenEnabled) {
                element.addEventListener("msfullscreenchange", changeHandler, false);
              }
            }
            if (errorHandler) {
              if (document.fullscreenEnabled) {
                element.addEventListener("fullscreenerror", errorHandler, false);
              } else if (document.webkitFullscreenEnabled) {
                element.addEventListener("webkitfullscreenerror", errorHandler, false);
              } else if (document.mozFullScreenEnabled) {
                document.addEventListener("mozfullscreenerror", errorHandler, false);
              } else if (document.msFullscreenEnabled) {
                element.addEventListener("msfullscreenerror", errorHandler, false);
              }
            }
          };
          VRDisplay.prototype.removeFullscreenListeners_ = function() {
            if (!this.fullscreenEventTarget_)
              return;
            var element = this.fullscreenEventTarget_;
            if (this.fullscreenChangeHandler_) {
              var changeHandler = this.fullscreenChangeHandler_;
              element.removeEventListener("fullscreenchange", changeHandler, false);
              element.removeEventListener("webkitfullscreenchange", changeHandler, false);
              document.removeEventListener("mozfullscreenchange", changeHandler, false);
              element.removeEventListener("msfullscreenchange", changeHandler, false);
            }
            if (this.fullscreenErrorHandler_) {
              var errorHandler = this.fullscreenErrorHandler_;
              element.removeEventListener("fullscreenerror", errorHandler, false);
              element.removeEventListener("webkitfullscreenerror", errorHandler, false);
              document.removeEventListener("mozfullscreenerror", errorHandler, false);
              element.removeEventListener("msfullscreenerror", errorHandler, false);
            }
            this.fullscreenEventTarget_ = null;
            this.fullscreenChangeHandler_ = null;
            this.fullscreenErrorHandler_ = null;
          };
          VRDisplay.prototype.beginPresent_ = function() {
          };
          VRDisplay.prototype.endPresent_ = function() {
          };
          VRDisplay.prototype.submitFrame = function(pose) {
          };
          VRDisplay.prototype.getEyeParameters = function(whichEye) {
            return null;
          };
          function VRDevice() {
            this.isPolyfilled = true;
            this.hardwareUnitId = "webvr-polyfill hardwareUnitId";
            this.deviceId = "webvr-polyfill deviceId";
            this.deviceName = "webvr-polyfill deviceName";
          }
          function HMDVRDevice() {
          }
          HMDVRDevice.prototype = new VRDevice();
          function PositionSensorVRDevice() {
          }
          PositionSensorVRDevice.prototype = new VRDevice();
          module4.exports.VRFrameData = VRFrameData2;
          module4.exports.VRDisplay = VRDisplay;
          module4.exports.VRDevice = VRDevice;
          module4.exports.HMDVRDevice = HMDVRDevice;
          module4.exports.PositionSensorVRDevice = PositionSensorVRDevice;
        }, { "./util.js": 22, "./wakelock.js": 24 }], 3: [function(_dereq_2, module4, exports4) {
          var CardboardUI = _dereq_2("./cardboard-ui.js");
          var Util = _dereq_2("./util.js");
          var WGLUPreserveGLState = _dereq_2("./deps/wglu-preserve-state.js");
          var distortionVS = [
            "attribute vec2 position;",
            "attribute vec3 texCoord;",
            "varying vec2 vTexCoord;",
            "uniform vec4 viewportOffsetScale[2];",
            "void main() {",
            "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];",
            "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;",
            "  gl_Position = vec4( position, 1.0, 1.0 );",
            "}"
          ].join("\n");
          var distortionFS = [
            "precision mediump float;",
            "uniform sampler2D diffuse;",
            "varying vec2 vTexCoord;",
            "void main() {",
            "  gl_FragColor = texture2D(diffuse, vTexCoord);",
            "}"
          ].join("\n");
          function CardboardDistorter(gl) {
            this.gl = gl;
            this.ctxAttribs = gl.getContextAttributes();
            this.meshWidth = 20;
            this.meshHeight = 20;
            this.bufferScale = WebVRConfig.BUFFER_SCALE;
            this.bufferWidth = gl.drawingBufferWidth;
            this.bufferHeight = gl.drawingBufferHeight;
            this.realBindFramebuffer = gl.bindFramebuffer;
            this.realEnable = gl.enable;
            this.realDisable = gl.disable;
            this.realColorMask = gl.colorMask;
            this.realClearColor = gl.clearColor;
            this.realViewport = gl.viewport;
            if (!Util.isIOS()) {
              this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "width");
              this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "height");
            }
            this.isPatched = false;
            this.lastBoundFramebuffer = null;
            this.cullFace = false;
            this.depthTest = false;
            this.blend = false;
            this.scissorTest = false;
            this.stencilTest = false;
            this.viewport = [0, 0, 0, 0];
            this.colorMask = [true, true, true, true];
            this.clearColor = [0, 0, 0, 0];
            this.attribs = {
              position: 0,
              texCoord: 1
            };
            this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
            this.uniforms = Util.getProgramUniforms(gl, this.program);
            this.viewportOffsetScale = new Float32Array(8);
            this.setTextureBounds();
            this.vertexBuffer = gl.createBuffer();
            this.indexBuffer = gl.createBuffer();
            this.indexCount = 0;
            this.renderTarget = gl.createTexture();
            this.framebuffer = gl.createFramebuffer();
            this.depthStencilBuffer = null;
            this.depthBuffer = null;
            this.stencilBuffer = null;
            if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
              this.depthStencilBuffer = gl.createRenderbuffer();
            } else if (this.ctxAttribs.depth) {
              this.depthBuffer = gl.createRenderbuffer();
            } else if (this.ctxAttribs.stencil) {
              this.stencilBuffer = gl.createRenderbuffer();
            }
            this.patch();
            this.onResize();
            if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
              this.cardboardUI = new CardboardUI(gl);
            }
          }
          ;
          CardboardDistorter.prototype.destroy = function() {
            var gl = this.gl;
            this.unpatch();
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.vertexBuffer);
            gl.deleteBuffer(this.indexBuffer);
            gl.deleteTexture(this.renderTarget);
            gl.deleteFramebuffer(this.framebuffer);
            if (this.depthStencilBuffer) {
              gl.deleteRenderbuffer(this.depthStencilBuffer);
            }
            if (this.depthBuffer) {
              gl.deleteRenderbuffer(this.depthBuffer);
            }
            if (this.stencilBuffer) {
              gl.deleteRenderbuffer(this.stencilBuffer);
            }
            if (this.cardboardUI) {
              this.cardboardUI.destroy();
            }
          };
          CardboardDistorter.prototype.onResize = function() {
            var gl = this.gl;
            var self2 = this;
            var glState = [
              gl.RENDERBUFFER_BINDING,
              gl.TEXTURE_BINDING_2D,
              gl.TEXTURE0
            ];
            WGLUPreserveGLState(gl, glState, function(gl2) {
              self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
              if (self2.scissorTest) {
                self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
              }
              self2.realColorMask.call(gl2, true, true, true, true);
              self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
              self2.realClearColor.call(gl2, 0, 0, 0, 1);
              gl2.clear(gl2.COLOR_BUFFER_BIT);
              self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.framebuffer);
              gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
              gl2.texImage2D(
                gl2.TEXTURE_2D,
                0,
                self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB,
                self2.bufferWidth,
                self2.bufferHeight,
                0,
                self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB,
                gl2.UNSIGNED_BYTE,
                null
              );
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
              gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
              gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, self2.renderTarget, 0);
              if (self2.ctxAttribs.depth && self2.ctxAttribs.stencil) {
                gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthStencilBuffer);
                gl2.renderbufferStorage(
                  gl2.RENDERBUFFER,
                  gl2.DEPTH_STENCIL,
                  self2.bufferWidth,
                  self2.bufferHeight
                );
                gl2.framebufferRenderbuffer(
                  gl2.FRAMEBUFFER,
                  gl2.DEPTH_STENCIL_ATTACHMENT,
                  gl2.RENDERBUFFER,
                  self2.depthStencilBuffer
                );
              } else if (self2.ctxAttribs.depth) {
                gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthBuffer);
                gl2.renderbufferStorage(
                  gl2.RENDERBUFFER,
                  gl2.DEPTH_COMPONENT16,
                  self2.bufferWidth,
                  self2.bufferHeight
                );
                gl2.framebufferRenderbuffer(
                  gl2.FRAMEBUFFER,
                  gl2.DEPTH_ATTACHMENT,
                  gl2.RENDERBUFFER,
                  self2.depthBuffer
                );
              } else if (self2.ctxAttribs.stencil) {
                gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.stencilBuffer);
                gl2.renderbufferStorage(
                  gl2.RENDERBUFFER,
                  gl2.STENCIL_INDEX8,
                  self2.bufferWidth,
                  self2.bufferHeight
                );
                gl2.framebufferRenderbuffer(
                  gl2.FRAMEBUFFER,
                  gl2.STENCIL_ATTACHMENT,
                  gl2.RENDERBUFFER,
                  self2.stencilBuffer
                );
              }
              if (!gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE) {
                console.error("Framebuffer incomplete!");
              }
              self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
              if (self2.scissorTest) {
                self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
              }
              self2.realColorMask.apply(gl2, self2.colorMask);
              self2.realViewport.apply(gl2, self2.viewport);
              self2.realClearColor.apply(gl2, self2.clearColor);
            });
            if (this.cardboardUI) {
              this.cardboardUI.onResize();
            }
          };
          CardboardDistorter.prototype.patch = function() {
            if (this.isPatched) {
              return;
            }
            var self2 = this;
            var canvas = this.gl.canvas;
            var gl = this.gl;
            if (!Util.isIOS()) {
              canvas.width = Util.getScreenWidth() * this.bufferScale;
              canvas.height = Util.getScreenHeight() * this.bufferScale;
              Object.defineProperty(canvas, "width", {
                configurable: true,
                enumerable: true,
                get: function() {
                  return self2.bufferWidth;
                },
                set: function(value) {
                  self2.bufferWidth = value;
                  self2.realCanvasWidth.set.call(canvas, value);
                  self2.onResize();
                }
              });
              Object.defineProperty(canvas, "height", {
                configurable: true,
                enumerable: true,
                get: function() {
                  return self2.bufferHeight;
                },
                set: function(value) {
                  self2.bufferHeight = value;
                  self2.realCanvasHeight.set.call(canvas, value);
                  self2.onResize();
                }
              });
            }
            this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
            if (this.lastBoundFramebuffer == null) {
              this.lastBoundFramebuffer = this.framebuffer;
              this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            }
            this.gl.bindFramebuffer = function(target, framebuffer) {
              self2.lastBoundFramebuffer = framebuffer ? framebuffer : self2.framebuffer;
              self2.realBindFramebuffer.call(gl, target, self2.lastBoundFramebuffer);
            };
            this.cullFace = gl.getParameter(gl.CULL_FACE);
            this.depthTest = gl.getParameter(gl.DEPTH_TEST);
            this.blend = gl.getParameter(gl.BLEND);
            this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
            this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
            gl.enable = function(pname) {
              switch (pname) {
                case gl.CULL_FACE:
                  self2.cullFace = true;
                  break;
                case gl.DEPTH_TEST:
                  self2.depthTest = true;
                  break;
                case gl.BLEND:
                  self2.blend = true;
                  break;
                case gl.SCISSOR_TEST:
                  self2.scissorTest = true;
                  break;
                case gl.STENCIL_TEST:
                  self2.stencilTest = true;
                  break;
              }
              self2.realEnable.call(gl, pname);
            };
            gl.disable = function(pname) {
              switch (pname) {
                case gl.CULL_FACE:
                  self2.cullFace = false;
                  break;
                case gl.DEPTH_TEST:
                  self2.depthTest = false;
                  break;
                case gl.BLEND:
                  self2.blend = false;
                  break;
                case gl.SCISSOR_TEST:
                  self2.scissorTest = false;
                  break;
                case gl.STENCIL_TEST:
                  self2.stencilTest = false;
                  break;
              }
              self2.realDisable.call(gl, pname);
            };
            this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
            gl.colorMask = function(r, g, b, a) {
              self2.colorMask[0] = r;
              self2.colorMask[1] = g;
              self2.colorMask[2] = b;
              self2.colorMask[3] = a;
              self2.realColorMask.call(gl, r, g, b, a);
            };
            this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
            gl.clearColor = function(r, g, b, a) {
              self2.clearColor[0] = r;
              self2.clearColor[1] = g;
              self2.clearColor[2] = b;
              self2.clearColor[3] = a;
              self2.realClearColor.call(gl, r, g, b, a);
            };
            this.viewport = gl.getParameter(gl.VIEWPORT);
            gl.viewport = function(x, y, w, h) {
              self2.viewport[0] = x;
              self2.viewport[1] = y;
              self2.viewport[2] = w;
              self2.viewport[3] = h;
              self2.realViewport.call(gl, x, y, w, h);
            };
            this.isPatched = true;
            Util.safariCssSizeWorkaround(canvas);
          };
          CardboardDistorter.prototype.unpatch = function() {
            if (!this.isPatched) {
              return;
            }
            var gl = this.gl;
            var canvas = this.gl.canvas;
            if (!Util.isIOS()) {
              Object.defineProperty(canvas, "width", this.realCanvasWidth);
              Object.defineProperty(canvas, "height", this.realCanvasHeight);
            }
            canvas.width = this.bufferWidth;
            canvas.height = this.bufferHeight;
            gl.bindFramebuffer = this.realBindFramebuffer;
            gl.enable = this.realEnable;
            gl.disable = this.realDisable;
            gl.colorMask = this.realColorMask;
            gl.clearColor = this.realClearColor;
            gl.viewport = this.realViewport;
            if (this.lastBoundFramebuffer == this.framebuffer) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            this.isPatched = false;
            setTimeout(function() {
              Util.safariCssSizeWorkaround(canvas);
            }, 1);
          };
          CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
            if (!leftBounds) {
              leftBounds = [0, 0, 0.5, 1];
            }
            if (!rightBounds) {
              rightBounds = [0.5, 0, 0.5, 1];
            }
            this.viewportOffsetScale[0] = leftBounds[0];
            this.viewportOffsetScale[1] = leftBounds[1];
            this.viewportOffsetScale[2] = leftBounds[2];
            this.viewportOffsetScale[3] = leftBounds[3];
            this.viewportOffsetScale[4] = rightBounds[0];
            this.viewportOffsetScale[5] = rightBounds[1];
            this.viewportOffsetScale[6] = rightBounds[2];
            this.viewportOffsetScale[7] = rightBounds[3];
          };
          CardboardDistorter.prototype.submitFrame = function() {
            var gl = this.gl;
            var self2 = this;
            var glState = [];
            if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
              glState.push(
                gl.CURRENT_PROGRAM,
                gl.ARRAY_BUFFER_BINDING,
                gl.ELEMENT_ARRAY_BUFFER_BINDING,
                gl.TEXTURE_BINDING_2D,
                gl.TEXTURE0
              );
            }
            WGLUPreserveGLState(gl, glState, function(gl2) {
              self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
              if (self2.cullFace) {
                self2.realDisable.call(gl2, gl2.CULL_FACE);
              }
              if (self2.depthTest) {
                self2.realDisable.call(gl2, gl2.DEPTH_TEST);
              }
              if (self2.blend) {
                self2.realDisable.call(gl2, gl2.BLEND);
              }
              if (self2.scissorTest) {
                self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
              }
              if (self2.stencilTest) {
                self2.realDisable.call(gl2, gl2.STENCIL_TEST);
              }
              self2.realColorMask.call(gl2, true, true, true, true);
              self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
              if (self2.ctxAttribs.alpha || Util.isIOS()) {
                self2.realClearColor.call(gl2, 0, 0, 0, 1);
                gl2.clear(gl2.COLOR_BUFFER_BIT);
              }
              gl2.useProgram(self2.program);
              gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
              gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
              gl2.enableVertexAttribArray(self2.attribs.position);
              gl2.enableVertexAttribArray(self2.attribs.texCoord);
              gl2.vertexAttribPointer(self2.attribs.position, 2, gl2.FLOAT, false, 20, 0);
              gl2.vertexAttribPointer(self2.attribs.texCoord, 3, gl2.FLOAT, false, 20, 8);
              gl2.activeTexture(gl2.TEXTURE0);
              gl2.uniform1i(self2.uniforms.diffuse, 0);
              gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
              gl2.uniform4fv(self2.uniforms.viewportOffsetScale, self2.viewportOffsetScale);
              gl2.drawElements(gl2.TRIANGLES, self2.indexCount, gl2.UNSIGNED_SHORT, 0);
              if (self2.cardboardUI) {
                self2.cardboardUI.renderNoState();
              }
              self2.realBindFramebuffer.call(self2.gl, gl2.FRAMEBUFFER, self2.framebuffer);
              if (!self2.ctxAttribs.preserveDrawingBuffer) {
                self2.realClearColor.call(gl2, 0, 0, 0, 0);
                gl2.clear(gl2.COLOR_BUFFER_BIT);
              }
              if (!WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
                self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
              }
              if (self2.cullFace) {
                self2.realEnable.call(gl2, gl2.CULL_FACE);
              }
              if (self2.depthTest) {
                self2.realEnable.call(gl2, gl2.DEPTH_TEST);
              }
              if (self2.blend) {
                self2.realEnable.call(gl2, gl2.BLEND);
              }
              if (self2.scissorTest) {
                self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
              }
              if (self2.stencilTest) {
                self2.realEnable.call(gl2, gl2.STENCIL_TEST);
              }
              self2.realColorMask.apply(gl2, self2.colorMask);
              self2.realViewport.apply(gl2, self2.viewport);
              if (self2.ctxAttribs.alpha || !self2.ctxAttribs.preserveDrawingBuffer) {
                self2.realClearColor.apply(gl2, self2.clearColor);
              }
            });
            if (Util.isIOS()) {
              var canvas = gl.canvas;
              if (canvas.width != self2.bufferWidth || canvas.height != self2.bufferHeight) {
                self2.bufferWidth = canvas.width;
                self2.bufferHeight = canvas.height;
                self2.onResize();
              }
            }
          };
          CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
            var gl = this.gl;
            var self2 = this;
            var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
            WGLUPreserveGLState(gl, glState, function(gl2) {
              var vertices = self2.computeMeshVertices_(self2.meshWidth, self2.meshHeight, deviceInfo);
              gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
              gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW);
              if (!self2.indexCount) {
                var indices = self2.computeMeshIndices_(self2.meshWidth, self2.meshHeight);
                gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
                gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, indices, gl2.STATIC_DRAW);
                self2.indexCount = indices.length;
              }
            });
          };
          CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
            var vertices = new Float32Array(2 * width * height * 5);
            var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
            var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
            var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
            var vidx = 0;
            var iidx = 0;
            for (var e2 = 0; e2 < 2; e2++) {
              for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++, vidx++) {
                  var u = i / (width - 1);
                  var v = j / (height - 1);
                  var s = u;
                  var t = v;
                  var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
                  var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
                  var d = Math.sqrt(x * x + y * y);
                  var r = deviceInfo.distortion.distortInverse(d);
                  var p = x * r / d;
                  var q = y * r / d;
                  u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
                  v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
                  var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;
                  u = (viewport.x + u * viewport.width - 0.5) * 2;
                  v = (viewport.y + v * viewport.height - 0.5) * 2;
                  vertices[vidx * 5 + 0] = u;
                  vertices[vidx * 5 + 1] = v;
                  vertices[vidx * 5 + 2] = s;
                  vertices[vidx * 5 + 3] = t;
                  vertices[vidx * 5 + 4] = e2;
                }
              }
              var w = lensFrustum[2] - lensFrustum[0];
              lensFrustum[0] = -(w + lensFrustum[0]);
              lensFrustum[2] = w - lensFrustum[2];
              w = noLensFrustum[2] - noLensFrustum[0];
              noLensFrustum[0] = -(w + noLensFrustum[0]);
              noLensFrustum[2] = w - noLensFrustum[2];
              viewport.x = 1 - (viewport.x + viewport.width);
            }
            return vertices;
          };
          CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
            var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
            var halfwidth = width / 2;
            var halfheight = height / 2;
            var vidx = 0;
            var iidx = 0;
            for (var e2 = 0; e2 < 2; e2++) {
              for (var j = 0; j < height; j++) {
                for (var i = 0; i < width; i++, vidx++) {
                  if (i == 0 || j == 0)
                    continue;
                  if (i <= halfwidth == j <= halfheight) {
                    indices[iidx++] = vidx;
                    indices[iidx++] = vidx - width - 1;
                    indices[iidx++] = vidx - width;
                    indices[iidx++] = vidx - width - 1;
                    indices[iidx++] = vidx;
                    indices[iidx++] = vidx - 1;
                  } else {
                    indices[iidx++] = vidx - 1;
                    indices[iidx++] = vidx - width;
                    indices[iidx++] = vidx;
                    indices[iidx++] = vidx - width;
                    indices[iidx++] = vidx - 1;
                    indices[iidx++] = vidx - width - 1;
                  }
                }
              }
            }
            return indices;
          };
          CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
            var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
            if (descriptor.get === void 0 || descriptor.set === void 0) {
              descriptor.configurable = true;
              descriptor.enumerable = true;
              descriptor.get = function() {
                return this.getAttribute(attrName);
              };
              descriptor.set = function(val) {
                this.setAttribute(attrName, val);
              };
            }
            return descriptor;
          };
          module4.exports = CardboardDistorter;
        }, { "./cardboard-ui.js": 4, "./deps/wglu-preserve-state.js": 6, "./util.js": 22 }], 4: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          var WGLUPreserveGLState = _dereq_2("./deps/wglu-preserve-state.js");
          var uiVS = [
            "attribute vec2 position;",
            "uniform mat4 projectionMat;",
            "void main() {",
            "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );",
            "}"
          ].join("\n");
          var uiFS = [
            "precision mediump float;",
            "uniform vec4 color;",
            "void main() {",
            "  gl_FragColor = color;",
            "}"
          ].join("\n");
          var DEG2RAD = Math.PI / 180;
          var kAnglePerGearSection = 60;
          var kOuterRimEndAngle = 12;
          var kInnerRimBeginAngle = 20;
          var kOuterRadius = 1;
          var kMiddleRadius = 0.75;
          var kInnerRadius = 0.3125;
          var kCenterLineThicknessDp = 4;
          var kButtonWidthDp = 28;
          var kTouchSlopFactor = 1.5;
          var Angles = [
            0,
            kOuterRimEndAngle,
            kInnerRimBeginAngle,
            kAnglePerGearSection - kInnerRimBeginAngle,
            kAnglePerGearSection - kOuterRimEndAngle
          ];
          function CardboardUI(gl) {
            this.gl = gl;
            this.attribs = {
              position: 0
            };
            this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
            this.uniforms = Util.getProgramUniforms(gl, this.program);
            this.vertexBuffer = gl.createBuffer();
            this.gearOffset = 0;
            this.gearVertexCount = 0;
            this.arrowOffset = 0;
            this.arrowVertexCount = 0;
            this.projMat = new Float32Array(16);
            this.listener = null;
            this.onResize();
          }
          ;
          CardboardUI.prototype.destroy = function() {
            var gl = this.gl;
            if (this.listener) {
              gl.canvas.removeEventListener("click", this.listener, false);
            }
            gl.deleteProgram(this.program);
            gl.deleteBuffer(this.vertexBuffer);
          };
          CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
            var canvas = this.gl.canvas;
            this.listener = function(event) {
              var midline = canvas.clientWidth / 2;
              var buttonSize = kButtonWidthDp * kTouchSlopFactor;
              if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
                optionsCallback(event);
              } else if (event.clientX < buttonSize && event.clientY < buttonSize) {
                backCallback(event);
              }
            };
            canvas.addEventListener("click", this.listener, false);
          };
          CardboardUI.prototype.onResize = function() {
            var gl = this.gl;
            var self2 = this;
            var glState = [
              gl.ARRAY_BUFFER_BINDING
            ];
            WGLUPreserveGLState(gl, glState, function(gl2) {
              var vertices = [];
              var midline = gl2.drawingBufferWidth / 2;
              var dps = gl2.drawingBufferWidth / (screen.width * window.devicePixelRatio);
              if (!Util.isIOS()) {
                dps *= window.devicePixelRatio;
              }
              var lineWidth = kCenterLineThicknessDp * dps / 2;
              var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
              var buttonScale = kButtonWidthDp * dps / 2;
              var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
              vertices.push(midline - lineWidth, buttonSize);
              vertices.push(midline - lineWidth, gl2.drawingBufferHeight);
              vertices.push(midline + lineWidth, buttonSize);
              vertices.push(midline + lineWidth, gl2.drawingBufferHeight);
              self2.gearOffset = vertices.length / 2;
              function addGearSegment(theta, r) {
                var angle = (90 - theta) * DEG2RAD;
                var x = Math.cos(angle);
                var y = Math.sin(angle);
                vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
                vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
              }
              for (var i = 0; i <= 6; i++) {
                var segmentTheta = i * kAnglePerGearSection;
                addGearSegment(segmentTheta, kOuterRadius);
                addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
                addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
                addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
                addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
              }
              self2.gearVertexCount = vertices.length / 2 - self2.gearOffset;
              self2.arrowOffset = vertices.length / 2;
              function addArrowVertex(x, y) {
                vertices.push(buttonBorder + x, gl2.drawingBufferHeight - buttonBorder - y);
              }
              var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
              addArrowVertex(0, buttonScale);
              addArrowVertex(buttonScale, 0);
              addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
              addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
              addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
              addArrowVertex(0, buttonScale);
              addArrowVertex(buttonScale, buttonScale * 2);
              addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
              addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
              addArrowVertex(0, buttonScale);
              addArrowVertex(angledLineWidth, buttonScale - lineWidth);
              addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
              addArrowVertex(angledLineWidth, buttonScale + lineWidth);
              addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
              self2.arrowVertexCount = vertices.length / 2 - self2.arrowOffset;
              gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
              gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(vertices), gl2.STATIC_DRAW);
            });
          };
          CardboardUI.prototype.render = function() {
            var gl = this.gl;
            var self2 = this;
            var glState = [
              gl.CULL_FACE,
              gl.DEPTH_TEST,
              gl.BLEND,
              gl.SCISSOR_TEST,
              gl.STENCIL_TEST,
              gl.COLOR_WRITEMASK,
              gl.VIEWPORT,
              gl.CURRENT_PROGRAM,
              gl.ARRAY_BUFFER_BINDING
            ];
            WGLUPreserveGLState(gl, glState, function(gl2) {
              gl2.disable(gl2.CULL_FACE);
              gl2.disable(gl2.DEPTH_TEST);
              gl2.disable(gl2.BLEND);
              gl2.disable(gl2.SCISSOR_TEST);
              gl2.disable(gl2.STENCIL_TEST);
              gl2.colorMask(true, true, true, true);
              gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
              self2.renderNoState();
            });
          };
          CardboardUI.prototype.renderNoState = function() {
            var gl = this.gl;
            gl.useProgram(this.program);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.enableVertexAttribArray(this.attribs.position);
            gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
            gl.uniform4f(this.uniforms.color, 1, 1, 1, 1);
            Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024);
            gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
            gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
          };
          module4.exports = CardboardUI;
        }, { "./deps/wglu-preserve-state.js": 6, "./util.js": 22 }], 5: [function(_dereq_2, module4, exports4) {
          var CardboardDistorter = _dereq_2("./cardboard-distorter.js");
          var CardboardUI = _dereq_2("./cardboard-ui.js");
          var DeviceInfo = _dereq_2("./device-info.js");
          var Dpdb = _dereq_2("./dpdb/dpdb.js");
          var FusionPoseSensor = _dereq_2("./sensor-fusion/fusion-pose-sensor.js");
          var RotateInstructions = _dereq_2("./rotate-instructions.js");
          var ViewerSelector = _dereq_2("./viewer-selector.js");
          var VRDisplay = _dereq_2("./base.js").VRDisplay;
          var Util = _dereq_2("./util.js");
          var Eye = {
            LEFT: "left",
            RIGHT: "right"
          };
          function CardboardVRDisplay() {
            this.displayName = "Cardboard VRDisplay (webvr-polyfill)";
            this.capabilities.hasOrientation = true;
            this.capabilities.canPresent = true;
            this.bufferScale_ = WebVRConfig.BUFFER_SCALE;
            this.poseSensor_ = new FusionPoseSensor();
            this.distorter_ = null;
            this.cardboardUI_ = null;
            this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
            this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());
            this.viewerSelector_ = new ViewerSelector();
            this.viewerSelector_.on("change", this.onViewerChanged_.bind(this));
            this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
            if (!WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
              this.rotateInstructions_ = new RotateInstructions();
            }
            if (Util.isIOS()) {
              window.addEventListener("resize", this.onResize_.bind(this));
            }
          }
          CardboardVRDisplay.prototype = new VRDisplay();
          CardboardVRDisplay.prototype.getImmediatePose = function() {
            return {
              position: this.poseSensor_.getPosition(),
              orientation: this.poseSensor_.getOrientation(),
              linearVelocity: null,
              linearAcceleration: null,
              angularVelocity: null,
              angularAcceleration: null
            };
          };
          CardboardVRDisplay.prototype.resetPose = function() {
            this.poseSensor_.resetPose();
          };
          CardboardVRDisplay.prototype.getEyeParameters = function(whichEye) {
            var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
            var fieldOfView;
            if (whichEye == Eye.LEFT) {
              offset[0] *= -1;
              fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
            } else if (whichEye == Eye.RIGHT) {
              fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
            } else {
              console.error("Invalid eye provided: %s", whichEye);
              return null;
            }
            return {
              fieldOfView,
              offset,
              // TODO: Should be able to provide better values than these.
              renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
              renderHeight: this.deviceInfo_.device.height * this.bufferScale_
            };
          };
          CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function(newParams) {
            console.log("DPDB reported that device params were updated.");
            this.deviceInfo_.updateDeviceParams(newParams);
            if (this.distorter_) {
              this.distorter_.updateDeviceInfo(this.deviceInfo_);
            }
          };
          CardboardVRDisplay.prototype.updateBounds_ = function() {
            if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
              this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
            }
          };
          CardboardVRDisplay.prototype.beginPresent_ = function() {
            var gl = this.layer_.source.getContext("webgl");
            if (!gl)
              gl = this.layer_.source.getContext("experimental-webgl");
            if (!gl)
              gl = this.layer_.source.getContext("webgl2");
            if (!gl)
              return;
            if (this.layer_.predistorted) {
              if (!WebVRConfig.CARDBOARD_UI_DISABLED) {
                gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
                gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
                this.cardboardUI_ = new CardboardUI(gl);
              }
            } else {
              this.distorter_ = new CardboardDistorter(gl);
              this.distorter_.updateDeviceInfo(this.deviceInfo_);
              this.cardboardUI_ = this.distorter_.cardboardUI;
            }
            if (this.cardboardUI_) {
              this.cardboardUI_.listen((function(e2) {
                this.viewerSelector_.show(this.layer_.source.parentElement);
                e2.stopPropagation();
                e2.preventDefault();
              }).bind(this), (function(e2) {
                this.exitPresent();
                e2.stopPropagation();
                e2.preventDefault();
              }).bind(this));
            }
            if (this.rotateInstructions_) {
              if (Util.isLandscapeMode() && Util.isMobile()) {
                this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement);
              } else {
                this.rotateInstructions_.update();
              }
            }
            this.orientationHandler = this.onOrientationChange_.bind(this);
            window.addEventListener("orientationchange", this.orientationHandler);
            this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
            window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
            this.fireVRDisplayDeviceParamsChange_();
          };
          CardboardVRDisplay.prototype.endPresent_ = function() {
            if (this.distorter_) {
              this.distorter_.destroy();
              this.distorter_ = null;
            }
            if (this.cardboardUI_) {
              this.cardboardUI_.destroy();
              this.cardboardUI_ = null;
            }
            if (this.rotateInstructions_) {
              this.rotateInstructions_.hide();
            }
            this.viewerSelector_.hide();
            window.removeEventListener("orientationchange", this.orientationHandler);
            window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
          };
          CardboardVRDisplay.prototype.submitFrame = function(pose) {
            if (this.distorter_) {
              this.distorter_.submitFrame();
            } else if (this.cardboardUI_ && this.layer_) {
              var canvas = this.layer_.source.getContext("webgl").canvas;
              if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
                this.cardboardUI_.onResize();
              }
              this.lastWidth = canvas.width;
              this.lastHeight = canvas.height;
              this.cardboardUI_.render();
            }
          };
          CardboardVRDisplay.prototype.onOrientationChange_ = function(e2) {
            console.log("onOrientationChange_");
            this.viewerSelector_.hide();
            if (this.rotateInstructions_) {
              this.rotateInstructions_.update();
            }
            this.onResize_();
          };
          CardboardVRDisplay.prototype.onResize_ = function(e2) {
            if (this.layer_) {
              var gl = this.layer_.source.getContext("webgl");
              var cssProperties = [
                "position: absolute",
                "top: 0",
                "left: 0",
                "width: " + Math.max(screen.width, screen.height) + "px",
                "height: " + Math.min(screen.height, screen.width) + "px",
                "border: 0",
                "margin: 0",
                "padding: 0 10px 10px 0"
              ];
              gl.canvas.setAttribute("style", cssProperties.join("; ") + ";");
              Util.safariCssSizeWorkaround(gl.canvas);
            }
          };
          CardboardVRDisplay.prototype.onViewerChanged_ = function(viewer) {
            this.deviceInfo_.setViewer(viewer);
            if (this.distorter_) {
              this.distorter_.updateDeviceInfo(this.deviceInfo_);
            }
            this.fireVRDisplayDeviceParamsChange_();
          };
          CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function() {
            var event = new CustomEvent("vrdisplaydeviceparamschange", {
              detail: {
                vrdisplay: this,
                deviceInfo: this.deviceInfo_
              }
            });
            window.dispatchEvent(event);
          };
          module4.exports = CardboardVRDisplay;
        }, { "./base.js": 2, "./cardboard-distorter.js": 3, "./cardboard-ui.js": 4, "./device-info.js": 7, "./dpdb/dpdb.js": 11, "./rotate-instructions.js": 16, "./sensor-fusion/fusion-pose-sensor.js": 18, "./util.js": 22, "./viewer-selector.js": 23 }], 6: [function(_dereq_2, module4, exports4) {
          function WGLUPreserveGLState(gl, bindings, callback) {
            if (!bindings) {
              callback(gl);
              return;
            }
            var boundValues = [];
            var activeTexture = null;
            for (var i = 0; i < bindings.length; ++i) {
              var binding = bindings[i];
              switch (binding) {
                case gl.TEXTURE_BINDING_2D:
                case gl.TEXTURE_BINDING_CUBE_MAP:
                  var textureUnit = bindings[++i];
                  if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
                    console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
                    boundValues.push(null, null);
                    break;
                  }
                  if (!activeTexture) {
                    activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
                  }
                  gl.activeTexture(textureUnit);
                  boundValues.push(gl.getParameter(binding), null);
                  break;
                case gl.ACTIVE_TEXTURE:
                  activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
                  boundValues.push(null);
                  break;
                default:
                  boundValues.push(gl.getParameter(binding));
                  break;
              }
            }
            callback(gl);
            for (var i = 0; i < bindings.length; ++i) {
              var binding = bindings[i];
              var boundValue = boundValues[i];
              switch (binding) {
                case gl.ACTIVE_TEXTURE:
                  break;
                case gl.ARRAY_BUFFER_BINDING:
                  gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
                  break;
                case gl.COLOR_CLEAR_VALUE:
                  gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                  break;
                case gl.COLOR_WRITEMASK:
                  gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                  break;
                case gl.CURRENT_PROGRAM:
                  gl.useProgram(boundValue);
                  break;
                case gl.ELEMENT_ARRAY_BUFFER_BINDING:
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
                  break;
                case gl.FRAMEBUFFER_BINDING:
                  gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
                  break;
                case gl.RENDERBUFFER_BINDING:
                  gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
                  break;
                case gl.TEXTURE_BINDING_2D:
                  var textureUnit = bindings[++i];
                  if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                    break;
                  gl.activeTexture(textureUnit);
                  gl.bindTexture(gl.TEXTURE_2D, boundValue);
                  break;
                case gl.TEXTURE_BINDING_CUBE_MAP:
                  var textureUnit = bindings[++i];
                  if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                    break;
                  gl.activeTexture(textureUnit);
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
                  break;
                case gl.VIEWPORT:
                  gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                  break;
                case gl.BLEND:
                case gl.CULL_FACE:
                case gl.DEPTH_TEST:
                case gl.SCISSOR_TEST:
                case gl.STENCIL_TEST:
                  if (boundValue) {
                    gl.enable(binding);
                  } else {
                    gl.disable(binding);
                  }
                  break;
                default:
                  console.log("No GL restore behavior for 0x" + binding.toString(16));
                  break;
              }
              if (activeTexture) {
                gl.activeTexture(activeTexture);
              }
            }
          }
          module4.exports = WGLUPreserveGLState;
        }, {}], 7: [function(_dereq_2, module4, exports4) {
          var Distortion = _dereq_2("./distortion/distortion.js");
          var MathUtil = _dereq_2("./math-util.js");
          var Util = _dereq_2("./util.js");
          function Device(params) {
            this.width = params.width || Util.getScreenWidth();
            this.height = params.height || Util.getScreenHeight();
            this.widthMeters = params.widthMeters;
            this.heightMeters = params.heightMeters;
            this.bevelMeters = params.bevelMeters;
          }
          var DEFAULT_ANDROID = new Device({
            widthMeters: 0.11,
            heightMeters: 0.062,
            bevelMeters: 4e-3
          });
          var DEFAULT_IOS = new Device({
            widthMeters: 0.1038,
            heightMeters: 0.0584,
            bevelMeters: 4e-3
          });
          var Viewers = {
            CardboardV1: new CardboardViewer({
              id: "CardboardV1",
              label: "Cardboard I/O 2014",
              fov: 40,
              interLensDistance: 0.06,
              baselineLensDistance: 0.035,
              screenLensDistance: 0.042,
              distortionCoefficients: [0.441, 0.156],
              inverseCoefficients: [
                -0.4410035,
                0.42756155,
                -0.4804439,
                0.5460139,
                -0.58821183,
                0.5733938,
                -0.48303202,
                0.33299083,
                -0.17573841,
                0.0651772,
                -0.01488963,
                1559834e-9
              ]
            }),
            CardboardV2: new CardboardViewer({
              id: "CardboardV2",
              label: "Cardboard I/O 2015",
              fov: 60,
              interLensDistance: 0.064,
              baselineLensDistance: 0.035,
              screenLensDistance: 0.039,
              distortionCoefficients: [0.34, 0.55],
              inverseCoefficients: [
                -0.33836704,
                -0.18162185,
                0.862655,
                -1.2462051,
                1.0560602,
                -0.58208317,
                0.21609078,
                -0.05444823,
                9177956e-9,
                -9904169e-10,
                6183535e-11,
                -16981803e-13
              ]
            })
          };
          var DEFAULT_LEFT_CENTER = { x: 0.5, y: 0.5 };
          var DEFAULT_RIGHT_CENTER = { x: 0.5, y: 0.5 };
          function DeviceInfo(deviceParams) {
            this.viewer = Viewers.CardboardV2;
            this.updateDeviceParams(deviceParams);
            this.distortion = new Distortion(this.viewer.distortionCoefficients);
          }
          DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
            this.device = this.determineDevice_(deviceParams) || this.device;
          };
          DeviceInfo.prototype.getDevice = function() {
            return this.device;
          };
          DeviceInfo.prototype.setViewer = function(viewer) {
            this.viewer = viewer;
            this.distortion = new Distortion(this.viewer.distortionCoefficients);
          };
          DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
            if (!deviceParams) {
              if (Util.isIOS()) {
                console.warn("Using fallback iOS device measurements.");
                return DEFAULT_IOS;
              } else {
                console.warn("Using fallback Android device measurements.");
                return DEFAULT_ANDROID;
              }
            }
            var METERS_PER_INCH = 0.0254;
            var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
            var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
            var width = Util.getScreenWidth();
            var height = Util.getScreenHeight();
            return new Device({
              widthMeters: metersPerPixelX * width,
              heightMeters: metersPerPixelY * height,
              bevelMeters: deviceParams.bevelMm * 1e-3
            });
          };
          DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
            var viewer = this.viewer;
            var device = this.device;
            var distortion = this.distortion;
            var eyeToScreenDistance = viewer.screenLensDistance;
            var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
            var innerDist = viewer.interLensDistance / 2;
            var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
            var topDist = device.heightMeters - bottomDist;
            var outerAngle = MathUtil.radToDeg * Math.atan(
              distortion.distort(outerDist / eyeToScreenDistance)
            );
            var innerAngle = MathUtil.radToDeg * Math.atan(
              distortion.distort(innerDist / eyeToScreenDistance)
            );
            var bottomAngle = MathUtil.radToDeg * Math.atan(
              distortion.distort(bottomDist / eyeToScreenDistance)
            );
            var topAngle = MathUtil.radToDeg * Math.atan(
              distortion.distort(topDist / eyeToScreenDistance)
            );
            return {
              leftDegrees: Math.min(outerAngle, viewer.fov),
              rightDegrees: Math.min(innerAngle, viewer.fov),
              downDegrees: Math.min(bottomAngle, viewer.fov),
              upDegrees: Math.min(topAngle, viewer.fov)
            };
          };
          DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
            var viewer = this.viewer;
            var device = this.device;
            var distortion = this.distortion;
            var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
            var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
            var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
            var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
            var halfWidth = device.widthMeters / 4;
            var halfHeight = device.heightMeters / 2;
            var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
            var centerX = viewer.interLensDistance / 2 - halfWidth;
            var centerY = -verticalLensOffset;
            var centerZ = viewer.screenLensDistance;
            var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
            var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
            var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
            var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
            var result = new Float32Array(4);
            result[0] = Math.max(fovLeft, screenLeft);
            result[1] = Math.min(fovTop, screenTop);
            result[2] = Math.min(fovRight, screenRight);
            result[3] = Math.max(fovBottom, screenBottom);
            return result;
          };
          DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
            var viewer = this.viewer;
            var device = this.device;
            var distortion = this.distortion;
            var result = new Float32Array(4);
            var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
            var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
            var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
            var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
            var halfWidth = device.widthMeters / 4;
            var halfHeight = device.heightMeters / 2;
            var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
            var centerX = viewer.interLensDistance / 2 - halfWidth;
            var centerY = -verticalLensOffset;
            var centerZ = viewer.screenLensDistance;
            var screenLeft = (centerX - halfWidth) / centerZ;
            var screenTop = (centerY + halfHeight) / centerZ;
            var screenRight = (centerX + halfWidth) / centerZ;
            var screenBottom = (centerY - halfHeight) / centerZ;
            result[0] = Math.max(fovLeft, screenLeft);
            result[1] = Math.min(fovTop, screenTop);
            result[2] = Math.min(fovRight, screenRight);
            result[3] = Math.max(fovBottom, screenBottom);
            return result;
          };
          DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
            var viewer = this.viewer;
            var device = this.device;
            var dist = viewer.screenLensDistance;
            var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
            var eyeY = viewer.baselineLensDistance - device.bevelMeters;
            var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
            var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
            var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
            var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
            return {
              x: left,
              y: bottom,
              width: right - left,
              height: top - bottom
            };
          };
          DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
            return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
          };
          DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
            var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
            return {
              leftDegrees: fov.rightDegrees,
              rightDegrees: fov.leftDegrees,
              upDegrees: fov.upDegrees,
              downDegrees: fov.downDegrees
            };
          };
          DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
            var p = this.getUndistortedParams_();
            return {
              leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
              rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
              downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
              upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
            };
          };
          DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
            var p = this.getUndistortedParams_();
            var viewer = this.viewer;
            var device = this.device;
            var eyeToScreenDistance = viewer.screenLensDistance;
            var screenWidth = device.widthMeters / eyeToScreenDistance;
            var screenHeight = device.heightMeters / eyeToScreenDistance;
            var xPxPerTanAngle = device.width / screenWidth;
            var yPxPerTanAngle = device.height / screenHeight;
            var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
            var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
            return {
              x,
              y,
              width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
              height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
            };
          };
          DeviceInfo.prototype.getUndistortedParams_ = function() {
            var viewer = this.viewer;
            var device = this.device;
            var distortion = this.distortion;
            var eyeToScreenDistance = viewer.screenLensDistance;
            var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
            var screenWidth = device.widthMeters / eyeToScreenDistance;
            var screenHeight = device.heightMeters / eyeToScreenDistance;
            var eyePosX = screenWidth / 2 - halfLensDistance;
            var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
            var maxFov = viewer.fov;
            var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
            var outerDist = Math.min(eyePosX, viewerMax);
            var innerDist = Math.min(halfLensDistance, viewerMax);
            var bottomDist = Math.min(eyePosY, viewerMax);
            var topDist = Math.min(screenHeight - eyePosY, viewerMax);
            return {
              outerDist,
              innerDist,
              topDist,
              bottomDist,
              eyePosX,
              eyePosY
            };
          };
          function CardboardViewer(params) {
            this.id = params.id;
            this.label = params.label;
            this.fov = params.fov;
            this.interLensDistance = params.interLensDistance;
            this.baselineLensDistance = params.baselineLensDistance;
            this.screenLensDistance = params.screenLensDistance;
            this.distortionCoefficients = params.distortionCoefficients;
            this.inverseCoefficients = params.inverseCoefficients;
          }
          DeviceInfo.Viewers = Viewers;
          module4.exports = DeviceInfo;
        }, { "./distortion/distortion.js": 9, "./math-util.js": 14, "./util.js": 22 }], 8: [function(_dereq_2, module4, exports4) {
          var VRDisplay = _dereq_2("./base.js").VRDisplay;
          var HMDVRDevice = _dereq_2("./base.js").HMDVRDevice;
          var PositionSensorVRDevice = _dereq_2("./base.js").PositionSensorVRDevice;
          function VRDisplayHMDDevice(display) {
            this.display = display;
            this.hardwareUnitId = display.displayId;
            this.deviceId = "webvr-polyfill:HMD:" + display.displayId;
            this.deviceName = display.displayName + " (HMD)";
          }
          VRDisplayHMDDevice.prototype = new HMDVRDevice();
          VRDisplayHMDDevice.prototype.getEyeParameters = function(whichEye) {
            var eyeParameters = this.display.getEyeParameters(whichEye);
            return {
              currentFieldOfView: eyeParameters.fieldOfView,
              maximumFieldOfView: eyeParameters.fieldOfView,
              minimumFieldOfView: eyeParameters.fieldOfView,
              recommendedFieldOfView: eyeParameters.fieldOfView,
              eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
              renderRect: {
                x: whichEye == "right" ? eyeParameters.renderWidth : 0,
                y: 0,
                width: eyeParameters.renderWidth,
                height: eyeParameters.renderHeight
              }
            };
          };
          VRDisplayHMDDevice.prototype.setFieldOfView = function(opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
          };
          function VRDisplayPositionSensorDevice(display) {
            this.display = display;
            this.hardwareUnitId = display.displayId;
            this.deviceId = "webvr-polyfill:PositionSensor: " + display.displayId;
            this.deviceName = display.displayName + " (PositionSensor)";
          }
          VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();
          VRDisplayPositionSensorDevice.prototype.getState = function() {
            var pose = this.display.getPose();
            return {
              position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
              orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
              linearVelocity: null,
              linearAcceleration: null,
              angularVelocity: null,
              angularAcceleration: null
            };
          };
          VRDisplayPositionSensorDevice.prototype.resetState = function() {
            return this.positionDevice.resetPose();
          };
          module4.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
          module4.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;
        }, { "./base.js": 2 }], 9: [function(_dereq_2, module4, exports4) {
          function Distortion(coefficients) {
            this.coefficients = coefficients;
          }
          Distortion.prototype.distortInverse = function(radius) {
            var r0 = 0;
            var r1 = 1;
            var dr0 = radius - this.distort(r0);
            while (Math.abs(r1 - r0) > 1e-4) {
              var dr1 = radius - this.distort(r1);
              var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
              r0 = r1;
              r1 = r2;
              dr0 = dr1;
            }
            return r1;
          };
          Distortion.prototype.distort = function(radius) {
            var r2 = radius * radius;
            var ret = 0;
            for (var i = 0; i < this.coefficients.length; i++) {
              ret = r2 * (ret + this.coefficients[i]);
            }
            return (ret + 1) * radius;
          };
          Distortion.prototype.solveLinear_ = function(a, y) {
            var n = a.length;
            for (var j = 0; j < n - 1; ++j) {
              for (var k = j + 1; k < n; ++k) {
                var p = a[j][k] / a[j][j];
                for (var i = j + 1; i < n; ++i) {
                  a[i][k] -= p * a[i][j];
                }
                y[k] -= p * y[j];
              }
            }
            var x = new Array(n);
            for (var j = n - 1; j >= 0; --j) {
              var v = y[j];
              for (var i = j + 1; i < n; ++i) {
                v -= a[i][j] * x[i];
              }
              x[j] = v / a[j][j];
            }
            return x;
          };
          Distortion.prototype.solveLeastSquares_ = function(matA, vecY) {
            var i, j, k, sum;
            var numSamples = matA.length;
            var numCoefficients = matA[0].length;
            if (numSamples != vecY.Length) {
              throw new Error("Matrix / vector dimension mismatch");
            }
            var matATA = new Array(numCoefficients);
            for (k = 0; k < numCoefficients; ++k) {
              matATA[k] = new Array(numCoefficients);
              for (j = 0; j < numCoefficients; ++j) {
                sum = 0;
                for (i = 0; i < numSamples; ++i) {
                  sum += matA[j][i] * matA[k][i];
                }
                matATA[k][j] = sum;
              }
            }
            var vecATY = new Array(numCoefficients);
            for (j = 0; j < numCoefficients; ++j) {
              sum = 0;
              for (i = 0; i < numSamples; ++i) {
                sum += matA[j][i] * vecY[i];
              }
              vecATY[j] = sum;
            }
            return this.solveLinear_(matATA, vecATY);
          };
          Distortion.prototype.approximateInverse = function(maxRadius, numSamples) {
            maxRadius = maxRadius || 1;
            numSamples = numSamples || 100;
            var numCoefficients = 6;
            var i, j;
            var matA = new Array(numCoefficients);
            for (j = 0; j < numCoefficients; ++j) {
              matA[j] = new Array(numSamples);
            }
            var vecY = new Array(numSamples);
            for (i = 0; i < numSamples; ++i) {
              var r = maxRadius * (i + 1) / numSamples;
              var rp = this.distort(r);
              var v = rp;
              for (j = 0; j < numCoefficients; ++j) {
                v *= rp * rp;
                matA[j][i] = v;
              }
              vecY[i] = r - rp;
            }
            var inverseCoefficients = this.solveLeastSquares_(matA, vecY);
            return new Distortion(inverseCoefficients);
          };
          module4.exports = Distortion;
        }, {}], 10: [function(_dereq_2, module4, exports4) {
          var DPDB_CACHE = {
            "format": 1,
            "last_updated": "2016-01-20T00:18:35Z",
            "devices": [
              {
                "type": "android",
                "rules": [
                  { "mdmh": "asus/*/Nexus 7/*" },
                  { "ua": "Nexus 7" }
                ],
                "dpi": [320.8, 323],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "asus/*/ASUS_Z00AD/*" },
                  { "ua": "ASUS_Z00AD" }
                ],
                "dpi": [403, 404.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "HTC/*/HTC6435LVW/*" },
                  { "ua": "HTC6435LVW" }
                ],
                "dpi": [449.7, 443.3],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "HTC/*/HTC One XL/*" },
                  { "ua": "HTC One XL" }
                ],
                "dpi": [315.3, 314.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "htc/*/Nexus 9/*" },
                  { "ua": "Nexus 9" }
                ],
                "dpi": 289,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "HTC/*/HTC One M9/*" },
                  { "ua": "HTC One M9" }
                ],
                "dpi": [442.5, 443.3],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "HTC/*/HTC One_M8/*" },
                  { "ua": "HTC One_M8" }
                ],
                "dpi": [449.7, 447.4],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "HTC/*/HTC One/*" },
                  { "ua": "HTC One" }
                ],
                "dpi": 472.8,
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Huawei/*/Nexus 6P/*" },
                  { "ua": "Nexus 6P" }
                ],
                "dpi": [515.1, 518],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/Nexus 5X/*" },
                  { "ua": "Nexus 5X" }
                ],
                "dpi": [422, 419.9],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LGMS345/*" },
                  { "ua": "LGMS345" }
                ],
                "dpi": [221.7, 219.1],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LG-D800/*" },
                  { "ua": "LG-D800" }
                ],
                "dpi": [422, 424.1],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LG-D850/*" },
                  { "ua": "LG-D850" }
                ],
                "dpi": [537.9, 541.9],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/VS985 4G/*" },
                  { "ua": "VS985 4G" }
                ],
                "dpi": [537.9, 535.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/Nexus 5/*" },
                  { "ua": "Nexus 5 " }
                ],
                "dpi": [442.4, 444.8],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/Nexus 4/*" },
                  { "ua": "Nexus 4" }
                ],
                "dpi": [319.8, 318.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LG-P769/*" },
                  { "ua": "LG-P769" }
                ],
                "dpi": [240.6, 247.5],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LGMS323/*" },
                  { "ua": "LGMS323" }
                ],
                "dpi": [206.6, 204.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "LGE/*/LGLS996/*" },
                  { "ua": "LGLS996" }
                ],
                "dpi": [403.4, 401.5],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Micromax/*/4560MMX/*" },
                  { "ua": "4560MMX" }
                ],
                "dpi": [240, 219.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Micromax/*/A250/*" },
                  { "ua": "Micromax A250" }
                ],
                "dpi": [480, 446.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Micromax/*/Micromax AQ4501/*" },
                  { "ua": "Micromax AQ4501" }
                ],
                "dpi": 240,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/DROID RAZR/*" },
                  { "ua": "DROID RAZR" }
                ],
                "dpi": [368.1, 256.7],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT830C/*" },
                  { "ua": "XT830C" }
                ],
                "dpi": [254, 255.9],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1021/*" },
                  { "ua": "XT1021" }
                ],
                "dpi": [254, 256.7],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1023/*" },
                  { "ua": "XT1023" }
                ],
                "dpi": [254, 256.7],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1028/*" },
                  { "ua": "XT1028" }
                ],
                "dpi": [326.6, 327.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1034/*" },
                  { "ua": "XT1034" }
                ],
                "dpi": [326.6, 328.4],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1053/*" },
                  { "ua": "XT1053" }
                ],
                "dpi": [315.3, 316.1],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1562/*" },
                  { "ua": "XT1562" }
                ],
                "dpi": [403.4, 402.7],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/Nexus 6/*" },
                  { "ua": "Nexus 6 " }
                ],
                "dpi": [494.3, 489.7],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1063/*" },
                  { "ua": "XT1063" }
                ],
                "dpi": [295, 296.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1064/*" },
                  { "ua": "XT1064" }
                ],
                "dpi": [295, 295.6],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1092/*" },
                  { "ua": "XT1092" }
                ],
                "dpi": [422, 424.1],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "motorola/*/XT1095/*" },
                  { "ua": "XT1095" }
                ],
                "dpi": [422, 423.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "OnePlus/*/A0001/*" },
                  { "ua": "A0001" }
                ],
                "dpi": [403.4, 401],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "OnePlus/*/ONE E1005/*" },
                  { "ua": "ONE E1005" }
                ],
                "dpi": [442.4, 441.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "OnePlus/*/ONE A2005/*" },
                  { "ua": "ONE A2005" }
                ],
                "dpi": [391.9, 405.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "OPPO/*/X909/*" },
                  { "ua": "X909" }
                ],
                "dpi": [442.4, 444.1],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9082/*" },
                  { "ua": "GT-I9082" }
                ],
                "dpi": [184.7, 185.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G360P/*" },
                  { "ua": "SM-G360P" }
                ],
                "dpi": [196.7, 205.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/Nexus S/*" },
                  { "ua": "Nexus S" }
                ],
                "dpi": [234.5, 229.8],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9300/*" },
                  { "ua": "GT-I9300" }
                ],
                "dpi": [304.8, 303.9],
                "bw": 5,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-T230NU/*" },
                  { "ua": "SM-T230NU" }
                ],
                "dpi": 216,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SGH-T399/*" },
                  { "ua": "SGH-T399" }
                ],
                "dpi": [217.7, 231.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-N9005/*" },
                  { "ua": "SM-N9005" }
                ],
                "dpi": [386.4, 387],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" },
                  { "ua": "SAMSUNG-SM-N900A" }
                ],
                "dpi": [386.4, 387.7],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9500/*" },
                  { "ua": "GT-I9500" }
                ],
                "dpi": [442.5, 443.3],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9505/*" },
                  { "ua": "GT-I9505" }
                ],
                "dpi": 439.4,
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G900F/*" },
                  { "ua": "SM-G900F" }
                ],
                "dpi": [415.6, 431.6],
                "bw": 5,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G900M/*" },
                  { "ua": "SM-G900M" }
                ],
                "dpi": [415.6, 431.6],
                "bw": 5,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G800F/*" },
                  { "ua": "SM-G800F" }
                ],
                "dpi": 326.8,
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G906S/*" },
                  { "ua": "SM-G906S" }
                ],
                "dpi": [562.7, 572.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9300/*" },
                  { "ua": "GT-I9300" }
                ],
                "dpi": [306.7, 304.8],
                "bw": 5,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-T535/*" },
                  { "ua": "SM-T535" }
                ],
                "dpi": [142.6, 136.4],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-N920C/*" },
                  { "ua": "SM-N920C" }
                ],
                "dpi": [515.1, 518.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9300I/*" },
                  { "ua": "GT-I9300I" }
                ],
                "dpi": [304.8, 305.8],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-I9195/*" },
                  { "ua": "GT-I9195" }
                ],
                "dpi": [249.4, 256.7],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SPH-L520/*" },
                  { "ua": "SPH-L520" }
                ],
                "dpi": [249.4, 255.9],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" },
                  { "ua": "SAMSUNG-SGH-I717" }
                ],
                "dpi": 285.8,
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SPH-D710/*" },
                  { "ua": "SPH-D710" }
                ],
                "dpi": [217.7, 204.2],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/GT-N7100/*" },
                  { "ua": "GT-N7100" }
                ],
                "dpi": 265.1,
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SCH-I605/*" },
                  { "ua": "SCH-I605" }
                ],
                "dpi": 265.1,
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/Galaxy Nexus/*" },
                  { "ua": "Galaxy Nexus" }
                ],
                "dpi": [315.3, 314.2],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-N910H/*" },
                  { "ua": "SM-N910H" }
                ],
                "dpi": [515.1, 518],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-N910C/*" },
                  { "ua": "SM-N910C" }
                ],
                "dpi": [515.2, 520.2],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G130M/*" },
                  { "ua": "SM-G130M" }
                ],
                "dpi": [165.9, 164.8],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G928I/*" },
                  { "ua": "SM-G928I" }
                ],
                "dpi": [515.1, 518.4],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G920F/*" },
                  { "ua": "SM-G920F" }
                ],
                "dpi": 580.6,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G920P/*" },
                  { "ua": "SM-G920P" }
                ],
                "dpi": [522.5, 577],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G925F/*" },
                  { "ua": "SM-G925F" }
                ],
                "dpi": 580.6,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "samsung/*/SM-G925V/*" },
                  { "ua": "SM-G925V" }
                ],
                "dpi": [522.5, 576.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Sony/*/C6903/*" },
                  { "ua": "C6903" }
                ],
                "dpi": [442.5, 443.3],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Sony/*/D6653/*" },
                  { "ua": "D6653" }
                ],
                "dpi": [428.6, 427.6],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Sony/*/E6653/*" },
                  { "ua": "E6653" }
                ],
                "dpi": [428.6, 425.7],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Sony/*/E6853/*" },
                  { "ua": "E6853" }
                ],
                "dpi": [403.4, 401.9],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "Sony/*/SGP321/*" },
                  { "ua": "SGP321" }
                ],
                "dpi": [224.7, 224.1],
                "bw": 3,
                "ac": 500
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" },
                  { "ua": "ALCATEL ONE TOUCH Fierce" }
                ],
                "dpi": [240, 247.5],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "THL/*/thl 5000/*" },
                  { "ua": "thl 5000" }
                ],
                "dpi": [480, 443.3],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "android",
                "rules": [
                  { "mdmh": "ZTE/*/ZTE Blade L2/*" },
                  { "ua": "ZTE Blade L2" }
                ],
                "dpi": 240,
                "bw": 3,
                "ac": 500
              },
              {
                "type": "ios",
                "rules": [{ "res": [640, 960] }],
                "dpi": [325.1, 328.4],
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [640, 960] }],
                "dpi": [325.1, 328.4],
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [640, 1136] }],
                "dpi": [317.1, 320.2],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [640, 1136] }],
                "dpi": [317.1, 320.2],
                "bw": 3,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [750, 1334] }],
                "dpi": 326.4,
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [750, 1334] }],
                "dpi": 326.4,
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [1242, 2208] }],
                "dpi": [453.6, 458.4],
                "bw": 4,
                "ac": 1e3
              },
              {
                "type": "ios",
                "rules": [{ "res": [1242, 2208] }],
                "dpi": [453.6, 458.4],
                "bw": 4,
                "ac": 1e3
              }
            ]
          };
          module4.exports = DPDB_CACHE;
        }, {}], 11: [function(_dereq_2, module4, exports4) {
          var DPDB_CACHE = _dereq_2("./dpdb-cache.js");
          var Util = _dereq_2("../util.js");
          var ONLINE_DPDB_URL = "https://storage.googleapis.com/cardboard-dpdb/dpdb.json";
          function Dpdb(fetchOnline, onDeviceParamsUpdated) {
            this.dpdb = DPDB_CACHE;
            this.recalculateDeviceParams_();
            if (fetchOnline) {
              this.onDeviceParamsUpdated = onDeviceParamsUpdated;
              console.log("Fetching DPDB...");
              var xhr = new XMLHttpRequest();
              var obj = this;
              xhr.open("GET", ONLINE_DPDB_URL, true);
              xhr.addEventListener("load", function() {
                obj.loading = false;
                if (xhr.status >= 200 && xhr.status <= 299) {
                  console.log("Successfully loaded online DPDB.");
                  obj.dpdb = JSON.parse(xhr.response);
                  obj.recalculateDeviceParams_();
                } else {
                  console.error("Error loading online DPDB!");
                }
              });
              xhr.send();
            }
          }
          Dpdb.prototype.getDeviceParams = function() {
            return this.deviceParams;
          };
          Dpdb.prototype.recalculateDeviceParams_ = function() {
            console.log("Recalculating device params.");
            var newDeviceParams = this.calcDeviceParams_();
            console.log("New device parameters:");
            console.log(newDeviceParams);
            if (newDeviceParams) {
              this.deviceParams = newDeviceParams;
              if (this.onDeviceParamsUpdated) {
                this.onDeviceParamsUpdated(this.deviceParams);
              }
            } else {
              console.error("Failed to recalculate device parameters.");
            }
          };
          Dpdb.prototype.calcDeviceParams_ = function() {
            var db = this.dpdb;
            if (!db) {
              console.error("DPDB not available.");
              return null;
            }
            if (db.format != 1) {
              console.error("DPDB has unexpected format version.");
              return null;
            }
            if (!db.devices || !db.devices.length) {
              console.error("DPDB does not have a devices section.");
              return null;
            }
            var userAgent = navigator.userAgent || navigator.vendor || window.opera;
            var width = Util.getScreenWidth();
            var height = Util.getScreenHeight();
            console.log("User agent: " + userAgent);
            console.log("Pixel width: " + width);
            console.log("Pixel height: " + height);
            if (!db.devices) {
              console.error("DPDB has no devices section.");
              return null;
            }
            for (var i = 0; i < db.devices.length; i++) {
              var device = db.devices[i];
              if (!device.rules) {
                console.warn("Device[" + i + "] has no rules section.");
                continue;
              }
              if (device.type != "ios" && device.type != "android") {
                console.warn("Device[" + i + "] has invalid type.");
                continue;
              }
              if (Util.isIOS() != (device.type == "ios"))
                continue;
              var matched = false;
              for (var j = 0; j < device.rules.length; j++) {
                var rule = device.rules[j];
                if (this.matchRule_(rule, userAgent, width, height)) {
                  console.log("Rule matched:");
                  console.log(rule);
                  matched = true;
                  break;
                }
              }
              if (!matched)
                continue;
              var xdpi = device.dpi[0] || device.dpi;
              var ydpi = device.dpi[1] || device.dpi;
              return new DeviceParams({ xdpi, ydpi, bevelMm: device.bw });
            }
            console.warn("No DPDB device match.");
            return null;
          };
          Dpdb.prototype.matchRule_ = function(rule, ua, screenWidth, screenHeight) {
            if (!rule.ua && !rule.res)
              return false;
            if (rule.ua && ua.indexOf(rule.ua) < 0)
              return false;
            if (rule.res) {
              if (!rule.res[0] || !rule.res[1])
                return false;
              var resX = rule.res[0];
              var resY = rule.res[1];
              if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
                return false;
              }
            }
            return true;
          };
          function DeviceParams(params) {
            this.xdpi = params.xdpi;
            this.ydpi = params.ydpi;
            this.bevelMm = params.bevelMm;
          }
          module4.exports = Dpdb;
        }, { "../util.js": 22, "./dpdb-cache.js": 10 }], 12: [function(_dereq_2, module4, exports4) {
          function Emitter() {
            this.callbacks = {};
          }
          Emitter.prototype.emit = function(eventName) {
            var callbacks = this.callbacks[eventName];
            if (!callbacks) {
              return;
            }
            var args = [].slice.call(arguments);
            args.shift();
            for (var i = 0; i < callbacks.length; i++) {
              callbacks[i].apply(this, args);
            }
          };
          Emitter.prototype.on = function(eventName, callback) {
            if (eventName in this.callbacks) {
              this.callbacks[eventName].push(callback);
            } else {
              this.callbacks[eventName] = [callback];
            }
          };
          module4.exports = Emitter;
        }, {}], 13: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          var WebVRPolyfill = _dereq_2("./webvr-polyfill.js").WebVRPolyfill;
          window.WebVRConfig = Util.extend({
            // Forces availability of VR mode, even for non-mobile devices.
            FORCE_ENABLE_VR: false,
            // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
            K_FILTER: 0.98,
            // How far into the future to predict during fast motion (in seconds).
            PREDICTION_TIME_S: 0.04,
            // Flag to enable touch panner. In case you have your own touch controls.
            TOUCH_PANNER_DISABLED: true,
            // Flag to disabled the UI in VR Mode.
            CARDBOARD_UI_DISABLED: false,
            // Default: false
            // Flag to disable the instructions to rotate your device.
            ROTATE_INSTRUCTIONS_DISABLED: false,
            // Default: false.
            // Enable yaw panning only, disabling roll and pitch. This can be useful
            // for panoramas with nothing interesting above or below.
            YAW_ONLY: false,
            // To disable keyboard and mouse controls, if you want to use your own
            // implementation.
            MOUSE_KEYBOARD_CONTROLS_DISABLED: false,
            // Prevent the polyfill from initializing immediately. Requires the app
            // to call InitializeWebVRPolyfill() before it can be used.
            DEFER_INITIALIZATION: false,
            // Enable the deprecated version of the API (navigator.getVRDevices).
            ENABLE_DEPRECATED_API: false,
            // Scales the recommended buffer size reported by WebVR, which can improve
            // performance.
            // UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
            // perform well on many mobile devices.
            BUFFER_SCALE: 0.5,
            // Allow VRDisplay.submitFrame to change gl bindings, which is more
            // efficient if the application code will re-bind its resources on the
            // next frame anyway. This has been seen to cause rendering glitches with
            // THREE.js.
            // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
            // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
            // and gl.TEXTURE_BINDING_2D for texture unit 0.
            DIRTY_SUBMIT_FRAME_BINDINGS: false
          }, window.WebVRConfig);
          if (!window.WebVRConfig.DEFER_INITIALIZATION) {
            new WebVRPolyfill();
          } else {
            window.InitializeWebVRPolyfill = function() {
              new WebVRPolyfill();
            };
          }
        }, { "./util.js": 22, "./webvr-polyfill.js": 25 }], 14: [function(_dereq_2, module4, exports4) {
          var MathUtil = window.MathUtil || {};
          MathUtil.degToRad = Math.PI / 180;
          MathUtil.radToDeg = 180 / Math.PI;
          MathUtil.Vector2 = function(x, y) {
            this.x = x || 0;
            this.y = y || 0;
          };
          MathUtil.Vector2.prototype = {
            constructor: MathUtil.Vector2,
            set: function(x, y) {
              this.x = x;
              this.y = y;
              return this;
            },
            copy: function(v) {
              this.x = v.x;
              this.y = v.y;
              return this;
            },
            subVectors: function(a, b) {
              this.x = a.x - b.x;
              this.y = a.y - b.y;
              return this;
            }
          };
          MathUtil.Vector3 = function(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          };
          MathUtil.Vector3.prototype = {
            constructor: MathUtil.Vector3,
            set: function(x, y, z) {
              this.x = x;
              this.y = y;
              this.z = z;
              return this;
            },
            copy: function(v) {
              this.x = v.x;
              this.y = v.y;
              this.z = v.z;
              return this;
            },
            length: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            normalize: function() {
              var scalar = this.length();
              if (scalar !== 0) {
                var invScalar = 1 / scalar;
                this.multiplyScalar(invScalar);
              } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
              }
              return this;
            },
            multiplyScalar: function(scalar) {
              this.x *= scalar;
              this.y *= scalar;
              this.z *= scalar;
            },
            applyQuaternion: function(q) {
              var x = this.x;
              var y = this.y;
              var z = this.z;
              var qx = q.x;
              var qy = q.y;
              var qz = q.z;
              var qw = q.w;
              var ix = qw * x + qy * z - qz * y;
              var iy = qw * y + qz * x - qx * z;
              var iz = qw * z + qx * y - qy * x;
              var iw = -qx * x - qy * y - qz * z;
              this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
              this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
              this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
              return this;
            },
            dot: function(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            },
            crossVectors: function(a, b) {
              var ax = a.x, ay = a.y, az = a.z;
              var bx = b.x, by = b.y, bz = b.z;
              this.x = ay * bz - az * by;
              this.y = az * bx - ax * bz;
              this.z = ax * by - ay * bx;
              return this;
            }
          };
          MathUtil.Quaternion = function(x, y, z, w) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== void 0 ? w : 1;
          };
          MathUtil.Quaternion.prototype = {
            constructor: MathUtil.Quaternion,
            set: function(x, y, z, w) {
              this.x = x;
              this.y = y;
              this.z = z;
              this.w = w;
              return this;
            },
            copy: function(quaternion) {
              this.x = quaternion.x;
              this.y = quaternion.y;
              this.z = quaternion.z;
              this.w = quaternion.w;
              return this;
            },
            setFromEulerXYZ: function(x, y, z) {
              var c1 = Math.cos(x / 2);
              var c2 = Math.cos(y / 2);
              var c3 = Math.cos(z / 2);
              var s1 = Math.sin(x / 2);
              var s2 = Math.sin(y / 2);
              var s3 = Math.sin(z / 2);
              this.x = s1 * c2 * c3 + c1 * s2 * s3;
              this.y = c1 * s2 * c3 - s1 * c2 * s3;
              this.z = c1 * c2 * s3 + s1 * s2 * c3;
              this.w = c1 * c2 * c3 - s1 * s2 * s3;
              return this;
            },
            setFromEulerYXZ: function(x, y, z) {
              var c1 = Math.cos(x / 2);
              var c2 = Math.cos(y / 2);
              var c3 = Math.cos(z / 2);
              var s1 = Math.sin(x / 2);
              var s2 = Math.sin(y / 2);
              var s3 = Math.sin(z / 2);
              this.x = s1 * c2 * c3 + c1 * s2 * s3;
              this.y = c1 * s2 * c3 - s1 * c2 * s3;
              this.z = c1 * c2 * s3 - s1 * s2 * c3;
              this.w = c1 * c2 * c3 + s1 * s2 * s3;
              return this;
            },
            setFromAxisAngle: function(axis, angle) {
              var halfAngle = angle / 2, s = Math.sin(halfAngle);
              this.x = axis.x * s;
              this.y = axis.y * s;
              this.z = axis.z * s;
              this.w = Math.cos(halfAngle);
              return this;
            },
            multiply: function(q) {
              return this.multiplyQuaternions(this, q);
            },
            multiplyQuaternions: function(a, b) {
              var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
              var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
              this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
              this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
              this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
              this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
              return this;
            },
            inverse: function() {
              this.x *= -1;
              this.y *= -1;
              this.z *= -1;
              this.normalize();
              return this;
            },
            normalize: function() {
              var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
              if (l === 0) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 1;
              } else {
                l = 1 / l;
                this.x = this.x * l;
                this.y = this.y * l;
                this.z = this.z * l;
                this.w = this.w * l;
              }
              return this;
            },
            slerp: function(qb, t) {
              if (t === 0)
                return this;
              if (t === 1)
                return this.copy(qb);
              var x = this.x, y = this.y, z = this.z, w = this.w;
              var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
              if (cosHalfTheta < 0) {
                this.w = -qb.w;
                this.x = -qb.x;
                this.y = -qb.y;
                this.z = -qb.z;
                cosHalfTheta = -cosHalfTheta;
              } else {
                this.copy(qb);
              }
              if (cosHalfTheta >= 1) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
              }
              var halfTheta = Math.acos(cosHalfTheta);
              var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
              if (Math.abs(sinHalfTheta) < 1e-3) {
                this.w = 0.5 * (w + this.w);
                this.x = 0.5 * (x + this.x);
                this.y = 0.5 * (y + this.y);
                this.z = 0.5 * (z + this.z);
                return this;
              }
              var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
              this.w = w * ratioA + this.w * ratioB;
              this.x = x * ratioA + this.x * ratioB;
              this.y = y * ratioA + this.y * ratioB;
              this.z = z * ratioA + this.z * ratioB;
              return this;
            },
            setFromUnitVectors: /* @__PURE__ */ function() {
              var v1, r;
              var EPS = 1e-6;
              return function(vFrom, vTo) {
                if (v1 === void 0)
                  v1 = new MathUtil.Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                  r = 0;
                  if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    v1.set(-vFrom.y, vFrom.x, 0);
                  } else {
                    v1.set(0, -vFrom.z, vFrom.y);
                  }
                } else {
                  v1.crossVectors(vFrom, vTo);
                }
                this.x = v1.x;
                this.y = v1.y;
                this.z = v1.z;
                this.w = r;
                this.normalize();
                return this;
              };
            }()
          };
          module4.exports = MathUtil;
        }, {}], 15: [function(_dereq_2, module4, exports4) {
          var VRDisplay = _dereq_2("./base.js").VRDisplay;
          var MathUtil = _dereq_2("./math-util.js");
          var Util = _dereq_2("./util.js");
          var KEY_SPEED = 0.15;
          var KEY_ANIMATION_DURATION = 80;
          var MOUSE_SPEED_X = 0.5;
          var MOUSE_SPEED_Y = 0.3;
          function MouseKeyboardVRDisplay() {
            this.displayName = "Mouse and Keyboard VRDisplay (webvr-polyfill)";
            this.capabilities.hasOrientation = true;
            window.addEventListener("keydown", this.onKeyDown_.bind(this));
            window.addEventListener("mousemove", this.onMouseMove_.bind(this));
            window.addEventListener("mousedown", this.onMouseDown_.bind(this));
            window.addEventListener("mouseup", this.onMouseUp_.bind(this));
            this.phi_ = 0;
            this.theta_ = 0;
            this.targetAngle_ = null;
            this.angleAnimation_ = null;
            this.orientation_ = new MathUtil.Quaternion();
            this.rotateStart_ = new MathUtil.Vector2();
            this.rotateEnd_ = new MathUtil.Vector2();
            this.rotateDelta_ = new MathUtil.Vector2();
            this.isDragging_ = false;
            this.orientationOut_ = new Float32Array(4);
          }
          MouseKeyboardVRDisplay.prototype = new VRDisplay();
          MouseKeyboardVRDisplay.prototype.getImmediatePose = function() {
            this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);
            this.orientationOut_[0] = this.orientation_.x;
            this.orientationOut_[1] = this.orientation_.y;
            this.orientationOut_[2] = this.orientation_.z;
            this.orientationOut_[3] = this.orientation_.w;
            return {
              position: null,
              orientation: this.orientationOut_,
              linearVelocity: null,
              linearAcceleration: null,
              angularVelocity: null,
              angularAcceleration: null
            };
          };
          MouseKeyboardVRDisplay.prototype.onKeyDown_ = function(e2) {
            if (e2.keyCode == 38) {
              this.animatePhi_(this.phi_ + KEY_SPEED);
            } else if (e2.keyCode == 39) {
              this.animateTheta_(this.theta_ - KEY_SPEED);
            } else if (e2.keyCode == 40) {
              this.animatePhi_(this.phi_ - KEY_SPEED);
            } else if (e2.keyCode == 37) {
              this.animateTheta_(this.theta_ + KEY_SPEED);
            }
          };
          MouseKeyboardVRDisplay.prototype.animateTheta_ = function(targetAngle) {
            this.animateKeyTransitions_("theta_", targetAngle);
          };
          MouseKeyboardVRDisplay.prototype.animatePhi_ = function(targetAngle) {
            targetAngle = Util.clamp(targetAngle, -Math.PI / 2, Math.PI / 2);
            this.animateKeyTransitions_("phi_", targetAngle);
          };
          MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
            if (this.angleAnimation_) {
              cancelAnimationFrame(this.angleAnimation_);
            }
            var startAngle = this[angleName];
            var startTime = /* @__PURE__ */ new Date();
            this.angleAnimation_ = requestAnimationFrame((function animate() {
              var elapsed = /* @__PURE__ */ new Date() - startTime;
              if (elapsed >= KEY_ANIMATION_DURATION) {
                this[angleName] = targetAngle;
                cancelAnimationFrame(this.angleAnimation_);
                return;
              }
              this.angleAnimation_ = requestAnimationFrame(animate.bind(this));
              var percent = elapsed / KEY_ANIMATION_DURATION;
              this[angleName] = startAngle + (targetAngle - startAngle) * percent;
            }).bind(this));
          };
          MouseKeyboardVRDisplay.prototype.onMouseDown_ = function(e2) {
            this.rotateStart_.set(e2.clientX, e2.clientY);
            this.isDragging_ = true;
          };
          MouseKeyboardVRDisplay.prototype.onMouseMove_ = function(e2) {
            if (!this.isDragging_ && !this.isPointerLocked_()) {
              return;
            }
            if (this.isPointerLocked_()) {
              var movementX = e2.movementX || e2.mozMovementX || 0;
              var movementY = e2.movementY || e2.mozMovementY || 0;
              this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
            } else {
              this.rotateEnd_.set(e2.clientX, e2.clientY);
            }
            this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
            this.rotateStart_.copy(this.rotateEnd_);
            this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
            this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;
            this.phi_ = Util.clamp(this.phi_, -Math.PI / 2, Math.PI / 2);
          };
          MouseKeyboardVRDisplay.prototype.onMouseUp_ = function(e2) {
            this.isDragging_ = false;
          };
          MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function() {
            var el = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
            return el !== void 0;
          };
          MouseKeyboardVRDisplay.prototype.resetPose = function() {
            this.phi_ = 0;
            this.theta_ = 0;
          };
          module4.exports = MouseKeyboardVRDisplay;
        }, { "./base.js": 2, "./math-util.js": 14, "./util.js": 22 }], 16: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          function RotateInstructions() {
            this.loadIcon_();
            var overlay = document.createElement("div");
            var s = overlay.style;
            s.position = "fixed";
            s.top = 0;
            s.right = 0;
            s.bottom = 0;
            s.left = 0;
            s.backgroundColor = "gray";
            s.fontFamily = "sans-serif";
            s.zIndex = 1e6;
            var img = document.createElement("img");
            img.src = this.icon;
            var s = img.style;
            s.marginLeft = "25%";
            s.marginTop = "25%";
            s.width = "50%";
            overlay.appendChild(img);
            var text = document.createElement("div");
            var s = text.style;
            s.textAlign = "center";
            s.fontSize = "16px";
            s.lineHeight = "24px";
            s.margin = "24px 25%";
            s.width = "50%";
            text.innerHTML = "Place your phone into your Cardboard viewer.";
            overlay.appendChild(text);
            var snackbar = document.createElement("div");
            var s = snackbar.style;
            s.backgroundColor = "#CFD8DC";
            s.position = "fixed";
            s.bottom = 0;
            s.width = "100%";
            s.height = "48px";
            s.padding = "14px 24px";
            s.boxSizing = "border-box";
            s.color = "#656A6B";
            overlay.appendChild(snackbar);
            var snackbarText = document.createElement("div");
            snackbarText.style.float = "left";
            snackbarText.innerHTML = "No Cardboard viewer?";
            var snackbarButton = document.createElement("a");
            snackbarButton.href = "https://www.google.com/get/cardboard/get-cardboard/";
            snackbarButton.innerHTML = "get one";
            snackbarButton.target = "_blank";
            var s = snackbarButton.style;
            s.float = "right";
            s.fontWeight = 600;
            s.textTransform = "uppercase";
            s.borderLeft = "1px solid gray";
            s.paddingLeft = "24px";
            s.textDecoration = "none";
            s.color = "#656A6B";
            snackbar.appendChild(snackbarText);
            snackbar.appendChild(snackbarButton);
            this.overlay = overlay;
            this.text = text;
            this.hide();
          }
          RotateInstructions.prototype.show = function(parent) {
            if (!parent && !this.overlay.parentElement) {
              document.body.appendChild(this.overlay);
            } else if (parent) {
              if (this.overlay.parentElement && this.overlay.parentElement != parent)
                this.overlay.parentElement.removeChild(this.overlay);
              parent.appendChild(this.overlay);
            }
            this.overlay.style.display = "block";
            var img = this.overlay.querySelector("img");
            var s = img.style;
            if (Util.isLandscapeMode()) {
              s.width = "20%";
              s.marginLeft = "40%";
              s.marginTop = "3%";
            } else {
              s.width = "50%";
              s.marginLeft = "25%";
              s.marginTop = "25%";
            }
          };
          RotateInstructions.prototype.hide = function() {
            this.overlay.style.display = "none";
          };
          RotateInstructions.prototype.showTemporarily = function(ms, parent) {
            this.show(parent);
            this.timer = setTimeout(this.hide.bind(this), ms);
          };
          RotateInstructions.prototype.disableShowTemporarily = function() {
            clearTimeout(this.timer);
          };
          RotateInstructions.prototype.update = function() {
            this.disableShowTemporarily();
            if (!Util.isLandscapeMode() && Util.isMobile()) {
              this.show();
            } else {
              this.hide();
            }
          };
          RotateInstructions.prototype.loadIcon_ = function() {
            this.icon = Util.base64("image/svg+xml", "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+");
          };
          module4.exports = RotateInstructions;
        }, { "./util.js": 22 }], 17: [function(_dereq_2, module4, exports4) {
          var SensorSample = _dereq_2("./sensor-sample.js");
          var MathUtil = _dereq_2("../math-util.js");
          var Util = _dereq_2("../util.js");
          var DEBUG = false;
          function ComplementaryFilter(kFilter) {
            this.kFilter = kFilter;
            this.currentAccelMeasurement = new SensorSample();
            this.currentGyroMeasurement = new SensorSample();
            this.previousGyroMeasurement = new SensorSample();
            if (Util.isIOS()) {
              this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
            } else {
              this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
            }
            this.previousFilterQ = new MathUtil.Quaternion();
            this.previousFilterQ.copy(this.filterQ);
            this.accelQ = new MathUtil.Quaternion();
            this.isOrientationInitialized = false;
            this.estimatedGravity = new MathUtil.Vector3();
            this.measuredGravity = new MathUtil.Vector3();
            this.gyroIntegralQ = new MathUtil.Quaternion();
          }
          ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
            this.currentAccelMeasurement.set(vector, timestampS);
          };
          ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
            this.currentGyroMeasurement.set(vector, timestampS);
            var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
            if (Util.isTimestampDeltaValid(deltaT)) {
              this.run_();
            }
            this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
          };
          ComplementaryFilter.prototype.run_ = function() {
            if (!this.isOrientationInitialized) {
              this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
              this.previousFilterQ.copy(this.accelQ);
              this.isOrientationInitialized = true;
              return;
            }
            var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
            var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
            this.gyroIntegralQ.multiply(gyroDeltaQ);
            this.filterQ.copy(this.previousFilterQ);
            this.filterQ.multiply(gyroDeltaQ);
            var invFilterQ = new MathUtil.Quaternion();
            invFilterQ.copy(this.filterQ);
            invFilterQ.inverse();
            this.estimatedGravity.set(0, 0, -1);
            this.estimatedGravity.applyQuaternion(invFilterQ);
            this.estimatedGravity.normalize();
            this.measuredGravity.copy(this.currentAccelMeasurement.sample);
            this.measuredGravity.normalize();
            var deltaQ = new MathUtil.Quaternion();
            deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
            deltaQ.inverse();
            if (DEBUG) {
              console.log(
                "Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)",
                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
                this.estimatedGravity.x.toFixed(1),
                this.estimatedGravity.y.toFixed(1),
                this.estimatedGravity.z.toFixed(1),
                this.measuredGravity.x.toFixed(1),
                this.measuredGravity.y.toFixed(1),
                this.measuredGravity.z.toFixed(1)
              );
            }
            var targetQ = new MathUtil.Quaternion();
            targetQ.copy(this.filterQ);
            targetQ.multiply(deltaQ);
            this.filterQ.slerp(targetQ, 1 - this.kFilter);
            this.previousFilterQ.copy(this.filterQ);
          };
          ComplementaryFilter.prototype.getOrientation = function() {
            return this.filterQ;
          };
          ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
            var normAccel = new MathUtil.Vector3();
            normAccel.copy(accel);
            normAccel.normalize();
            var quat = new MathUtil.Quaternion();
            quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
            quat.inverse();
            return quat;
          };
          ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
            var quat = new MathUtil.Quaternion();
            var axis = new MathUtil.Vector3();
            axis.copy(gyro);
            axis.normalize();
            quat.setFromAxisAngle(axis, gyro.length() * dt);
            return quat;
          };
          module4.exports = ComplementaryFilter;
        }, { "../math-util.js": 14, "../util.js": 22, "./sensor-sample.js": 20 }], 18: [function(_dereq_2, module4, exports4) {
          var ComplementaryFilter = _dereq_2("./complementary-filter.js");
          var PosePredictor = _dereq_2("./pose-predictor.js");
          var TouchPanner = _dereq_2("../touch-panner.js");
          var MathUtil = _dereq_2("../math-util.js");
          var Util = _dereq_2("../util.js");
          function FusionPoseSensor() {
            this.deviceId = "webvr-polyfill:fused";
            this.deviceName = "VR Position Device (webvr-polyfill:fused)";
            this.accelerometer = new MathUtil.Vector3();
            this.gyroscope = new MathUtil.Vector3();
            window.addEventListener("devicemotion", this.onDeviceMotionChange_.bind(this));
            window.addEventListener("orientationchange", this.onScreenOrientationChange_.bind(this));
            this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER);
            this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S);
            this.touchPanner = new TouchPanner();
            this.filterToWorldQ = new MathUtil.Quaternion();
            if (Util.isIOS()) {
              this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
            } else {
              this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
            }
            this.inverseWorldToScreenQ = new MathUtil.Quaternion();
            this.worldToScreenQ = new MathUtil.Quaternion();
            this.originalPoseAdjustQ = new MathUtil.Quaternion();
            this.originalPoseAdjustQ.setFromAxisAngle(
              new MathUtil.Vector3(0, 0, 1),
              -window.orientation * Math.PI / 180
            );
            this.setScreenTransform_();
            if (Util.isLandscapeMode()) {
              this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
            }
            this.resetQ = new MathUtil.Quaternion();
            this.isFirefoxAndroid = Util.isFirefoxAndroid();
            this.isIOS = Util.isIOS();
            this.orientationOut_ = new Float32Array(4);
          }
          FusionPoseSensor.prototype.getPosition = function() {
            return null;
          };
          FusionPoseSensor.prototype.getOrientation = function() {
            var orientation = this.filter.getOrientation();
            this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);
            var out = new MathUtil.Quaternion();
            out.copy(this.filterToWorldQ);
            out.multiply(this.resetQ);
            if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
              out.multiply(this.touchPanner.getOrientation());
            }
            out.multiply(this.predictedQ);
            out.multiply(this.worldToScreenQ);
            if (WebVRConfig.YAW_ONLY) {
              out.x = 0;
              out.z = 0;
              out.normalize();
            }
            this.orientationOut_[0] = out.x;
            this.orientationOut_[1] = out.y;
            this.orientationOut_[2] = out.z;
            this.orientationOut_[3] = out.w;
            return this.orientationOut_;
          };
          FusionPoseSensor.prototype.resetPose = function() {
            this.resetQ.copy(this.filter.getOrientation());
            this.resetQ.x = 0;
            this.resetQ.y = 0;
            this.resetQ.z *= -1;
            this.resetQ.normalize();
            if (Util.isLandscapeMode()) {
              this.resetQ.multiply(this.inverseWorldToScreenQ);
            }
            this.resetQ.multiply(this.originalPoseAdjustQ);
            if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
              this.touchPanner.resetSensor();
            }
          };
          FusionPoseSensor.prototype.onDeviceMotionChange_ = function(deviceMotion) {
            var accGravity = deviceMotion.accelerationIncludingGravity;
            var rotRate = deviceMotion.rotationRate;
            var timestampS = deviceMotion.timeStamp / 1e3;
            if (this.isFirefoxAndroid) {
              timestampS /= 1e3;
            }
            var deltaS = timestampS - this.previousTimestampS;
            if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
              console.warn("Invalid timestamps detected. Time step between successive gyroscope sensor samples is very small or not monotonic");
              this.previousTimestampS = timestampS;
              return;
            }
            this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
            this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
            if (this.isIOS || this.isFirefoxAndroid) {
              this.gyroscope.multiplyScalar(Math.PI / 180);
            }
            this.filter.addAccelMeasurement(this.accelerometer, timestampS);
            this.filter.addGyroMeasurement(this.gyroscope, timestampS);
            this.previousTimestampS = timestampS;
          };
          FusionPoseSensor.prototype.onScreenOrientationChange_ = function(screenOrientation) {
            this.setScreenTransform_();
          };
          FusionPoseSensor.prototype.setScreenTransform_ = function() {
            this.worldToScreenQ.set(0, 0, 0, 1);
            switch (window.orientation) {
              case 0:
                break;
              case 90:
                this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
                break;
              case -90:
                this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
                break;
              case 180:
                break;
            }
            this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
            this.inverseWorldToScreenQ.inverse();
          };
          module4.exports = FusionPoseSensor;
        }, { "../math-util.js": 14, "../touch-panner.js": 21, "../util.js": 22, "./complementary-filter.js": 17, "./pose-predictor.js": 19 }], 19: [function(_dereq_2, module4, exports4) {
          var MathUtil = _dereq_2("../math-util.js");
          var DEBUG = false;
          function PosePredictor(predictionTimeS) {
            this.predictionTimeS = predictionTimeS;
            this.previousQ = new MathUtil.Quaternion();
            this.previousTimestampS = null;
            this.deltaQ = new MathUtil.Quaternion();
            this.outQ = new MathUtil.Quaternion();
          }
          PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
            if (!this.previousTimestampS) {
              this.previousQ.copy(currentQ);
              this.previousTimestampS = timestampS;
              return currentQ;
            }
            var axis = new MathUtil.Vector3();
            axis.copy(gyro);
            axis.normalize();
            var angularSpeed = gyro.length();
            if (angularSpeed < MathUtil.degToRad * 20) {
              if (DEBUG) {
                console.log(
                  "Moving slowly, at %s deg/s: no prediction",
                  (MathUtil.radToDeg * angularSpeed).toFixed(1)
                );
              }
              this.outQ.copy(currentQ);
              this.previousQ.copy(currentQ);
              return this.outQ;
            }
            var deltaT = timestampS - this.previousTimestampS;
            var predictAngle = angularSpeed * this.predictionTimeS;
            this.deltaQ.setFromAxisAngle(axis, predictAngle);
            this.outQ.copy(this.previousQ);
            this.outQ.multiply(this.deltaQ);
            this.previousQ.copy(currentQ);
            this.previousTimestampS = timestampS;
            return this.outQ;
          };
          module4.exports = PosePredictor;
        }, { "../math-util.js": 14 }], 20: [function(_dereq_2, module4, exports4) {
          function SensorSample(sample, timestampS) {
            this.set(sample, timestampS);
          }
          ;
          SensorSample.prototype.set = function(sample, timestampS) {
            this.sample = sample;
            this.timestampS = timestampS;
          };
          SensorSample.prototype.copy = function(sensorSample) {
            this.set(sensorSample.sample, sensorSample.timestampS);
          };
          module4.exports = SensorSample;
        }, {}], 21: [function(_dereq_2, module4, exports4) {
          var MathUtil = _dereq_2("./math-util.js");
          var Util = _dereq_2("./util.js");
          var ROTATE_SPEED = 0.5;
          function TouchPanner() {
            window.addEventListener("touchstart", this.onTouchStart_.bind(this));
            window.addEventListener("touchmove", this.onTouchMove_.bind(this));
            window.addEventListener("touchend", this.onTouchEnd_.bind(this));
            this.isTouching = false;
            this.rotateStart = new MathUtil.Vector2();
            this.rotateEnd = new MathUtil.Vector2();
            this.rotateDelta = new MathUtil.Vector2();
            this.theta = 0;
            this.orientation = new MathUtil.Quaternion();
          }
          TouchPanner.prototype.getOrientation = function() {
            this.orientation.setFromEulerXYZ(0, 0, this.theta);
            return this.orientation;
          };
          TouchPanner.prototype.resetSensor = function() {
            this.theta = 0;
          };
          TouchPanner.prototype.onTouchStart_ = function(e2) {
            if (e2.touches.length != 1) {
              return;
            }
            this.rotateStart.set(e2.touches[0].pageX, e2.touches[0].pageY);
            this.isTouching = true;
          };
          TouchPanner.prototype.onTouchMove_ = function(e2) {
            if (!this.isTouching) {
              return;
            }
            this.rotateEnd.set(e2.touches[0].pageX, e2.touches[0].pageY);
            this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
            this.rotateStart.copy(this.rotateEnd);
            if (Util.isIOS()) {
              this.rotateDelta.x *= -1;
            }
            var element = document.body;
            this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
          };
          TouchPanner.prototype.onTouchEnd_ = function(e2) {
            this.isTouching = false;
          };
          module4.exports = TouchPanner;
        }, { "./math-util.js": 14, "./util.js": 22 }], 22: [function(_dereq_2, module4, exports4) {
          var objectAssign = _dereq_2("object-assign");
          var Util = window.Util || {};
          Util.MIN_TIMESTEP = 1e-3;
          Util.MAX_TIMESTEP = 1;
          Util.base64 = function(mimeType, base64) {
            return "data:" + mimeType + ";base64," + base64;
          };
          Util.clamp = function(value, min, max) {
            return Math.min(Math.max(min, value), max);
          };
          Util.lerp = function(a, b, t) {
            return a + (b - a) * t;
          };
          Util.isIOS = function() {
            var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
            return function() {
              return isIOS;
            };
          }();
          Util.isSafari = function() {
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            return function() {
              return isSafari;
            };
          }();
          Util.isFirefoxAndroid = function() {
            var isFirefoxAndroid = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
            return function() {
              return isFirefoxAndroid;
            };
          }();
          Util.isLandscapeMode = function() {
            return window.orientation == 90 || window.orientation == -90;
          };
          Util.isTimestampDeltaValid = function(timestampDeltaS) {
            if (isNaN(timestampDeltaS)) {
              return false;
            }
            if (timestampDeltaS <= Util.MIN_TIMESTEP) {
              return false;
            }
            if (timestampDeltaS > Util.MAX_TIMESTEP) {
              return false;
            }
            return true;
          };
          Util.getScreenWidth = function() {
            return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
          };
          Util.getScreenHeight = function() {
            return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
          };
          Util.requestFullscreen = function(element) {
            if (element.requestFullscreen) {
              element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
              element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) {
              element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
              element.msRequestFullscreen();
            } else {
              return false;
            }
            return true;
          };
          Util.exitFullscreen = function() {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            } else {
              return false;
            }
            return true;
          };
          Util.getFullscreenElement = function() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
          };
          Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            for (var attribName in attribLocationMap)
              gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
            gl.linkProgram(program);
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            return program;
          };
          Util.getProgramUniforms = function(gl, program) {
            var uniforms = {};
            var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            var uniformName = "";
            for (var i = 0; i < uniformCount; i++) {
              var uniformInfo = gl.getActiveUniform(program, i);
              uniformName = uniformInfo.name.replace("[0]", "");
              uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
            }
            return uniforms;
          };
          Util.orthoMatrix = function(out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
          };
          Util.isMobile = function() {
            var check = false;
            (function(a) {
              if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
                check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
          };
          Util.extend = objectAssign;
          Util.safariCssSizeWorkaround = function(canvas) {
            if (Util.isIOS()) {
              var width = canvas.style.width;
              var height = canvas.style.height;
              canvas.style.width = parseInt(width) + 1 + "px";
              canvas.style.height = parseInt(height) + "px";
              console.log("Resetting width to...", width);
              setTimeout(function() {
                console.log("Done. Width is now", width);
                canvas.style.width = width;
                canvas.style.height = height;
              }, 100);
            }
            window.Util = Util;
            window.canvas = canvas;
          };
          Util.frameDataFromPose = function() {
            var piOver180 = Math.PI / 180;
            var rad45 = Math.PI * 0.25;
            function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
              var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45), downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45), leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45), rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
              out[0] = xScale;
              out[1] = 0;
              out[2] = 0;
              out[3] = 0;
              out[4] = 0;
              out[5] = yScale;
              out[6] = 0;
              out[7] = 0;
              out[8] = -((leftTan - rightTan) * xScale * 0.5);
              out[9] = (upTan - downTan) * yScale * 0.5;
              out[10] = far / (near - far);
              out[11] = -1;
              out[12] = 0;
              out[13] = 0;
              out[14] = far * near / (near - far);
              out[15] = 0;
              return out;
            }
            function mat4_fromRotationTranslation(out, q, v) {
              var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
              out[0] = 1 - (yy + zz);
              out[1] = xy + wz;
              out[2] = xz - wy;
              out[3] = 0;
              out[4] = xy - wz;
              out[5] = 1 - (xx + zz);
              out[6] = yz + wx;
              out[7] = 0;
              out[8] = xz + wy;
              out[9] = yz - wx;
              out[10] = 1 - (xx + yy);
              out[11] = 0;
              out[12] = v[0];
              out[13] = v[1];
              out[14] = v[2];
              out[15] = 1;
              return out;
            }
            ;
            function mat4_translate(out, a, v) {
              var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
              if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
              } else {
                a00 = a[0];
                a01 = a[1];
                a02 = a[2];
                a03 = a[3];
                a10 = a[4];
                a11 = a[5];
                a12 = a[6];
                a13 = a[7];
                a20 = a[8];
                a21 = a[9];
                a22 = a[10];
                a23 = a[11];
                out[0] = a00;
                out[1] = a01;
                out[2] = a02;
                out[3] = a03;
                out[4] = a10;
                out[5] = a11;
                out[6] = a12;
                out[7] = a13;
                out[8] = a20;
                out[9] = a21;
                out[10] = a22;
                out[11] = a23;
                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
              }
              return out;
            }
            ;
            mat4_invert = function(out, a) {
              var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              if (!det) {
                return null;
              }
              det = 1 / det;
              out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
              out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
              out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
              out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
              out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
              out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
              out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
              out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
              out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
              out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
              out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
              out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
              out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
              out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
              out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
              out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
              return out;
            };
            var defaultOrientation = new Float32Array([0, 0, 0, 1]);
            var defaultPosition = new Float32Array([0, 0, 0]);
            function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
              mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);
              var orientation = pose.orientation || defaultOrientation;
              var position = pose.position || defaultPosition;
              mat4_fromRotationTranslation(view, orientation, position);
              if (parameters)
                mat4_translate(view, view, parameters.offset);
              mat4_invert(view, view);
            }
            return function(frameData, pose, vrDisplay) {
              if (!frameData || !pose)
                return false;
              frameData.pose = pose;
              frameData.timestamp = pose.timestamp;
              updateEyeMatrices(
                frameData.leftProjectionMatrix,
                frameData.leftViewMatrix,
                pose,
                vrDisplay.getEyeParameters("left"),
                vrDisplay
              );
              updateEyeMatrices(
                frameData.rightProjectionMatrix,
                frameData.rightViewMatrix,
                pose,
                vrDisplay.getEyeParameters("right"),
                vrDisplay
              );
              return true;
            };
          }();
          module4.exports = Util;
        }, { "object-assign": 1 }], 23: [function(_dereq_2, module4, exports4) {
          var Emitter = _dereq_2("./emitter.js");
          var Util = _dereq_2("./util.js");
          var DeviceInfo = _dereq_2("./device-info.js");
          var DEFAULT_VIEWER = "CardboardV1";
          var VIEWER_KEY = "WEBVR_CARDBOARD_VIEWER";
          var CLASS_NAME = "webvr-polyfill-viewer-selector";
          function ViewerSelector() {
            try {
              this.selectedKey = localStorage.getItem(VIEWER_KEY) || DEFAULT_VIEWER;
            } catch (error) {
              console.error("Failed to load viewer profile: %s", error);
            }
            this.dialog = this.createDialog_(DeviceInfo.Viewers);
            this.root = null;
          }
          ViewerSelector.prototype = new Emitter();
          ViewerSelector.prototype.show = function(root) {
            this.root = root;
            root.appendChild(this.dialog);
            var selected = this.dialog.querySelector("#" + this.selectedKey);
            selected.checked = true;
            this.dialog.style.display = "block";
          };
          ViewerSelector.prototype.hide = function() {
            if (this.root && this.root.contains(this.dialog)) {
              this.root.removeChild(this.dialog);
            }
            this.dialog.style.display = "none";
          };
          ViewerSelector.prototype.getCurrentViewer = function() {
            return DeviceInfo.Viewers[this.selectedKey];
          };
          ViewerSelector.prototype.getSelectedKey_ = function() {
            var input = this.dialog.querySelector("input[name=field]:checked");
            if (input) {
              return input.id;
            }
            return null;
          };
          ViewerSelector.prototype.onSave_ = function() {
            this.selectedKey = this.getSelectedKey_();
            if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
              console.error("ViewerSelector.onSave_: this should never happen!");
              return;
            }
            this.emit("change", DeviceInfo.Viewers[this.selectedKey]);
            try {
              localStorage.setItem(VIEWER_KEY, this.selectedKey);
            } catch (error) {
              console.error("Failed to save viewer profile: %s", error);
            }
            this.hide();
          };
          ViewerSelector.prototype.createDialog_ = function(options) {
            var container = document.createElement("div");
            container.classList.add(CLASS_NAME);
            container.style.display = "none";
            var overlay = document.createElement("div");
            var s = overlay.style;
            s.position = "fixed";
            s.left = 0;
            s.top = 0;
            s.width = "100%";
            s.height = "100%";
            s.background = "rgba(0, 0, 0, 0.3)";
            overlay.addEventListener("click", this.hide.bind(this));
            var width = 280;
            var dialog = document.createElement("div");
            var s = dialog.style;
            s.boxSizing = "border-box";
            s.position = "fixed";
            s.top = "24px";
            s.left = "50%";
            s.marginLeft = -width / 2 + "px";
            s.width = width + "px";
            s.padding = "24px";
            s.overflow = "hidden";
            s.background = "#fafafa";
            s.fontFamily = "'Roboto', sans-serif";
            s.boxShadow = "0px 5px 20px #666";
            dialog.appendChild(this.createH1_("Select your viewer"));
            for (var id in options) {
              dialog.appendChild(this.createChoice_(id, options[id].label));
            }
            dialog.appendChild(this.createButton_("Save", this.onSave_.bind(this)));
            container.appendChild(overlay);
            container.appendChild(dialog);
            return container;
          };
          ViewerSelector.prototype.createH1_ = function(name) {
            var h1 = document.createElement("h1");
            var s = h1.style;
            s.color = "black";
            s.fontSize = "20px";
            s.fontWeight = "bold";
            s.marginTop = 0;
            s.marginBottom = "24px";
            h1.innerHTML = name;
            return h1;
          };
          ViewerSelector.prototype.createChoice_ = function(id, name) {
            var div = document.createElement("div");
            div.style.marginTop = "8px";
            div.style.color = "black";
            var input = document.createElement("input");
            input.style.fontSize = "30px";
            input.setAttribute("id", id);
            input.setAttribute("type", "radio");
            input.setAttribute("value", id);
            input.setAttribute("name", "field");
            var label = document.createElement("label");
            label.style.marginLeft = "4px";
            label.setAttribute("for", id);
            label.innerHTML = name;
            div.appendChild(input);
            div.appendChild(label);
            return div;
          };
          ViewerSelector.prototype.createButton_ = function(label, onclick) {
            var button = document.createElement("button");
            button.innerHTML = label;
            var s = button.style;
            s.float = "right";
            s.textTransform = "uppercase";
            s.color = "#1094f7";
            s.fontSize = "14px";
            s.letterSpacing = 0;
            s.border = 0;
            s.background = "none";
            s.marginTop = "16px";
            button.addEventListener("click", onclick);
            return button;
          };
          module4.exports = ViewerSelector;
        }, { "./device-info.js": 7, "./emitter.js": 12, "./util.js": 22 }], 24: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          function AndroidWakeLock() {
            var video = document.createElement("video");
            video.addEventListener("ended", function() {
              video.play();
            });
            this.request = function() {
              if (video.paused) {
                video.src = Util.base64("video/mp4", "AAAAGGZ0eXBpc29tAAAAAG1wNDFhdmMxAAAIA21vb3YAAABsbXZoZAAAAADSa9v60mvb+gABX5AAlw/gAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAdkdHJhawAAAFx0a2hkAAAAAdJr2/rSa9v6AAAAAQAAAAAAlw/gAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAHAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAJcP4AAAAAAAAQAAAAAG3G1kaWEAAAAgbWRoZAAAAADSa9v60mvb+gAPQkAGjneAFccAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABodtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAZHc3RibAAAAJdzdHNkAAAAAAAAAAEAAACHYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAMABwASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADFhdmNDAWQAC//hABlnZAALrNlfllw4QAAAAwBAAAADAKPFCmWAAQAFaOvssiwAAAAYc3R0cwAAAAAAAAABAAAAbgAPQkAAAAAUc3RzcwAAAAAAAAABAAAAAQAAA4BjdHRzAAAAAAAAAG4AAAABAD0JAAAAAAEAehIAAAAAAQA9CQAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEATEtAAAAAAQAehIAAAAABAAAAAAAAAAEAD0JAAAAAAQBMS0AAAAABAB6EgAAAAAEAAAAAAAAAAQAPQkAAAAABAExLQAAAAAEAHoSAAAAAAQAAAAAAAAABAA9CQAAAAAEALcbAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAABuAAAAAQAAAcxzdHN6AAAAAAAAAAAAAABuAAADCQAAABgAAAAOAAAADgAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABIAAAAOAAAADAAAAAwAAAASAAAADgAAAAwAAAAMAAAAEgAAAA4AAAAMAAAADAAAABMAAAAUc3RjbwAAAAAAAAABAAAIKwAAACt1ZHRhAAAAI6llbmMAFwAAdmxjIDIuMi4xIHN0cmVhbSBvdXRwdXQAAAAId2lkZQAACRRtZGF0AAACrgX//6vcRem95tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTQyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVmPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6b25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1hYnIgbWJ0cmVlPTEgYml0cmF0ZT0xMDAgcmF0ZXRvbD0xLjAgcWNvbXA9MC42MCBxcG1pbj0xMCBxcG1heD01MSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAU2WIhAAQ/8ltlOe+cTZuGkKg+aRtuivcDZ0pBsfsEi9p/i1yU9DxS2lq4dXTinViF1URBKXgnzKBd/Uh1bkhHtMrwrRcOJslD01UB+fyaL6ef+DBAAAAFEGaJGxBD5B+v+a+4QqF3MgBXz9MAAAACkGeQniH/+94r6EAAAAKAZ5hdEN/8QytwAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFomUwIIf/+4QAAAApBnoZFESw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAOQZrwSahBbJlMCCH//uEAAAAKQZ8ORRUsP/++gQAAAAgBny10Q3/EgQAAAAgBny9qQ3/EgAAAAA5BmzRJqEFsmUwIIf/+4AAAAApBn1JFFSw//76BAAAACAGfcXRDf8SAAAAACAGfc2pDf8SAAAAADkGbeEmoQWyZTAgh//7hAAAACkGflkUVLD//voAAAAAIAZ+1dEN/xIEAAAAIAZ+3akN/xIEAAAAOQZu8SahBbJlMCCH//uAAAAAKQZ/aRRUsP/++gQAAAAgBn/l0Q3/EgAAAAAgBn/tqQ3/EgQAAAA5Bm+BJqEFsmUwIIf/+4QAAAApBnh5FFSw//76AAAAACAGePXRDf8SAAAAACAGeP2pDf8SBAAAADkGaJEmoQWyZTAgh//7gAAAACkGeQkUVLD//voEAAAAIAZ5hdEN/xIAAAAAIAZ5jakN/xIEAAAAOQZpoSahBbJlMCCH//uEAAAAKQZ6GRRUsP/++gQAAAAgBnqV0Q3/EgQAAAAgBnqdqQ3/EgAAAAA5BmqxJqEFsmUwIIf/+4AAAAApBnspFFSw//76BAAAACAGe6XRDf8SAAAAACAGe62pDf8SAAAAADkGa8EmoQWyZTAgh//7hAAAACkGfDkUVLD//voEAAAAIAZ8tdEN/xIEAAAAIAZ8vakN/xIAAAAAOQZs0SahBbJlMCCH//uAAAAAKQZ9SRRUsP/++gQAAAAgBn3F0Q3/EgAAAAAgBn3NqQ3/EgAAAAA5Bm3hJqEFsmUwIIf/+4QAAAApBn5ZFFSw//76AAAAACAGftXRDf8SBAAAACAGft2pDf8SBAAAADkGbvEmoQWyZTAgh//7gAAAACkGf2kUVLD//voEAAAAIAZ/5dEN/xIAAAAAIAZ/7akN/xIEAAAAOQZvgSahBbJlMCCH//uEAAAAKQZ4eRRUsP/++gAAAAAgBnj10Q3/EgAAAAAgBnj9qQ3/EgQAAAA5BmiRJqEFsmUwIIf/+4AAAAApBnkJFFSw//76BAAAACAGeYXRDf8SAAAAACAGeY2pDf8SBAAAADkGaaEmoQWyZTAgh//7hAAAACkGehkUVLD//voEAAAAIAZ6ldEN/xIEAAAAIAZ6nakN/xIAAAAAOQZqsSahBbJlMCCH//uAAAAAKQZ7KRRUsP/++gQAAAAgBnul0Q3/EgAAAAAgBnutqQ3/EgAAAAA5BmvBJqEFsmUwIIf/+4QAAAApBnw5FFSw//76BAAAACAGfLXRDf8SBAAAACAGfL2pDf8SAAAAADkGbNEmoQWyZTAgh//7gAAAACkGfUkUVLD//voEAAAAIAZ9xdEN/xIAAAAAIAZ9zakN/xIAAAAAOQZt4SahBbJlMCCH//uEAAAAKQZ+WRRUsP/++gAAAAAgBn7V0Q3/EgQAAAAgBn7dqQ3/EgQAAAA5Bm7xJqEFsmUwIIf/+4AAAAApBn9pFFSw//76BAAAACAGf+XRDf8SAAAAACAGf+2pDf8SBAAAADkGb4EmoQWyZTAgh//7hAAAACkGeHkUVLD//voAAAAAIAZ49dEN/xIAAAAAIAZ4/akN/xIEAAAAOQZokSahBbJlMCCH//uAAAAAKQZ5CRRUsP/++gQAAAAgBnmF0Q3/EgAAAAAgBnmNqQ3/EgQAAAA5BmmhJqEFsmUwIIf/+4QAAAApBnoZFFSw//76BAAAACAGepXRDf8SBAAAACAGep2pDf8SAAAAADkGarEmoQWyZTAgh//7gAAAACkGeykUVLD//voEAAAAIAZ7pdEN/xIAAAAAIAZ7rakN/xIAAAAAPQZruSahBbJlMFEw3//7B");
                video.play();
              }
            };
            this.release = function() {
              video.pause();
              video.src = "";
            };
          }
          function iOSWakeLock() {
            var timer = null;
            this.request = function() {
              if (!timer) {
                timer = setInterval(function() {
                  window.location = window.location;
                  setTimeout(window.stop, 0);
                }, 3e4);
              }
            };
            this.release = function() {
              if (timer) {
                clearInterval(timer);
                timer = null;
              }
            };
          }
          function getWakeLock() {
            var userAgent = navigator.userAgent || navigator.vendor || window.opera;
            if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
              return iOSWakeLock;
            } else {
              return AndroidWakeLock;
            }
          }
          module4.exports = getWakeLock();
        }, { "./util.js": 22 }], 25: [function(_dereq_2, module4, exports4) {
          var Util = _dereq_2("./util.js");
          var CardboardVRDisplay = _dereq_2("./cardboard-vr-display.js");
          var MouseKeyboardVRDisplay = _dereq_2("./mouse-keyboard-vr-display.js");
          var VRDisplay = _dereq_2("./base.js").VRDisplay;
          var VRFrameData2 = _dereq_2("./base.js").VRFrameData;
          var HMDVRDevice = _dereq_2("./base.js").HMDVRDevice;
          var PositionSensorVRDevice = _dereq_2("./base.js").PositionSensorVRDevice;
          var VRDisplayHMDDevice = _dereq_2("./display-wrappers.js").VRDisplayHMDDevice;
          var VRDisplayPositionSensorDevice = _dereq_2("./display-wrappers.js").VRDisplayPositionSensorDevice;
          function WebVRPolyfill() {
            this.displays = [];
            this.devices = [];
            this.devicesPopulated = false;
            this.nativeWebVRAvailable = this.isWebVRAvailable();
            this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();
            if (!this.nativeLegacyWebVRAvailable) {
              if (!this.nativeWebVRAvailable) {
                this.enablePolyfill();
              }
              if (WebVRConfig.ENABLE_DEPRECATED_API) {
                this.enableDeprecatedPolyfill();
              }
            }
            InstallWebVRSpecShim();
          }
          WebVRPolyfill.prototype.isWebVRAvailable = function() {
            return "getVRDisplays" in navigator;
          };
          WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function() {
            return "getVRDevices" in navigator || "mozGetVRDevices" in navigator;
          };
          WebVRPolyfill.prototype.populateDevices = function() {
            if (this.devicesPopulated) {
              return;
            }
            var vrDisplay = null;
            if (this.isCardboardCompatible()) {
              vrDisplay = new CardboardVRDisplay();
              this.displays.push(vrDisplay);
              if (WebVRConfig.ENABLE_DEPRECATED_API) {
                this.devices.push(new VRDisplayHMDDevice(vrDisplay));
                this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
              }
            }
            if (!this.isMobile() && !WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
              vrDisplay = new MouseKeyboardVRDisplay();
              this.displays.push(vrDisplay);
              if (WebVRConfig.ENABLE_DEPRECATED_API) {
                this.devices.push(new VRDisplayHMDDevice(vrDisplay));
                this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
              }
            }
            this.devicesPopulated = true;
          };
          WebVRPolyfill.prototype.enablePolyfill = function() {
            navigator.getVRDisplays = this.getVRDisplays.bind(this);
            window.VRDisplay = VRDisplay;
            var self2 = this;
            Object.defineProperty(navigator, "vrEnabled", {
              get: function() {
                return self2.isCardboardCompatible() && (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || false);
              }
            });
            window.VRFrameData = VRFrameData2;
          };
          WebVRPolyfill.prototype.enableDeprecatedPolyfill = function() {
            navigator.getVRDevices = this.getVRDevices.bind(this);
            window.HMDVRDevice = HMDVRDevice;
            window.PositionSensorVRDevice = PositionSensorVRDevice;
          };
          WebVRPolyfill.prototype.getVRDisplays = function() {
            this.populateDevices();
            var displays = this.displays;
            return new Promise(function(resolve, reject) {
              try {
                resolve(displays);
              } catch (e2) {
                reject(e2);
              }
            });
          };
          WebVRPolyfill.prototype.getVRDevices = function() {
            console.warn("getVRDevices is deprecated. Please update your code to use getVRDisplays instead.");
            var self2 = this;
            return new Promise(function(resolve, reject) {
              try {
                if (!self2.devicesPopulated) {
                  if (self2.nativeWebVRAvailable) {
                    return navigator.getVRDisplays(function(displays) {
                      for (var i = 0; i < displays.length; ++i) {
                        self2.devices.push(new VRDisplayHMDDevice(displays[i]));
                        self2.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
                      }
                      self2.devicesPopulated = true;
                      resolve(self2.devices);
                    }, reject);
                  }
                  if (self2.nativeLegacyWebVRAvailable) {
                    return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function(devices) {
                      for (var i = 0; i < devices.length; ++i) {
                        if (devices[i] instanceof HMDVRDevice) {
                          self2.devices.push(devices[i]);
                        }
                        if (devices[i] instanceof PositionSensorVRDevice) {
                          self2.devices.push(devices[i]);
                        }
                      }
                      self2.devicesPopulated = true;
                      resolve(self2.devices);
                    }, reject);
                  }
                }
                self2.populateDevices();
                resolve(self2.devices);
              } catch (e2) {
                reject(e2);
              }
            });
          };
          WebVRPolyfill.prototype.isMobile = function() {
            return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent);
          };
          WebVRPolyfill.prototype.isCardboardCompatible = function() {
            return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
          };
          function InstallWebVRSpecShim() {
            if ("VRDisplay" in window && !("VRFrameData" in window)) {
              window.VRFrameData = VRFrameData2;
              if (!("depthNear" in window.VRDisplay.prototype)) {
                window.VRDisplay.prototype.depthNear = 0.01;
              }
              if (!("depthFar" in window.VRDisplay.prototype)) {
                window.VRDisplay.prototype.depthFar = 1e4;
              }
              window.VRDisplay.prototype.getFrameData = function(frameData) {
                return Util.frameDataFromPose(frameData, this.getPose(), this);
              };
            }
          }
          ;
          module4.exports.WebVRPolyfill = WebVRPolyfill;
        }, { "./base.js": 2, "./cardboard-vr-display.js": 5, "./display-wrappers.js": 8, "./mouse-keyboard-vr-display.js": 15, "./util.js": 22 }] }, {}, [13]);
      }, {}], 20: [function(_dereq_, module3, exports3) {
        module3.exports = {
          "name": "aframe",
          "version": "0.4.0",
          "description": "A web framework for building virtual reality experiences.",
          "homepage": "https://aframe.io/",
          "main": "dist/aframe-master.js",
          "scripts": {
            "browserify": "browserify src/index.js -s 'AFRAME' -p browserify-derequire",
            "build": "mkdirp build/ && npm run browserify -- --debug -t [envify --INSPECTOR_VERSION dev] -o build/aframe.js",
            "codecov": "codecov",
            "dev": "npm run build && cross-env INSPECTOR_VERSION=dev node ./scripts/budo -t envify",
            "dist": "npm run dist:min && npm run dist:max",
            "dist:max": "npm run browserify -s -- --debug -t [envify --INSPECTOR_VERSION dev] | exorcist dist/aframe-master.js.map > dist/aframe-master.js",
            "dist:min": "npm run browserify -s -- --debug -t [envify --INSPECTOR_VERSION dev] -p [minifyify --map aframe-master.min.js.map --output dist/aframe-master.min.js.map] -o dist/aframe-master.min.js",
            "docs": "markserv --dir docs --port 9001",
            "ghpages": "ghpages -p gh-pages/",
            "lint": "semistandard -v | snazzy",
            "precommit": "npm run lint",
            "preghpages": "npm run dist && rimraf gh-pages && mkdirp gh-pages && cp -r {.nojekyll,dist,lib,examples,index.html,style} gh-pages/. 2>/dev/null || : && git checkout dist/ && replace 'build/aframe.js' 'dist/aframe.min.js' gh-pages/ -r --silent",
            "prerelease": "npm run dist && node scripts/release.js 0.3.2 0.4.0",
            "start": "npm run dev",
            "test": "karma start ./tests/karma.conf.js",
            "test:docs": "node scripts/docs-lint.js",
            "test:firefox": "karma start ./tests/karma.conf.js --browsers Firefox",
            "test:chrome": "karma start ./tests/karma.conf.js --browsers Chrome",
            "test:ci": "TEST_ENV=ci karma start ./tests/karma.conf.js --single-run --browsers Firefox"
          },
          "repository": "aframevr/aframe",
          "license": "MIT",
          "dependencies": {
            "browserify-css": "^0.8.2",
            "debug": "^2.2.0",
            "deep-assign": "^2.0.0",
            "document-register-element": "dmarcos/document-register-element#8ccc532b7",
            "object-assign": "^4.0.1",
            "present": "0.0.6",
            "promise-polyfill": "^3.1.0",
            "style-attr": "^1.0.2",
            "three": "^0.82.1",
            "tween.js": "^15.0.0",
            "webvr-polyfill": "^0.9.23"
          },
          "devDependencies": {
            "browserify": "^13.1.0",
            "browserify-derequire": "^0.9.4",
            "browserify-istanbul": "^2.0.0",
            "budo": "^9.2.0",
            "chai": "^3.5.0",
            "chai-shallow-deep-equal": "^1.4.0",
            "chalk": "^1.1.3",
            "codecov": "^1.0.1",
            "cross-env": "^3.1.3",
            "envify": "^3.4.1",
            "exorcist": "^0.4.0",
            "ghpages": "0.0.8",
            "glob": "^7.1.1",
            "husky": "^0.11.7",
            "istanbul": "^0.4.5",
            "karma": "^1.3.0",
            "karma-browserify": "^5.1.0",
            "karma-chai-shallow-deep-equal": "0.0.4",
            "karma-chrome-launcher": "^2.0.0",
            "karma-coverage": "^1.1.1",
            "karma-env-preprocessor": "^0.1.1",
            "karma-firefox-launcher": "^1.0.0",
            "karma-mocha": "^1.1.1",
            "karma-mocha-reporter": "^2.1.0",
            "karma-sinon-chai": "^1.2.4",
            "lolex": "^1.5.1",
            "markserv": "0.0.20",
            "minifyify": "^7.3.3",
            "mkdirp": "^0.5.1",
            "mocha": "^3.0.2",
            "mozilla-download": "^1.1.1",
            "open": "0.0.5",
            "replace": "^0.3.0",
            "rimraf": "^2.5.4",
            "semistandard": "^9.0.0",
            "sinon": "^1.17.5",
            "sinon-chai": "^2.8.0",
            "snazzy": "^5.0.0",
            "too-wordy": "ngokevin/too-wordy",
            "uglifyjs": "^2.4.10",
            "write-good": "^0.9.1"
          },
          "link": true,
          "browserify": {
            "transform": [
              "browserify-css",
              "envify"
            ]
          },
          "semistandard": {
            "ignore": [
              "build/**",
              "dist/**",
              "examples/**/shaders/*.js",
              "**/vendor/**"
            ]
          },
          "keywords": [
            "3d",
            "aframe",
            "cardboard",
            "components",
            "oculus",
            "three",
            "three.js",
            "rift",
            "vive",
            "vr",
            "web-components",
            "webvr"
          ],
          "browserify-css": {
            "minify": true
          },
          "engines": {
            "node": ">= 4.6.0",
            "npm": "^2.15.9"
          }
        };
      }, {}], 21: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        module3.exports.Component = registerComponent("blend-character-model", {
          schema: { type: "asset" },
          init: function() {
            this.model = null;
          },
          update: function() {
            var self2 = this;
            var el = this.el;
            var src = this.data;
            if (!src) {
              return;
            }
            this.remove();
            this.model = new THREE2.BlendCharacter();
            this.model.load(src, function() {
              el.setObject3D("mesh", self2.model);
              el.emit("model-loaded", { format: "blend", model: self2.model });
              self2.model.castShadow = true;
              self2.model.receiveShadow = true;
              self2.model.material.shading = THREE2.FlatShading;
              self2.model.geometry.computeBoundingBox();
            });
          },
          remove: function() {
            if (!this.model) {
              return;
            }
            this.el.removeObject3D("mesh");
          }
        });
      }, { "../core/component": 63, "../lib/three": 106 }], 22: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var bind = utils.bind;
        var checkHasPositionalTracking = utils.device.checkHasPositionalTracking;
        module3.exports.Component = registerComponent("camera", {
          schema: {
            active: { default: true },
            far: { default: 1e4 },
            fov: { default: 80, min: 0 },
            near: { default: 5e-3, min: 0 },
            userHeight: { default: 0, min: 0 },
            zoom: { default: 1, min: 0 }
          },
          /**
           * Initialize three.js camera and add it to the entity.
           * Add reference from scene to this entity as the camera.
           */
          init: function() {
            var camera;
            var el = this.el;
            var sceneEl = el.sceneEl;
            this.savedPose = null;
            camera = this.camera = new THREE2.PerspectiveCamera();
            el.setObject3D("camera", camera);
            this.onEnterVR = bind(this.onEnterVR, this);
            this.onExitVR = bind(this.onExitVR, this);
            sceneEl.addEventListener("enter-vr", this.onEnterVR);
            sceneEl.addEventListener("exit-vr", this.onExitVR);
          },
          /**
           * Update three.js camera.
           */
          update: function(oldData) {
            var el = this.el;
            var data = this.data;
            var camera = this.camera;
            var system = this.system;
            this.addHeightOffset(oldData.userHeight);
            camera.aspect = data.aspect || window.innerWidth / window.innerHeight;
            camera.far = data.far;
            camera.fov = data.fov;
            camera.near = data.near;
            camera.zoom = data.zoom;
            camera.updateProjectionMatrix();
            if (oldData && oldData.active === data.active) {
              return;
            }
            if (data.active && system.activeCameraEl !== el) {
              system.setActiveCamera(el);
            } else if (!data.active && system.activeCameraEl === el) {
              system.disableActiveCamera();
            }
          },
          /**
           * Remove camera on remove (callback).
           */
          remove: function() {
            var sceneEl = this.el.sceneEl;
            this.el.removeObject3D("camera");
            sceneEl.removeEventListener("enter-vr", this.onEnterVR);
            sceneEl.removeEventListener("exit-vr", this.onExitVR);
          },
          /**
           * Save pose and remove the offset.
           */
          onEnterVR: function() {
            this.saveCameraPose();
            this.removeHeightOffset();
          },
          /**
           * Restore the pose. Do not need to re-add the offset because it was saved on entering VR.
           */
          onExitVR: function() {
            this.restoreCameraPose();
          },
          /**
           * Offsets the position of the camera to set a human scale perspective
           * This offset is not necessary when using a headset because the SDK
           * will return the real user's head height and position.
           */
          addHeightOffset: function(oldOffset) {
            var el = this.el;
            var currentPosition;
            var userHeightOffset = this.data.userHeight;
            oldOffset = oldOffset || 0;
            currentPosition = el.getAttribute("position") || { x: 0, y: 0, z: 0 };
            el.setAttribute("position", {
              x: currentPosition.x,
              y: currentPosition.y - oldOffset + userHeightOffset,
              z: currentPosition.z
            });
          },
          /**
           * Remove the height offset (called when entering VR) since WebVR API gives absolute
           * position.
           */
          removeHeightOffset: function() {
            var currentPosition;
            var el = this.el;
            var hasPositionalTracking;
            var userHeightOffset = this.data.userHeight;
            hasPositionalTracking = this.hasPositionalTracking || checkHasPositionalTracking();
            if (!userHeightOffset || !hasPositionalTracking) {
              return;
            }
            currentPosition = el.getAttribute("position") || { x: 0, y: 0, z: 0 };
            el.setAttribute("position", {
              x: currentPosition.x,
              y: currentPosition.y - userHeightOffset,
              z: currentPosition.z
            });
          },
          /**
           * Save camera pose before entering VR to restore later if exiting.
           */
          saveCameraPose: function() {
            var el = this.el;
            var hasPositionalTracking = this.hasPositionalTracking || checkHasPositionalTracking();
            if (this.savedPose || !hasPositionalTracking) {
              return;
            }
            this.savedPose = {
              position: el.getAttribute("position"),
              rotation: el.getAttribute("rotation")
            };
          },
          /**
           * Reset camera pose to before entering VR.
           */
          restoreCameraPose: function() {
            var el = this.el;
            var savedPose = this.savedPose;
            var hasPositionalTracking = this.hasPositionalTracking || checkHasPositionalTracking();
            if (!savedPose || !hasPositionalTracking) {
              return;
            }
            el.setAttribute("position", savedPose.position);
            el.setAttribute("rotation", savedPose.rotation);
            this.savedPose = null;
          }
        });
      }, { "../core/component": 63, "../lib/three": 106, "../utils/": 124 }], 23: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        module3.exports.Component = registerComponent("collada-model", {
          schema: { type: "asset" },
          init: function() {
            this.model = null;
            this.loader = new THREE2.ColladaLoader();
            this.loader.options.convertUpAxis = true;
          },
          update: function() {
            var self2 = this;
            var el = this.el;
            var src = this.data;
            if (!src) {
              return;
            }
            this.remove();
            this.loader.load(src, function(colladaModel) {
              self2.model = colladaModel.scene;
              el.setObject3D("mesh", self2.model);
              el.emit("model-loaded", { format: "collada", model: self2.model });
            });
          },
          remove: function() {
            if (!this.model) {
              return;
            }
            this.el.removeObject3D("mesh");
          }
        });
      }, { "../core/component": 63, "../lib/three": 106 }], 24: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var utils = _dereq_("../utils/");
        var bind = utils.bind;
        var EVENTS = {
          CLICK: "click",
          FUSING: "fusing",
          MOUSEENTER: "mouseenter",
          MOUSEDOWN: "mousedown",
          MOUSELEAVE: "mouseleave",
          MOUSEUP: "mouseup"
        };
        var STATES = {
          FUSING: "cursor-fusing",
          HOVERING: "cursor-hovering",
          HOVERED: "cursor-hovered"
        };
        module3.exports.Component = registerComponent("cursor", {
          dependencies: ["raycaster"],
          schema: {
            fuse: { default: utils.device.isMobile() },
            fuseTimeout: { default: 1500, min: 0 }
          },
          init: function() {
            var cursorEl = this.el;
            var canvas = cursorEl.sceneEl.canvas;
            this.fuseTimeout = void 0;
            this.mouseDownEl = null;
            this.intersection = null;
            this.intersectedEl = null;
            if (!canvas) {
              cursorEl.sceneEl.addEventListener("render-target-loaded", bind(this.init, this));
              return;
            }
            canvas.addEventListener("mousedown", bind(this.onMouseDown, this));
            canvas.addEventListener("mouseup", bind(this.onMouseUp, this));
            cursorEl.addEventListener("raycaster-intersection", bind(this.onIntersection, this));
            cursorEl.addEventListener(
              "raycaster-intersection-cleared",
              bind(this.onIntersectionCleared, this)
            );
          },
          /**
           * Trigger mousedown and keep track of the mousedowned entity.
           */
          onMouseDown: function(evt) {
            this.twoWayEmit(EVENTS.MOUSEDOWN);
            this.mouseDownEl = this.intersectedEl;
          },
          /**
           * Trigger mouseup if:
           * - Not fusing (mobile has no mouse).
           * - Currently intersecting an entity.
           * - Currently-intersected entity is the same as the one when mousedown was triggered,
           *   in case user mousedowned one entity, dragged to another, and mouseupped.
           */
          onMouseUp: function(evt) {
            this.twoWayEmit(EVENTS.MOUSEUP);
            if (this.data.fuse || !this.intersectedEl || this.mouseDownEl !== this.intersectedEl) {
              return;
            }
            this.twoWayEmit(EVENTS.CLICK);
          },
          /**
           * Handle intersection.
           */
          onIntersection: function(evt) {
            var self2 = this;
            var cursorEl = this.el;
            var data = this.data;
            var index;
            var intersectedEl;
            var intersection;
            index = evt.detail.els[0] === cursorEl ? 1 : 0;
            intersection = evt.detail.intersections[index];
            intersectedEl = evt.detail.els[index];
            if (!intersectedEl) {
              return;
            }
            if (this.intersectedEl === intersectedEl) {
              this.intersection = intersection;
              return;
            }
            if (this.intersectedEl) {
              this.clearCurrentIntersection();
            }
            this.intersection = intersection;
            this.intersectedEl = intersectedEl;
            cursorEl.addState(STATES.HOVERING);
            intersectedEl.addState(STATES.HOVERED);
            self2.twoWayEmit(EVENTS.MOUSEENTER);
            if (data.fuseTimeout === 0 || !data.fuse) {
              return;
            }
            cursorEl.addState(STATES.FUSING);
            this.twoWayEmit(EVENTS.FUSING);
            this.fuseTimeout = setTimeout(function fuse() {
              cursorEl.removeState(STATES.FUSING);
              self2.twoWayEmit(EVENTS.CLICK);
            }, data.fuseTimeout);
          },
          /**
           * Handle intersection cleared.
           */
          onIntersectionCleared: function(evt) {
            var cursorEl = this.el;
            var intersectedEl = evt.detail.el;
            if (cursorEl === intersectedEl) {
              return;
            }
            if (intersectedEl !== this.intersectedEl) {
              return;
            }
            this.clearCurrentIntersection();
          },
          clearCurrentIntersection: function() {
            var cursorEl = this.el;
            this.intersectedEl.removeState(STATES.HOVERED);
            cursorEl.removeState(STATES.HOVERING);
            cursorEl.removeState(STATES.FUSING);
            this.twoWayEmit(EVENTS.MOUSELEAVE);
            this.intersection = null;
            this.intersectedEl = null;
            clearTimeout(this.fuseTimeout);
          },
          /**
           * Helper to emit on both the cursor and the intersected entity (if exists).
           */
          twoWayEmit: function(evtName) {
            var el = this.el;
            var intersectedEl = this.intersectedEl;
            var intersection = this.intersection;
            el.emit(evtName, { intersectedEl, intersection });
            if (!intersectedEl) {
              return;
            }
            intersectedEl.emit(evtName, { cursorEl: el, intersection });
          }
        });
      }, { "../core/component": 63, "../utils/": 124 }], 25: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("../utils/debug");
        var geometries = _dereq_("../core/geometry").geometries;
        var geometryNames = _dereq_("../core/geometry").geometryNames;
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var dummyGeometry = new THREE2.Geometry();
        var warn = debug("components:geometry:warn");
        module3.exports.Component = registerComponent("geometry", {
          schema: {
            buffer: { default: true },
            mergeTo: { type: "selector" },
            primitive: { default: "box", oneOf: geometryNames },
            skipCache: { default: false }
          },
          init: function() {
            this.geometry = null;
          },
          /**
           * Talk to geometry system to get or create geometry.
           */
          update: function(previousData) {
            var data = this.data;
            var mesh = this.el.getOrCreateObject3D("mesh", THREE2.Mesh);
            var system = this.system;
            if (this.geometry) {
              system.unuseGeometry(previousData);
              this.geometry = null;
            }
            this.geometry = mesh.geometry = system.getOrCreateGeometry(data);
            if (data.mergeTo) {
              this.mergeTo(data.mergeTo);
            }
          },
          /**
           * Merge geometry to another entity's geometry.
           * Remove the entity from the scene. Not a reversible operation.
           *
           * @param {Element} toEl - Entity where the geometry will be merged to.
           */
          mergeTo: function(toEl) {
            var el = this.el;
            var mesh = el.getObject3D("mesh");
            var toMesh;
            if (!toEl) {
              warn("There is not a valid entity to merge the geometry to");
              return;
            }
            if (toEl === el) {
              warn("Source and target geometries cannot be the same for merge");
              return;
            }
            toMesh = toEl.getObject3D("mesh");
            if (!toMesh) {
              toMesh = toEl.getOrCreateObject3D("mesh", THREE2.Mesh);
              toEl.setAttribute("material", el.getAttribute("material"));
              return;
            }
            if (toMesh.geometry instanceof THREE2.Geometry === false || mesh.geometry instanceof THREE2.Geometry === false) {
              warn("Geometry merge is only available for `THREE.Geometry` types. Check that both of the merging geometry and the target geometry have `buffer` set to false");
              return;
            }
            if (this.data.skipCache === false) {
              warn("Cached geometries are not allowed to merge. Set `skipCache` to true");
              return;
            }
            mesh.parent.updateMatrixWorld();
            toMesh.geometry.merge(mesh.geometry, mesh.matrixWorld);
            el.emit("geometry-merged", { mergeTarget: toEl });
            el.parentNode.removeChild(el);
          },
          /**
           * Tell geometry system that entity is no longer using the geometry.
           * Unset the geometry on the mesh
           */
          remove: function() {
            this.system.unuseGeometry(this.data);
            this.el.getObject3D("mesh").geometry = dummyGeometry;
            this.geometry = null;
          },
          /**
           * Update geometry component schema based on geometry type.
           *
           * @param {object} data - New data passed by Component.
           */
          updateSchema: function(data) {
            var newGeometryType = data.primitive;
            var currentGeometryType = this.data && this.data.primitive;
            var schema = geometries[newGeometryType] && geometries[newGeometryType].schema;
            if (!schema) {
              throw new Error("Unknown geometry schema `" + newGeometryType + "`");
            }
            if (currentGeometryType && currentGeometryType === newGeometryType) {
              return;
            }
            this.extendSchema(schema);
          }
        });
      }, { "../core/component": 63, "../core/geometry": 64, "../lib/three": 106, "../utils/debug": 120 }], 26: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var OCULUS_LEFT_HAND_MODEL_URL = "https://cdn.aframe.io/controllers/oculus-hands/leftHand.json";
        var OCULUS_RIGHT_HAND_MODEL_URL = "https://cdn.aframe.io/controllers/oculus-hands/rightHand.json";
        module3.exports.Component = registerComponent("hand-controls", {
          schema: { default: "left" },
          init: function() {
            var self2 = this;
            this.touchedButtons = {};
            this.pressedButtons = {};
            this.onGripDown = function() {
              self2.handleButton("grip", "down");
            };
            this.onGripUp = function() {
              self2.handleButton("grip", "up");
            };
            this.onTrackpadDown = function() {
              self2.handleButton("trackpad", "down");
            };
            this.onTrackpadUp = function() {
              self2.handleButton("trackpad", "up");
            };
            this.onTrackpadTouchStart = function() {
              self2.handleButton("trackpad", "touchstart");
            };
            this.onTrackpadTouchEnd = function() {
              self2.handleButton("trackpad", "touchend");
            };
            this.onTriggerDown = function() {
              self2.handleButton("trigger", "down");
            };
            this.onTriggerUp = function() {
              self2.handleButton("trigger", "up");
            };
            this.onTriggerTouchStart = function() {
              self2.handleButton("trigger", "touchstart");
            };
            this.onTriggerTouchEnd = function() {
              self2.handleButton("trigger", "touchend");
            };
            this.onGripTouchStart = function() {
              self2.handleButton("grip", "touchstart");
            };
            this.onGripTouchEnd = function() {
              self2.handleButton("grip", "touchend");
            };
            this.onThumbstickDown = function() {
              self2.handleButton("thumbstick", "down");
            };
            this.onThumbstickUp = function() {
              self2.handleButton("thumbstick", "up");
            };
            this.onAorXTouchStart = function() {
              self2.handleButton("AorX", "touchstart");
            };
            this.onAorXTouchEnd = function() {
              self2.handleButton("AorX", "touchend");
            };
            this.onBorYTouchStart = function() {
              self2.handleButton("BorY", "touchstart");
            };
            this.onBorYTouchEnd = function() {
              self2.handleButton("BorY", "touchend");
            };
            this.onSurfaceTouchStart = function() {
              self2.handleButton("surface", "touchstart");
            };
            this.onSurfaceTouchEnd = function() {
              self2.handleButton("surface", "touchend");
            };
          },
          play: function() {
            this.addEventListeners();
          },
          pause: function() {
            this.removeEventListeners();
          },
          addEventListeners: function() {
            var el = this.el;
            el.addEventListener("gripdown", this.onGripDown);
            el.addEventListener("gripup", this.onGripUp);
            el.addEventListener("trackpaddown", this.onTrackpadDown);
            el.addEventListener("trackpadup", this.onTrackpadUp);
            el.addEventListener("trackpadtouchstart", this.onTrackpadTouchStart);
            el.addEventListener("trackpadtouchend", this.onTrackpadTouchEnd);
            el.addEventListener("triggerdown", this.onTriggerDown);
            el.addEventListener("triggerup", this.onTriggerUp);
            el.addEventListener("triggertouchstart", this.onTriggerTouchStart);
            el.addEventListener("triggertouchend", this.onTriggerTouchEnd);
            el.addEventListener("griptouchstart", this.onGripTouchStart);
            el.addEventListener("griptouchend", this.onGripTouchEnd);
            el.addEventListener("thumbstickdown", this.onThumbstickDown);
            el.addEventListener("thumbstickup", this.onThumbstickUp);
            el.addEventListener("Atouchstart", this.onAorXTouchStart);
            el.addEventListener("Atouchend", this.onAorXTouchEnd);
            el.addEventListener("Btouchstart", this.onBorYTouchStart);
            el.addEventListener("Btouchend", this.onBorYTouchEnd);
            el.addEventListener("Xtouchstart", this.onAorXTouchStart);
            el.addEventListener("Xtouchend", this.onAorXTouchEnd);
            el.addEventListener("Ytouchstart", this.onBorYTouchStart);
            el.addEventListener("Ytouchend", this.onBorYTouchEnd);
            el.addEventListener("surfacetouchstart", this.onSurfaceTouchStart);
            el.addEventListener("surfacetouchend", this.onSurfaceTouchEnd);
          },
          removeEventListeners: function() {
            var el = this.el;
            el.removeEventListener("gripdown", this.onGripDown);
            el.removeEventListener("gripup", this.onGripUp);
            el.removeEventListener("trackpaddown", this.onTrackpadDown);
            el.removeEventListener("trackpadup", this.onTrackpadUp);
            el.removeEventListener("trackpadtouchstart", this.onTrackpadTouchStart);
            el.removeEventListener("trackpadtouchend", this.onTrackpadTouchEnd);
            el.removeEventListener("triggerdown", this.onTriggerDown);
            el.removeEventListener("triggerup", this.onTriggerUp);
            el.removeEventListener("triggertouchstart", this.onTriggerTouchStart);
            el.removeEventListener("triggertouchend", this.onTriggerTouchEnd);
            el.removeEventListener("griptouchstart", this.onGripTouchStart);
            el.removeEventListener("griptouchend", this.onGripTouchEnd);
            el.removeEventListener("thumbstickdown", this.onThumbstickDown);
            el.removeEventListener("thumbstickup", this.onThumbstickUp);
            el.removeEventListener("Atouchstart", this.onAorXTouchStart);
            el.removeEventListener("Atouchend", this.onAorXTouchEnd);
            el.removeEventListener("Btouchstart", this.onBorYTouchStart);
            el.removeEventListener("Btouchend", this.onBorYTouchEnd);
            el.removeEventListener("Xtouchstart", this.onAorXTouchStart);
            el.removeEventListener("Xtouchend", this.onAorXTouchEnd);
            el.removeEventListener("Ytouchstart", this.onBorYTouchStart);
            el.removeEventListener("Ytouchend", this.onBorYTouchEnd);
            el.removeEventListener("surfacetouchstart", this.onSurfaceTouchStart);
            el.removeEventListener("surfacetouchend", this.onSurfaceTouchEnd);
          },
          update: function() {
            var el = this.el;
            var hand = this.data;
            var controlConfiguration = {
              hand,
              model: false,
              rotationOffset: hand === "left" ? 90 : -90
            };
            var modelUrl;
            if (hand === "left") {
              modelUrl = "url(" + OCULUS_LEFT_HAND_MODEL_URL + ")";
            } else {
              modelUrl = "url(" + OCULUS_RIGHT_HAND_MODEL_URL + ")";
            }
            el.setAttribute("vive-controls", controlConfiguration);
            el.setAttribute("oculus-touch-controls", controlConfiguration);
            el.setAttribute("blend-character-model", modelUrl);
          },
          /** Play the model animations based on the pressed button and kind of event.
            *
            * @param {string} button the name of the button
            * @param {string} evt the event associated to the button
            */
          handleButton: function(button, evt) {
            var isPressed = evt === "down";
            var isTouched = evt === "touchstart";
            var lastGesture;
            if (evt.indexOf("touch") === 0) {
              if (isTouched === this.touchedButtons[button]) {
                return;
              }
              this.touchedButtons[button] = isTouched;
            } else {
              if (isPressed === this.pressedButtons[button]) {
                return;
              }
              this.pressedButtons[button] = isPressed;
            }
            lastGesture = this.gesture;
            this.gesture = this.determineGesture();
            if (this.gesture === lastGesture) {
              return;
            }
            this.animateGesture(this.gesture);
            this.emitGestureEvents(this.gesture, lastGesture);
          },
          isViveController: function() {
            var trackedControls = this.el.components["tracked-controls"];
            var controllerId = trackedControls && trackedControls.controller && trackedControls.controller.id;
            return controllerId === "OpenVR Gamepad";
          },
          determineGesture: function() {
            var gesture;
            var isGripActive = this.pressedButtons["grip"];
            var isSurfaceActive = this.pressedButtons["surface"] || this.touchedButtons["surface"];
            var isTrackpadActive = this.pressedButtons["trackpad"] || this.touchedButtons["trackpad"];
            var isTriggerActive = this.pressedButtons["trigger"] || this.touchedButtons["trigger"];
            var isABXYActive = this.touchedButtons["AorX"] || this.touchedButtons["BorY"];
            var isVive = this.isViveController();
            if (isGripActive) {
              if (isVive) {
                gesture = "fist";
              } else if (isSurfaceActive || isABXYActive || isTrackpadActive) {
                gesture = isTriggerActive ? "fist" : "pointing";
              } else {
                gesture = isTriggerActive ? "thumb" : "pistol";
              }
            } else if (isTriggerActive) {
              gesture = isVive ? "fist" : "touch";
            } else if (isVive && isTrackpadActive) {
              gesture = "pointing";
            }
            return gesture;
          },
          gestureAnimationMapping: {
            "pointing": "pointing",
            "pistol": "pistol",
            "fist": "press",
            "touch": "touch",
            "thumb": "thumb"
          },
          animateGesture: function(gesture) {
            var isVive = this.isViveController();
            if (!gesture) {
              this.playAnimation("touch", !isVive);
              return;
            }
            var animation = this.gestureAnimationMapping[gesture];
            this.playAnimation(animation || "touch", !animation && !isVive);
          },
          // map to old vive-specific event names for now
          gestureEventMapping: {
            "fist": "grip",
            // fist: e.g. grip active, trigger active, trackpad / surface active
            "touch": "point",
            // 'touch' e.g. trigger active, grip not active
            "thumb": "thumb",
            // thumbs up: e.g. grip active, trigger active, trackpad / surface not active
            "pointing": "pointing",
            // pointing: e.g. grip active, trackpad / surface active, trigger not active
            "pistol": "pistol"
            // pistol: e.g. grip active, trigger not active, trackpad / surface not active
          },
          gestureEventName: function(gesture, active) {
            if (!gesture)
              return 0;
            var eventName = this.gestureEventMapping[gesture];
            if (eventName === "grip") {
              return eventName + (active ? "close" : "open");
            }
            if (eventName === "point" || eventName === "thumb") {
              return eventName + (active ? "up" : "down");
            }
            if (eventName === "pointing" || eventName === "pistol") {
              return eventName + (active ? "start" : "end");
            }
            return 0;
          },
          emitGestureEvents: function(gesture, lastGesture) {
            var el = this.el;
            var eventName;
            if (lastGesture !== gesture) {
              eventName = this.gestureEventName(lastGesture, false);
              if (eventName) {
                el.emit(eventName);
              }
              eventName = this.gestureEventName(gesture, true);
              if (eventName) {
                el.emit(eventName);
              }
            }
          },
          /**
            * Play the hand animations based on button state.
            *
            * @param {string} animation - the name of the animation.
            * @param {string} reverse - It the animation has to play in reverse.
            */
          playAnimation: function(animation, reverse) {
            var animationActive = this.animationActive;
            var timeScale = 1;
            var mesh = this.el.getObject3D("mesh");
            if (!mesh) {
              return;
            }
            if (reverse) {
              timeScale = -1;
            }
            if (animationActive) {
              mesh.play(animationActive, 0);
            }
            mesh.mixer.clipAction(animation).loop = 2200;
            mesh.mixer.clipAction(animation).clampWhenFinished = true;
            mesh.mixer.clipAction(animation).timeScale = timeScale;
            mesh.play(animation, 1);
            this.animationActive = animation;
          }
        });
      }, { "../core/component": 63 }], 27: [function(_dereq_, module3, exports3) {
        _dereq_("./blend-character-model");
        _dereq_("./camera");
        _dereq_("./collada-model");
        _dereq_("./cursor");
        _dereq_("./geometry");
        _dereq_("./hand-controls");
        _dereq_("./light");
        _dereq_("./look-controls");
        _dereq_("./material");
        _dereq_("./obj-model");
        _dereq_("./oculus-touch-controls");
        _dereq_("./position");
        _dereq_("./raycaster");
        _dereq_("./rotation");
        _dereq_("./scale");
        _dereq_("./sound");
        _dereq_("./tracked-controls");
        _dereq_("./visible");
        _dereq_("./vive-controls");
        _dereq_("./wasd-controls");
        _dereq_("./scene/auto-enter-vr");
        _dereq_("./scene/canvas");
        _dereq_("./scene/debug");
        _dereq_("./scene/embedded");
        _dereq_("./scene/inspector");
        _dereq_("./scene/fog");
        _dereq_("./scene/keyboard-shortcuts");
        _dereq_("./scene/pool");
        _dereq_("./scene/screenshot");
        _dereq_("./scene/stats");
        _dereq_("./scene/vr-mode-ui");
      }, { "./blend-character-model": 21, "./camera": 22, "./collada-model": 23, "./cursor": 24, "./geometry": 25, "./hand-controls": 26, "./light": 28, "./look-controls": 29, "./material": 30, "./obj-model": 31, "./oculus-touch-controls": 32, "./position": 33, "./raycaster": 34, "./rotation": 35, "./scale": 36, "./scene/auto-enter-vr": 37, "./scene/canvas": 38, "./scene/debug": 39, "./scene/embedded": 40, "./scene/fog": 41, "./scene/inspector": 42, "./scene/keyboard-shortcuts": 43, "./scene/pool": 44, "./scene/screenshot": 45, "./scene/stats": 46, "./scene/vr-mode-ui": 47, "./sound": 48, "./tracked-controls": 49, "./visible": 50, "./vive-controls": 51, "./wasd-controls": 52 }], 28: [function(_dereq_, module3, exports3) {
        var bind = _dereq_("../utils/bind");
        var diff = _dereq_("../utils").diff;
        var debug = _dereq_("../utils/debug");
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        var warn = debug("components:light:warn");
        module3.exports.Component = registerComponent("light", {
          schema: {
            angle: { default: 60, if: { type: ["spot"] } },
            color: { type: "color" },
            groundColor: { type: "color", if: { type: ["hemisphere"] } },
            decay: { default: 1, if: { type: ["point", "spot"] } },
            distance: { default: 0, min: 0, if: { type: ["point", "spot"] } },
            intensity: { default: 1, min: 0, if: { type: ["ambient", "directional", "hemisphere", "point", "spot"] } },
            penumbra: { default: 0, min: 0, max: 1, if: { type: ["spot"] } },
            type: {
              default: "directional",
              oneOf: ["ambient", "directional", "hemisphere", "point", "spot"]
            },
            target: { type: "selector", if: { type: ["spot", "directional"] } }
          },
          /**
           * Notifies scene a light has been added to remove default lighting.
           */
          init: function() {
            var el = this.el;
            this.light = null;
            this.defaultTarget = null;
            this.system.registerLight(el);
          },
          /**
           * (Re)create or update light.
           */
          update: function(oldData) {
            var data = this.data;
            var diffData = diff(data, oldData);
            var light = this.light;
            var self2 = this;
            if (light && !("type" in diffData)) {
              Object.keys(diffData).forEach(function(key) {
                var value = data[key];
                switch (key) {
                  case "color": {
                    light.color.set(value);
                    break;
                  }
                  case "groundColor": {
                    light.groundColor.set(value);
                    break;
                  }
                  case "angle": {
                    light.angle = degToRad(value);
                    break;
                  }
                  case "target": {
                    if (value === null) {
                      if (data.type === "spot" || data.type === "directional") {
                        light.target = self2.defaultTarget;
                      }
                    } else {
                      if (value.hasLoaded) {
                        self2.onSetTarget(value);
                      } else {
                        value.addEventListener("loaded", bind(self2.onSetTarget, self2, value));
                      }
                    }
                    break;
                  }
                  default: {
                    light[key] = value;
                  }
                }
              });
              return;
            }
            this.setLight(this.data);
          },
          setLight: function(data) {
            var el = this.el;
            var newLight = this.getLight(data);
            if (newLight) {
              if (this.light) {
                el.removeObject3D("light");
              }
              this.light = newLight;
              this.light.el = el;
              el.setObject3D("light", this.light);
              if (data.type === "spot" || data.type === "directional" || data.type === "hemisphere") {
                el.getObject3D("light").translateY(-1);
              }
              if (data.type === "spot") {
                el.setObject3D("light-target", this.defaultTarget);
                el.getObject3D("light-target").position.set(0, 0, -1);
              }
            }
          },
          /**
           * Creates a new three.js light object given data object defining the light.
           *
           * @param {object} data
           */
          getLight: function(data) {
            var angle = data.angle;
            var color = new THREE2.Color(data.color).getHex();
            var decay = data.decay;
            var distance = data.distance;
            var groundColor = new THREE2.Color(data.groundColor).getHex();
            var intensity = data.intensity;
            var type = data.type;
            var target = data.target;
            var light = null;
            switch (type.toLowerCase()) {
              case "ambient": {
                return new THREE2.AmbientLight(color, intensity);
              }
              case "directional": {
                light = new THREE2.DirectionalLight(color, intensity);
                this.defaultTarget = light.target;
                if (target) {
                  if (target.hasLoaded) {
                    this.onSetTarget(target);
                  } else {
                    target.addEventListener("loaded", bind(this.onSetTarget, this, target));
                  }
                }
                return light;
              }
              case "hemisphere": {
                return new THREE2.HemisphereLight(color, groundColor, intensity);
              }
              case "point": {
                return new THREE2.PointLight(color, intensity, distance, decay);
              }
              case "spot": {
                light = new THREE2.SpotLight(color, intensity, distance, degToRad(angle), data.penumbra, decay);
                this.defaultTarget = light.target;
                if (target) {
                  if (target.hasLoaded) {
                    this.onSetTarget(target);
                  } else {
                    target.addEventListener("loaded", bind(this.onSetTarget, this, target));
                  }
                }
                return light;
              }
              default: {
                warn("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.", type);
              }
            }
          },
          onSetTarget: function(targetEl) {
            this.light.target = targetEl.object3D;
          },
          /**
           * Remove light on remove (callback).
           */
          remove: function() {
            this.el.removeObject3D("light");
          }
        });
      }, { "../core/component": 63, "../lib/three": 106, "../utils": 124, "../utils/bind": 118, "../utils/debug": 120 }], 29: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var isMobile = _dereq_("../utils/").device.isMobile();
        var bind = _dereq_("../utils/bind");
        var PI_2 = Math.PI / 2;
        var radToDeg = THREE2.Math.radToDeg;
        module3.exports.Component = registerComponent("look-controls", {
          dependencies: ["position", "rotation"],
          schema: {
            enabled: { default: true },
            hmdEnabled: { default: true },
            reverseMouseDrag: { default: false },
            standing: { default: true }
          },
          init: function() {
            var sceneEl = this.el.sceneEl;
            this.previousHMDPosition = new THREE2.Vector3();
            this.setupMouseControls();
            this.setupHMDControls();
            this.bindMethods();
            function enableGrabCursor() {
              sceneEl.canvas.classList.add("a-grab-cursor");
            }
            if (!sceneEl.canvas) {
              sceneEl.addEventListener("render-target-loaded", enableGrabCursor);
            } else {
              enableGrabCursor();
            }
          },
          update: function(oldData) {
            var data = this.data;
            var hmdEnabled = data.hmdEnabled;
            if (!data.enabled) {
              return;
            }
            if (!hmdEnabled && oldData && hmdEnabled !== oldData.hmdEnabled) {
              this.pitchObject.rotation.set(0, 0, 0);
              this.yawObject.rotation.set(0, 0, 0);
            }
            this.controls.standing = data.standing;
            this.controls.update();
            this.updateOrientation();
            this.updatePosition();
          },
          play: function() {
            this.addEventListeners();
          },
          pause: function() {
            this.removeEventListeners();
          },
          tick: function(t) {
            this.update();
          },
          remove: function() {
            this.pause();
          },
          bindMethods: function() {
            this.onMouseDown = bind(this.onMouseDown, this);
            this.onMouseMove = bind(this.onMouseMove, this);
            this.releaseMouse = bind(this.releaseMouse, this);
            this.onTouchStart = bind(this.onTouchStart, this);
            this.onTouchMove = bind(this.onTouchMove, this);
            this.onTouchEnd = bind(this.onTouchEnd, this);
          },
          setupMouseControls: function() {
            this.mouseDown = false;
            this.pitchObject = new THREE2.Object3D();
            this.yawObject = new THREE2.Object3D();
            this.yawObject.position.y = 10;
            this.yawObject.add(this.pitchObject);
          },
          setupHMDControls: function() {
            this.dolly = new THREE2.Object3D();
            this.euler = new THREE2.Euler();
            this.controls = new THREE2.VRControls(this.dolly);
            this.controls.userHeight = 0;
          },
          addEventListeners: function() {
            var sceneEl = this.el.sceneEl;
            var canvasEl = sceneEl.canvas;
            if (!canvasEl) {
              sceneEl.addEventListener("render-target-loaded", bind(this.addEventListeners, this));
              return;
            }
            canvasEl.addEventListener("mousedown", this.onMouseDown, false);
            window.addEventListener("mousemove", this.onMouseMove, false);
            window.addEventListener("mouseup", this.releaseMouse, false);
            canvasEl.addEventListener("touchstart", this.onTouchStart);
            window.addEventListener("touchmove", this.onTouchMove);
            window.addEventListener("touchend", this.onTouchEnd);
          },
          removeEventListeners: function() {
            var sceneEl = this.el.sceneEl;
            var canvasEl = sceneEl && sceneEl.canvas;
            if (!canvasEl) {
              return;
            }
            canvasEl.removeEventListener("mousedown", this.onMouseDown);
            canvasEl.removeEventListener("mousemove", this.onMouseMove);
            canvasEl.removeEventListener("mouseup", this.releaseMouse);
            canvasEl.removeEventListener("mouseout", this.releaseMouse);
            canvasEl.removeEventListener("touchstart", this.onTouchStart);
            canvasEl.removeEventListener("touchmove", this.onTouchMove);
            canvasEl.removeEventListener("touchend", this.onTouchEnd);
          },
          updateOrientation: function() {
            var hmdEuler = new THREE2.Euler();
            return function() {
              var currentRotation;
              var deltaRotation;
              var pitchObject = this.pitchObject;
              var yawObject = this.yawObject;
              var hmdQuaternion = this.calculateHMDQuaternion();
              var sceneEl = this.el.sceneEl;
              var rotation;
              hmdEuler.setFromQuaternion(hmdQuaternion, "YXZ");
              if (isMobile) {
                rotation = {
                  x: radToDeg(hmdEuler.x) + radToDeg(pitchObject.rotation.x),
                  y: radToDeg(hmdEuler.y) + radToDeg(yawObject.rotation.y),
                  z: radToDeg(hmdEuler.z)
                };
              } else if (!sceneEl.is("vr-mode") || isNullVector(hmdEuler) || !this.data.hmdEnabled) {
                currentRotation = this.el.getAttribute("rotation");
                deltaRotation = this.calculateDeltaRotation();
                if (this.data.reverseMouseDrag) {
                  rotation = {
                    x: currentRotation.x - deltaRotation.x,
                    y: currentRotation.y - deltaRotation.y,
                    z: currentRotation.z
                  };
                } else {
                  rotation = {
                    x: currentRotation.x + deltaRotation.x,
                    y: currentRotation.y + deltaRotation.y,
                    z: currentRotation.z
                  };
                }
              } else {
                rotation = {
                  x: radToDeg(hmdEuler.x),
                  y: radToDeg(hmdEuler.y),
                  z: radToDeg(hmdEuler.z)
                };
              }
              this.el.setAttribute("rotation", rotation);
            };
          }(),
          calculateDeltaRotation: /* @__PURE__ */ function() {
            var previousRotationX;
            var previousRotationY;
            return function() {
              var currentRotationX = radToDeg(this.pitchObject.rotation.x);
              var currentRotationY = radToDeg(this.yawObject.rotation.y);
              var deltaRotation;
              previousRotationX = previousRotationX || currentRotationX;
              previousRotationY = previousRotationY || currentRotationY;
              deltaRotation = {
                x: currentRotationX - previousRotationX,
                y: currentRotationY - previousRotationY
              };
              previousRotationX = currentRotationX;
              previousRotationY = currentRotationY;
              return deltaRotation;
            };
          }(),
          calculateHMDQuaternion: function() {
            var hmdQuaternion = new THREE2.Quaternion();
            return function() {
              hmdQuaternion.copy(this.dolly.quaternion);
              return hmdQuaternion;
            };
          }(),
          updatePosition: function() {
            var deltaHMDPosition = new THREE2.Vector3();
            return function() {
              var el = this.el;
              var currentPosition = el.getAttribute("position");
              var currentHMDPosition;
              var previousHMDPosition = this.previousHMDPosition;
              var sceneEl = this.el.sceneEl;
              currentHMDPosition = this.calculateHMDPosition();
              deltaHMDPosition.copy(currentHMDPosition).sub(previousHMDPosition);
              if (!sceneEl.is("vr-mode") || isNullVector(deltaHMDPosition)) {
                return;
              }
              previousHMDPosition.copy(currentHMDPosition);
              if (!sceneEl.is("vr-mode")) {
                return;
              }
              el.setAttribute("position", {
                x: currentPosition.x + deltaHMDPosition.x,
                y: currentPosition.y + deltaHMDPosition.y,
                z: currentPosition.z + deltaHMDPosition.z
              });
            };
          }(),
          calculateHMDPosition: function() {
            var dolly = this.dolly;
            var position = new THREE2.Vector3();
            dolly.updateMatrix();
            position.setFromMatrixPosition(dolly.matrix);
            return position;
          },
          onMouseMove: function(event) {
            var pitchObject = this.pitchObject;
            var yawObject = this.yawObject;
            var previousMouseEvent = this.previousMouseEvent;
            if (!this.mouseDown || !this.data.enabled) {
              return;
            }
            var movementX = event.movementX || event.mozMovementX;
            var movementY = event.movementY || event.mozMovementY;
            if (movementX === void 0 || movementY === void 0) {
              movementX = event.screenX - previousMouseEvent.screenX;
              movementY = event.screenY - previousMouseEvent.screenY;
            }
            this.previousMouseEvent = event;
            yawObject.rotation.y -= movementX * 2e-3;
            pitchObject.rotation.x -= movementY * 2e-3;
            pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
          },
          onMouseDown: function(event) {
            this.mouseDown = true;
            this.previousMouseEvent = event;
            document.body.classList.add("a-grabbing");
          },
          releaseMouse: function() {
            this.mouseDown = false;
            document.body.classList.remove("a-grabbing");
          },
          onTouchStart: function(e2) {
            if (e2.touches.length !== 1) {
              return;
            }
            this.touchStart = {
              x: e2.touches[0].pageX,
              y: e2.touches[0].pageY
            };
            this.touchStarted = true;
          },
          onTouchMove: function(e2) {
            var deltaY;
            var yawObject = this.yawObject;
            if (!this.touchStarted) {
              return;
            }
            deltaY = 2 * Math.PI * (e2.touches[0].pageX - this.touchStart.x) / this.el.sceneEl.canvas.clientWidth;
            yawObject.rotation.y -= deltaY * 0.5;
            this.touchStart = {
              x: e2.touches[0].pageX,
              y: e2.touches[0].pageY
            };
          },
          onTouchEnd: function() {
            this.touchStarted = false;
          }
        });
        function isNullVector(vector) {
          return vector.x === 0 && vector.y === 0 && vector.z === 0;
        }
      }, { "../core/component": 63, "../lib/three": 106, "../utils/": 124, "../utils/bind": 118 }], 30: [function(_dereq_, module3, exports3) {
        var utils = _dereq_("../utils/");
        var component = _dereq_("../core/component");
        var THREE2 = _dereq_("../lib/three");
        var shader = _dereq_("../core/shader");
        var error = utils.debug("components:material:error");
        var registerComponent = component.registerComponent;
        var shaders = shader.shaders;
        var shaderNames = shader.shaderNames;
        module3.exports.Component = registerComponent("material", {
          schema: {
            depthTest: { default: true },
            flatShading: { default: false },
            opacity: { default: 1, min: 0, max: 1 },
            shader: { default: "standard", oneOf: shaderNames },
            side: { default: "front", oneOf: ["front", "back", "double"] },
            transparent: { default: false },
            visible: { default: true }
          },
          init: function() {
            this.material = null;
          },
          /**
           * Update or create material.
           *
           * @param {object|null} oldData
           */
          update: function(oldData) {
            var data = this.data;
            if (!this.shader || data.shader !== oldData.shader) {
              this.updateShader(data.shader);
            }
            this.shader.update(this.data);
            this.updateMaterial();
          },
          updateSchema: function(data) {
            var newShader = data.shader;
            var currentShader = this.data && this.data.shader;
            var shader2 = newShader || currentShader;
            var schema = shaders[shader2] && shaders[shader2].schema;
            if (!schema) {
              error("Unknown shader schema " + shader2);
            }
            if (currentShader && newShader === currentShader) {
              return;
            }
            this.extendSchema(schema);
            this.updateBehavior();
          },
          updateBehavior: function() {
            var schema = this.schema;
            var self2 = this;
            var sceneEl = this.el.sceneEl;
            var tickProperties = {};
            var tick = function(time, delta) {
              var keys2 = Object.keys(tickProperties);
              keys2.forEach(update);
              function update(key) {
                tickProperties[key] = time;
              }
              self2.shader.update(tickProperties);
            };
            var keys = Object.keys(schema);
            this.tick = void 0;
            keys.forEach(function(key) {
              if (schema[key].type === "time") {
                self2.tick = tick;
                tickProperties[key] = true;
              }
            });
            if (!sceneEl) {
              return;
            }
            if (!this.tick) {
              sceneEl.removeBehavior(this);
            } else {
              sceneEl.addBehavior(this);
            }
          },
          updateShader: function(shaderName) {
            var data = this.data;
            var Shader = shaders[shaderName] && shaders[shaderName].Shader;
            var shaderInstance;
            if (!Shader) {
              throw new Error("Unknown shader " + shaderName);
            }
            shaderInstance = this.shader = new Shader();
            shaderInstance.el = this.el;
            shaderInstance.init(data);
            this.setMaterial(shaderInstance.material);
            this.updateSchema(data);
          },
          updateMaterial: function() {
            var data = this.data;
            var material = this.material;
            material.side = parseSide(data.side);
            material.opacity = data.opacity;
            material.transparent = data.transparent !== false || data.opacity < 1;
            material.depthTest = data.depthTest !== false;
            material.shading = data.flatShading ? THREE2.FlatShading : THREE2.SmoothShading;
            material.visible = data.visible;
          },
          /**
           * Remove material on remove (callback).
           * Dispose of it from memory and unsubscribe from scene updates.
           */
          remove: function() {
            var defaultMaterial = new THREE2.MeshBasicMaterial();
            var material = this.material;
            var object3D = this.el.getObject3D("mesh");
            if (object3D) {
              object3D.material = defaultMaterial;
            }
            disposeMaterial(material, this.system);
          },
          /**
           * (Re)create new material. Has side-effects of setting `this.material` and updating
           * material registration in scene.
           *
           * @param {object} data - Material component data.
           * @param {object} type - Material type to create.
           * @returns {object} Material.
           */
          setMaterial: function(material) {
            var mesh = this.el.getOrCreateObject3D("mesh", THREE2.Mesh);
            var system = this.system;
            if (this.material) {
              disposeMaterial(this.material, system);
            }
            this.material = mesh.material = material;
            system.registerMaterial(material);
          }
        });
        function parseSide(side) {
          switch (side) {
            case "back": {
              return THREE2.BackSide;
            }
            case "double": {
              return THREE2.DoubleSide;
            }
            default: {
              return THREE2.FrontSide;
            }
          }
        }
        function disposeMaterial(material, system) {
          material.dispose();
          system.unregisterMaterial(material);
        }
      }, { "../core/component": 63, "../core/shader": 71, "../lib/three": 106, "../utils/": 124 }], 31: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("../utils/debug");
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var warn = debug("components:obj-model:warn");
        module3.exports.Component = registerComponent("obj-model", {
          dependencies: ["material"],
          schema: {
            mtl: { type: "model" },
            obj: { type: "model" }
          },
          init: function() {
            this.model = null;
            this.objLoader = new THREE2.OBJLoader();
            this.mtlLoader = new THREE2.MTLLoader(this.objLoader.manager);
            this.mtlLoader.crossOrigin = "";
          },
          update: function() {
            var data = this.data;
            if (!data.obj) {
              return;
            }
            this.remove();
            this.loadObj(data.obj, data.mtl);
          },
          remove: function() {
            if (!this.model) {
              return;
            }
            this.el.removeObject3D("mesh");
          },
          loadObj: function(objUrl, mtlUrl) {
            var self2 = this;
            var el = this.el;
            var mtlLoader = this.mtlLoader;
            var objLoader = this.objLoader;
            if (mtlUrl) {
              if (el.hasAttribute("material")) {
                warn("Material component properties are ignored when a .MTL is provided");
              }
              mtlLoader.setBaseUrl(mtlUrl.substr(0, mtlUrl.lastIndexOf("/") + 1));
              mtlLoader.load(mtlUrl, function(materials) {
                materials.preload();
                objLoader.setMaterials(materials);
                objLoader.load(objUrl, function(objModel) {
                  self2.model = objModel;
                  el.setObject3D("mesh", objModel);
                  el.emit("model-loaded", { format: "obj", model: objModel });
                });
              });
              return;
            }
            objLoader.load(objUrl, function(objModel) {
              var material = el.components.material;
              if (material) {
                objModel.traverse(function(child) {
                  if (child instanceof THREE2.Mesh) {
                    child.material = material.material;
                  }
                });
              }
              self2.model = objModel;
              el.setObject3D("mesh", objModel);
              el.emit("model-loaded", { format: "obj", model: objModel });
            });
          }
        });
      }, { "../core/component": 63, "../lib/three": 106, "../utils/debug": 120 }], 32: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var bind = _dereq_("../utils/bind");
        var isControllerPresent = _dereq_("../utils/tracked-controls").isControllerPresent;
        var TOUCH_CONTROLLER_MODEL_BASE_URL = "https://cdn.aframe.io/controllers/oculus/oculus-touch-controller-";
        var TOUCH_CONTROLLER_MODEL_OBJ_URL_L = TOUCH_CONTROLLER_MODEL_BASE_URL + "left.obj";
        var TOUCH_CONTROLLER_MODEL_OBJ_MTL_L = TOUCH_CONTROLLER_MODEL_BASE_URL + "left.mtl";
        var TOUCH_CONTROLLER_MODEL_OBJ_URL_R = TOUCH_CONTROLLER_MODEL_BASE_URL + "right.obj";
        var TOUCH_CONTROLLER_MODEL_OBJ_MTL_R = TOUCH_CONTROLLER_MODEL_BASE_URL + "right.mtl";
        var GAMEPAD_ID_PREFIX = "Oculus Touch";
        var PIVOT_OFFSET = { x: 0, y: -0.015, z: 0.04 };
        var EMULATED_TOUCH_THRESHOLD = 1e-3;
        module3.exports.Component = registerComponent("oculus-touch-controls", {
          schema: {
            hand: { default: "left" },
            buttonColor: { default: "#FAFAFA" },
            // Off-white.
            buttonHighlightColor: { default: "#22D1EE" },
            // Light blue.
            model: { default: true },
            rotationOffset: { default: 0 }
            // no default offset; -999 is sentinel value to auto-determine based on hand
          },
          // buttonId
          // 0 - thumbstick
          // 1 - trigger ( intensity value from 0.5 to 1 )
          // 2 - grip
          // 3 - menu ( dispatch but better for menu options )
          // 4 - system ( never dispatched on this layer )
          mapping: {
            "left": {
              axis0: "thumbstick",
              axis1: "thumbstick",
              button0: "thumbstick",
              button1: "trigger",
              button2: "grip",
              button3: "X",
              button4: "Y",
              button5: "surface"
            },
            "right": {
              axis0: "thumbstick",
              axis1: "thumbstick",
              button0: "thumbstick",
              button1: "trigger",
              button2: "grip",
              button3: "A",
              button4: "B",
              button5: "surface"
            }
          },
          bindMethods: function() {
            this.onModelLoaded = bind(this.onModelLoaded, this);
            this.onControllersUpdate = bind(this.onControllersUpdate, this);
            this.checkIfControllerPresent = bind(this.checkIfControllerPresent, this);
            this.removeControllersUpdateListener = bind(this.removeControllersUpdateListener, this);
            this.onGamepadConnected = bind(this.onGamepadConnected, this);
            this.onGamepadDisconnected = bind(this.onGamepadDisconnected, this);
          },
          init: function() {
            var self2 = this;
            this.animationActive = "pointing";
            this.onButtonChanged = bind(this.onButtonChanged, this);
            this.onButtonDown = function(evt) {
              self2.onButtonEvent(evt.detail.id, "down");
            };
            this.onButtonUp = function(evt) {
              self2.onButtonEvent(evt.detail.id, "up");
            };
            this.onButtonTouchStart = function(evt) {
              self2.onButtonEvent(evt.detail.id, "touchstart");
            };
            this.onButtonTouchEnd = function(evt) {
              self2.onButtonEvent(evt.detail.id, "touchend");
            };
            this.controllerPresent = false;
            this.everGotGamepadEvent = false;
            this.lastControllerCheck = 0;
            this.previousButtonValues = {};
            this.bindMethods();
            this.isControllerPresent = isControllerPresent;
          },
          addEventListeners: function() {
            var el = this.el;
            el.addEventListener("buttonchanged", this.onButtonChanged);
            el.addEventListener("buttondown", this.onButtonDown);
            el.addEventListener("buttonup", this.onButtonUp);
            el.addEventListener("touchstart", this.onButtonTouchStart);
            el.addEventListener("touchend", this.onButtonTouchEnd);
            el.addEventListener("model-loaded", this.onModelLoaded);
          },
          removeEventListeners: function() {
            var el = this.el;
            el.removeEventListener("buttonchanged", this.onButtonChanged);
            el.removeEventListener("buttondown", this.onButtonDown);
            el.removeEventListener("buttonup", this.onButtonUp);
            el.removeEventListener("touchstart", this.onButtonTouchStart);
            el.removeEventListener("touchend", this.onButtonTouchEnd);
            el.removeEventListener("model-loaded", this.onModelLoaded);
          },
          checkIfControllerPresent: function() {
            var data = this.data;
            var isPresent = this.isControllerPresent(this.el.sceneEl, GAMEPAD_ID_PREFIX, { hand: data.hand });
            if (isPresent === this.controllerPresent) {
              return;
            }
            this.controllerPresent = isPresent;
            if (isPresent) {
              this.injectTrackedControls();
              this.addEventListeners();
            } else {
              this.removeEventListeners();
            }
          },
          onGamepadConnected: function(evt) {
            this.checkIfControllerPresent();
          },
          onGamepadDisconnected: function(evt) {
            this.checkIfControllerPresent();
          },
          play: function() {
            this.checkIfControllerPresent();
            window.addEventListener("gamepadconnected", this.onGamepadConnected, false);
            window.addEventListener("gamepaddisconnected", this.onGamepadDisconnected, false);
            this.addControllersUpdateListener();
          },
          pause: function() {
            window.removeEventListener("gamepadconnected", this.onGamepadConnected, false);
            window.removeEventListener("gamepaddisconnected", this.onGamepadDisconnected, false);
            this.removeControllersUpdateListener();
            this.removeEventListeners();
          },
          updateControllerModel: function() {
            var objUrl, mtlUrl;
            if (!this.data.model) {
              return;
            }
            if (this.data.hand === "right") {
              objUrl = "url(" + TOUCH_CONTROLLER_MODEL_OBJ_URL_R + ")";
              mtlUrl = "url(" + TOUCH_CONTROLLER_MODEL_OBJ_MTL_R + ")";
            } else {
              objUrl = "url(" + TOUCH_CONTROLLER_MODEL_OBJ_URL_L + ")";
              mtlUrl = "url(" + TOUCH_CONTROLLER_MODEL_OBJ_MTL_L + ")";
            }
            this.el.setAttribute("obj-model", { obj: objUrl, mtl: mtlUrl });
          },
          injectTrackedControls: function() {
            var el = this.el;
            var data = this.data;
            var isRightHand = data.hand === "right";
            el.setAttribute("tracked-controls", {
              id: isRightHand ? "Oculus Touch (Right)" : "Oculus Touch (Left)",
              controller: 0,
              rotationOffset: data.rotationOffset !== -999 ? data.rotationOffset : isRightHand ? -90 : 90
            });
            this.updateControllerModel();
          },
          addControllersUpdateListener: function() {
            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, false);
          },
          removeControllersUpdateListener: function() {
            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, false);
          },
          onControllersUpdate: function() {
            if (!this.everGotGamepadEvent) {
              this.checkIfControllerPresent();
            }
          },
          // currently, browser bugs prevent capacitive touch events from firing on trigger and grip;
          // however those have analog values, and this (below button-down values) can be used to fake them
          isEmulatedTouchEvent: function(analogValue) {
            return analogValue && analogValue >= EMULATED_TOUCH_THRESHOLD;
          },
          onButtonChanged: function(evt) {
            var button = this.mapping[this.data.hand]["button" + evt.detail.id];
            var buttonMeshes = this.buttonMeshes;
            var isPreviousValueEmulatedTouch;
            var analogValue;
            var isEmulatedTouch;
            if (button !== "trigger" && button !== "grip") {
              return;
            }
            analogValue = evt.detail.state.value;
            isPreviousValueEmulatedTouch = this.isEmulatedTouchEvent(this.previousButtonValues[button]);
            this.previousButtonValues[button] = analogValue;
            isEmulatedTouch = this.isEmulatedTouchEvent(analogValue);
            if (isEmulatedTouch !== isPreviousValueEmulatedTouch) {
              (isEmulatedTouch ? this.onButtonTouchStart : this.onButtonTouchEnd)(evt);
            }
            if (button !== "trigger" || !buttonMeshes || !buttonMeshes.trigger) {
              return;
            }
            buttonMeshes.trigger.rotation.x = -analogValue * (Math.PI / 12);
          },
          onModelLoaded: function(evt) {
            var controllerObject3D = evt.detail.model;
            var buttonMeshes;
            if (!this.data.model) {
              return;
            }
            var leftHand = this.data.hand === "left";
            buttonMeshes = this.buttonMeshes = {};
            buttonMeshes.grip = controllerObject3D.getObjectByName(leftHand ? "grip tooche1 group3" : "grip tooche group4");
            buttonMeshes.thumbstick = controllerObject3D.getObjectByName(leftHand ? "tooche1 group3 control_surface group2 thumb_stick" : "tooche group4 control_surface group2 thumb_stick");
            buttonMeshes.trigger = controllerObject3D.getObjectByName(leftHand ? "tooche1 group3 trigger" : "tooche group4 trigger");
            buttonMeshes["X"] = controllerObject3D.getObjectByName("tooche1 group3 control_surface group2 button2");
            buttonMeshes["A"] = controllerObject3D.getObjectByName("tooche group4 control_surface group2 button2");
            buttonMeshes["Y"] = controllerObject3D.getObjectByName("tooche1 group3 control_surface group2 button3");
            buttonMeshes["B"] = controllerObject3D.getObjectByName("tooche group4 control_surface group2 button3");
            buttonMeshes.surface = controllerObject3D.getObjectByName(leftHand ? "tooche1 group3 face control_surface group2" : "tooche group4 face control_surface group2");
            controllerObject3D.position = PIVOT_OFFSET;
          },
          onButtonEvent: function(id, evtName) {
            var buttonName = this.mapping[this.data.hand]["button" + id];
            var i;
            if (Array.isArray(buttonName)) {
              for (i = 0; i < buttonName.length; i++) {
                this.el.emit(buttonName[i] + evtName);
              }
            } else {
              this.el.emit(buttonName + evtName);
            }
            this.updateModel(buttonName, evtName);
          },
          updateModel: function(buttonName, evtName) {
            var i;
            if (Array.isArray(buttonName)) {
              for (i = 0; i < buttonName.length; i++) {
                this.updateButtonModel(buttonName[i], evtName);
              }
            } else {
              this.updateButtonModel(buttonName, evtName);
            }
          },
          updateButtonModel: function(buttonName, state) {
            var color = state === "up" ? this.data.buttonColor : this.data.buttonHighlightColor;
            var buttonMeshes = this.buttonMeshes;
            if (!this.data.model) {
              return;
            }
            if (buttonMeshes && buttonMeshes[buttonName]) {
              buttonMeshes[buttonName].material.color.set(color);
            }
          }
        });
      }, { "../core/component": 63, "../utils/bind": 118, "../utils/tracked-controls": 128 }], 33: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        module3.exports.Component = registerComponent("position", {
          schema: { type: "vec3" },
          update: function() {
            var object3D = this.el.object3D;
            var data = this.data;
            object3D.position.set(data.x, data.y, data.z);
          }
        });
      }, { "../core/component": 63 }], 34: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var bind = _dereq_("../utils/").bind;
        var scaleDummy = new THREE2.Vector3();
        module3.exports.Component = registerComponent("raycaster", {
          schema: {
            far: { default: Infinity },
            // Infinity.
            interval: { default: 100 },
            near: { default: 0 },
            objects: { default: "" },
            recursive: { default: true }
          },
          init: function() {
            this.direction = new THREE2.Vector3();
            this.intersectedEls = [];
            this.objects = null;
            this.prevCheckTime = void 0;
            this.raycaster = new THREE2.Raycaster();
            this.updateOriginDirection();
            this.refreshObjects = bind(this.refreshObjects, this);
          },
          play: function() {
            this.el.sceneEl.addEventListener("child-attached", this.refreshObjects);
            this.el.sceneEl.addEventListener("child-detached", this.refreshObjects);
          },
          pause: function() {
            this.el.sceneEl.removeEventListener("child-attached", this.refreshObjects);
            this.el.sceneEl.removeEventListener("child-detached", this.refreshObjects);
          },
          /**
           * Create or update raycaster object.
           */
          update: function() {
            var data = this.data;
            var raycaster = this.raycaster;
            raycaster.far = data.far;
            raycaster.near = data.near;
            this.refreshObjects();
          },
          /**
           * Update list of objects to test for intersection.
           */
          refreshObjects: function() {
            var data = this.data;
            var i;
            var objectEls;
            if (data.objects) {
              objectEls = this.el.sceneEl.querySelectorAll(data.objects);
              this.objects = [];
              for (i = 0; i < objectEls.length; i++) {
                this.objects.push(objectEls[i].object3D);
              }
              return;
            }
            this.objects = this.el.sceneEl.object3D.children;
          },
          /**
           * Check for intersections and cleared intersections on an interval.
           */
          tick: function(time) {
            var el = this.el;
            var data = this.data;
            var intersectedEls;
            var intersections;
            var prevCheckTime = this.prevCheckTime;
            var prevIntersectedEls;
            if (prevCheckTime && time - prevCheckTime < data.interval) {
              return;
            }
            prevIntersectedEls = this.intersectedEls.slice();
            this.updateOriginDirection();
            intersections = this.raycaster.intersectObjects(this.objects, data.recursive);
            intersections = intersections.filter(function hasEl(intersection) {
              return !!intersection.object.el;
            });
            intersectedEls = this.intersectedEls = intersections.map(function getEl(intersection) {
              return intersection.object.el;
            });
            intersections.forEach(function emitEvents(intersection) {
              var intersectedEl = intersection.object.el;
              intersectedEl.emit("raycaster-intersected", { el, intersection });
            });
            if (intersections.length) {
              el.emit("raycaster-intersection", {
                els: intersectedEls.slice(),
                intersections
              });
            }
            prevIntersectedEls.forEach(function checkStillIntersected(intersectedEl) {
              if (intersectedEls.indexOf(intersectedEl) !== -1) {
                return;
              }
              el.emit("raycaster-intersection-cleared", { el: intersectedEl });
              intersectedEl.emit("raycaster-intersected-cleared", { el });
            });
          },
          /**
           * Set origin and direction of raycaster using entity position and rotation.
           */
          updateOriginDirection: function() {
            var directionHelper = new THREE2.Quaternion();
            var originVec3 = new THREE2.Vector3();
            return function updateOriginDirection() {
              var el = this.el;
              var object3D = el.object3D;
              object3D.updateMatrixWorld();
              object3D.matrixWorld.decompose(originVec3, directionHelper, scaleDummy);
              this.direction.set(0, 0, -1);
              this.direction.applyQuaternion(directionHelper);
              this.raycaster.set(originVec3, this.direction);
            };
          }()
        });
      }, { "../core/component": 63, "../lib/three": 106, "../utils/": 124 }], 35: [function(_dereq_, module3, exports3) {
        var degToRad = _dereq_("../lib/three").Math.degToRad;
        var registerComponent = _dereq_("../core/component").registerComponent;
        module3.exports.Component = registerComponent("rotation", {
          schema: { type: "vec3" },
          /**
           * Updates object3D rotation.
           */
          update: function() {
            var data = this.data;
            var object3D = this.el.object3D;
            object3D.rotation.set(degToRad(data.x), degToRad(data.y), degToRad(data.z));
            object3D.rotation.order = "YXZ";
          }
        });
      }, { "../core/component": 63, "../lib/three": 106 }], 36: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var zeroScale = 1e-5;
        module3.exports.Component = registerComponent("scale", {
          schema: {
            type: "vec3",
            default: { x: 1, y: 1, z: 1 }
          },
          update: function() {
            var data = this.data;
            var object3D = this.el.object3D;
            var x = data.x === 0 ? zeroScale : data.x;
            var y = data.y === 0 ? zeroScale : data.y;
            var z = data.z === 0 ? zeroScale : data.z;
            object3D.scale.set(x, y, z);
          }
        });
      }, { "../core/component": 63 }], 37: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var utils = _dereq_("../../utils");
        module3.exports.Component = registerComponent("auto-enter-vr", {
          schema: {
            display: { type: "string", default: "GearVR" },
            enabled: { type: "boolean", default: true }
          },
          init: function() {
            var scene = this.el;
            var self2 = this;
            this.enterVR = scene.enterVR.bind(scene);
            this.exitVR = scene.exitVR.bind(scene);
            this.shouldAutoEnterVR = this.shouldAutoEnterVR.bind(this);
            if (utils.getUrlParameter("auto-enter-vr") === "false") {
              return;
            }
            window.addEventListener("vrdisplayactivate", function() {
              self2.enterVR();
            }, false);
            window.addEventListener("vrdisplaydeactivate", function() {
              self2.exitVR();
            }, false);
            setTimeout(function() {
              if (self2.shouldAutoEnterVR()) {
                self2.enterVR();
              }
            }, 0);
          },
          update: function() {
            return this.shouldAutoEnterVR() ? this.enterVR() : this.exitVR();
          },
          shouldAutoEnterVR: function() {
            var scene = this.el;
            var data = this.data;
            if (!data.enabled) {
              return false;
            }
            if (data.display) {
              var display = scene.effect && scene.effect.getVRDisplay && scene.effect.getVRDisplay();
              if (!display || !display.displayName || display.displayName.indexOf(data.display) < 0) {
                return false;
              }
            }
            return true;
          }
        });
      }, { "../../core/component": 63, "../../utils": 124 }], 38: [function(_dereq_, module3, exports3) {
        var bind = _dereq_("../../utils/bind");
        var register = _dereq_("../../core/component").registerComponent;
        module3.exports.Component = register("canvas", {
          init: function() {
            var sceneEl = this.el;
            var canvasEl = document.createElement("canvas");
            canvasEl.classList.add("a-canvas");
            canvasEl.dataset.aframeCanvas = true;
            sceneEl.appendChild(canvasEl);
            document.addEventListener("fullscreenchange", onFullScreenChange);
            document.addEventListener("mozfullscreenchange", onFullScreenChange);
            document.addEventListener("webkitfullscreenchange", onFullScreenChange);
            canvasEl.addEventListener("touchmove", function(event) {
              event.preventDefault();
            });
            sceneEl.addEventListener("enter-vr", addFullscreenClass);
            sceneEl.addEventListener("exit-vr", removeFullscreenClass);
            sceneEl.canvas = canvasEl;
            sceneEl.emit("render-target-loaded", {
              target: canvasEl
            });
            function addFullscreenClass(event) {
              canvasEl.classList.add("fullscreen");
            }
            function removeFullscreenClass(event) {
              canvasEl.classList.remove("fullscreen");
            }
            function onFullScreenChange() {
              var fullscreenEl = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
              if (!fullscreenEl) {
                sceneEl.exitVR();
              }
              document.activeElement.blur();
              document.body.focus();
              setTimeout(bind(sceneEl.resize, sceneEl), 0);
            }
          }
        });
      }, { "../../core/component": 63, "../../utils/bind": 118 }], 39: [function(_dereq_, module3, exports3) {
        var register = _dereq_("../../core/component").registerComponent;
        module3.exports.Component = register("debug", {
          schema: { default: true }
        });
      }, { "../../core/component": 63 }], 40: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        module3.exports.Component = registerComponent("embedded", {
          dependencies: ["vr-mode-ui"],
          schema: { default: true },
          update: function() {
            var sceneEl = this.el;
            var enterVREl = sceneEl.querySelector(".a-enter-vr");
            if (this.data === true) {
              enterVREl.classList.add("embedded");
              sceneEl.removeFullScreenStyles();
            } else {
              enterVREl.classList.remove("embedded");
              sceneEl.addFullScreenStyles();
            }
          }
        });
      }, { "../../core/component": 63 }], 41: [function(_dereq_, module3, exports3) {
        var register = _dereq_("../../core/component").registerComponent;
        var THREE2 = _dereq_("../../lib/three");
        var debug = _dereq_("../../utils/debug");
        var warn = debug("components:fog:warn");
        module3.exports.Component = register("fog", {
          schema: {
            color: { default: "#000" },
            density: { default: 25e-5 },
            far: { default: 1e3, min: 0 },
            near: { default: 1, min: 0 },
            type: { default: "linear", oneOf: ["linear", "exponential"] }
          },
          update: function() {
            var data = this.data;
            var el = this.el;
            var fog = this.el.object3D.fog;
            if (!el.isScene) {
              warn("Fog component can only be applied to <a-scene>");
              return;
            }
            if (!fog || data.type !== fog.name) {
              el.object3D.fog = getFog(data);
              el.systems.material.updateMaterials();
              return;
            }
            Object.keys(this.schema).forEach(function(key) {
              var value = data[key];
              if (key === "color") {
                value = new THREE2.Color(value);
              }
              fog[key] = value;
            });
          },
          /**
           * Remove fog on remove (callback).
           */
          remove: function() {
            var fog = this.el.object3D.fog;
            if (fog) {
              fog.density = 0;
              fog.far = 0;
              fog.near = 0;
            }
          }
        });
        function getFog(data) {
          var fog;
          if (data.type === "exponential") {
            fog = new THREE2.FogExp2(data.color, data.density);
          } else {
            fog = new THREE2.Fog(data.color, data.near, data.far);
          }
          fog.name = data.type;
          return fog;
        }
      }, { "../../core/component": 63, "../../lib/three": 106, "../../utils/debug": 120 }], 42: [function(_dereq_, module3, exports3) {
        var AFRAME_INJECTED = _dereq_("../../constants").AFRAME_INJECTED;
        var bind = _dereq_("../../utils/bind");
        var pkg = _dereq_("../../../package");
        var registerComponent = _dereq_("../../core/component").registerComponent;
        function getFuzzyPatchVersion(version) {
          var split = version.split(".");
          split[2] = "x";
          return split.join(".");
        }
        var INSPECTOR_DEV_URL = "https://aframe.io/aframe-inspector/dist/aframe-inspector.js";
        var INSPECTOR_RELEASE_URL = "https://unpkg.com/aframe-inspector@" + getFuzzyPatchVersion(pkg.version) + "/dist/aframe-inspector.min.js";
        var INSPECTOR_URL = true ? INSPECTOR_DEV_URL : INSPECTOR_RELEASE_URL;
        var LOADING_MESSAGE = "Loading Inspector";
        module3.exports.Component = registerComponent("inspector", {
          schema: {
            url: { default: INSPECTOR_URL }
          },
          init: function() {
            this.onKeydown = bind(this.onKeydown, this);
            this.onMessage = bind(this.onMessage, this);
            this.initOverlay();
            window.addEventListener("keydown", this.onKeydown);
            window.addEventListener("message", this.onMessage);
          },
          initOverlay: function() {
            var dotsHTML = '<span class="dots"><span>.</span><span>.</span><span>.</span></span>';
            this.loadingMessageEl = document.createElement("div");
            this.loadingMessageEl.classList.add("a-inspector-loader");
            this.loadingMessageEl.innerHTML = LOADING_MESSAGE + dotsHTML;
          },
          remove: function() {
            this.removeEventListeners();
          },
          /**
           * <ctrl> + <alt> + i keyboard shortcut.
           */
          onKeydown: function(evt) {
            var shortcutPressed = evt.keyCode === 73 && evt.ctrlKey && evt.altKey;
            if (!this.data || !shortcutPressed) {
              return;
            }
            this.injectInspector();
          },
          showLoader: function() {
            document.body.appendChild(this.loadingMessageEl);
          },
          hideLoader: function() {
            this.el.removeChild(this.loadingMessageEl);
          },
          /**
           * postMessage. aframe.io uses this to create a button on examples to open Inspector.
           */
          onMessage: function(evt) {
            if (evt.data === "INJECT_AFRAME_INSPECTOR") {
              this.injectInspector();
            }
          },
          injectInspector: function() {
            var self2 = this;
            var script;
            if (AFRAME.INSPECTOR || AFRAME.inspectorInjected) {
              return;
            }
            this.showLoader();
            script = document.createElement("script");
            script.src = this.data.url;
            script.setAttribute("data-name", "aframe-inspector");
            script.setAttribute(AFRAME_INJECTED, "");
            script.onload = function() {
              AFRAME.INSPECTOR.open();
              self2.hideLoader();
              self2.removeEventListeners();
            };
            document.head.appendChild(script);
            AFRAME.inspectorInjected = true;
          },
          removeEventListeners: function() {
            window.removeEventListener("keydown", this.onKeydown);
            window.removeEventListener("message", this.onMessage);
          }
        });
      }, { "../../../package": 20, "../../constants": 54, "../../core/component": 63, "../../utils/bind": 118 }], 43: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var shouldCaptureKeyEvent = _dereq_("../../utils/").shouldCaptureKeyEvent;
        var THREE2 = _dereq_("../../lib/three");
        var controls = new THREE2.VRControls(new THREE2.Object3D());
        module3.exports.Component = registerComponent("keyboard-shortcuts", {
          schema: {
            enterVR: { default: true },
            exitVR: { default: true },
            resetSensor: { default: true }
          },
          init: function() {
            var self2 = this;
            var scene = this.el;
            this.listener = window.addEventListener("keyup", function(event) {
              if (!shouldCaptureKeyEvent(event)) {
                return;
              }
              if (self2.enterVREnabled && event.keyCode === 70) {
                scene.enterVR();
              }
              if (self2.enterVREnabled && event.keyCode === 27) {
                scene.exitVR();
              }
              if (self2.resetSensorEnabled && event.keyCode === 90) {
                controls.resetSensor();
              }
            }, false);
          },
          update: function(oldData) {
            var data = this.data;
            this.enterVREnabled = data.enterVR;
            this.resetSensorEnabled = data.resetSensor;
          },
          remove: function() {
            window.removeEventListener("keyup", this.listener);
          }
        });
      }, { "../../core/component": 63, "../../lib/three": 106, "../../utils/": 124 }], 44: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("../../utils/debug");
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var warn = debug("components:pool:warn");
        module3.exports.Component = registerComponent("pool", {
          schema: {
            mixin: { default: "" },
            size: { default: 0 },
            dynamic: { default: false }
          },
          multiple: true,
          init: function() {
            this.initPool();
          },
          initPool: function() {
            var i;
            var mixin = this.data.mixin;
            if (!mixin) {
              return;
            }
            this.availableEls = [];
            this.usedEls = [];
            for (i = 0; i < this.data.size; ++i) {
              this.createEntity();
            }
          },
          update: function(oldData) {
            var data = this.data;
            if (oldData.mixin !== data.mixin || oldData.size !== data.size) {
              this.initPool();
            }
          },
          /**
           * Add a new entity to the list of available entities.
           */
          createEntity: function() {
            var el = document.createElement("a-entity");
            el.play = this.wrapPlay(el.play);
            el.setAttribute("mixin", this.data.mixin);
            el.setAttribute("visible", false);
            this.el.appendChild(el);
            this.availableEls.push(el);
          },
          /**
           * Play wrapper for pooled entities. When pausing and playing
           * a scene we don't want to play the entities that are not in use
           */
          wrapPlay: function(playMethod) {
            var usedEls = this.usedEls;
            return function() {
              if (usedEls.indexOf(this) === -1) {
                return;
              }
              playMethod.call(this);
            };
          },
          /**
           * Used to request one of the available entities of the pool
           */
          requestEntity: function() {
            var el;
            if (this.availableEls.length === 0) {
              if (this.data.dynamic === false) {
                warn("Requested entity from empty pool " + this.name);
                return;
              } else {
                warn("Requested entity from empty pool. This pool is dynamicand will resize automatically. You might want to increase its initial size" + this.name);
              }
              this.createEntity();
            }
            el = this.availableEls.shift();
            this.usedEls.push(el);
            el.setAttribute("visible", true);
            return el;
          },
          /**
           * Used to return a used entity to the pool
           */
          returnEntity: function(el) {
            var index = this.usedEls.indexOf(el);
            if (index === -1) {
              warn("The returned entity was not previously pooled from " + this.name);
              return;
            }
            this.usedEls.splice(index, 1);
            this.availableEls.push(el);
            el.setAttribute("visible", false);
            el.pause();
          }
        });
      }, { "../../core/component": 63, "../../utils/debug": 120 }], 45: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var THREE2 = _dereq_("../../lib/three");
        var VERTEX_SHADER = [
          "attribute vec3 position;",
          "attribute vec2 uv;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 modelViewMatrix;",
          "varying vec2 vUv;",
          "void main()  {",
          "  vUv = vec2( 1.- uv.x, uv.y );",
          "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}"
        ].join("\n");
        var FRAGMENT_SHADER = [
          "precision mediump float;",
          "uniform samplerCube map;",
          "varying vec2 vUv;",
          "#define M_PI 3.141592653589793238462643383279",
          "void main() {",
          "  vec2 uv = vUv;",
          "  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;",
          "  float latitude = uv.y * M_PI;",
          "  vec3 dir = vec3(",
          "    - sin( longitude ) * sin( latitude ),",
          "    cos( latitude ),",
          "    - cos( longitude ) * sin( latitude )",
          "  );",
          "  normalize( dir );",
          "  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );",
          "}"
        ].join("\n");
        module3.exports.Component = registerComponent("screenshot", {
          schema: {
            width: { default: 4096 },
            height: { default: 2048 }
          },
          init: function() {
            var el = this.el;
            var self2 = this;
            if (el.renderer) {
              setup();
            } else {
              el.addEventListener("render-target-loaded", setup);
            }
            function setup() {
              var gl = el.renderer.getContext();
              self2.cubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
              self2.material = new THREE2.RawShaderMaterial({
                uniforms: { map: { type: "t", value: null } },
                vertexShader: VERTEX_SHADER,
                fragmentShader: FRAGMENT_SHADER,
                side: THREE2.DoubleSide
              });
              self2.quad = new THREE2.Mesh(
                new THREE2.PlaneBufferGeometry(1, 1),
                self2.material
              );
              self2.quad.visible = false;
              self2.camera = new THREE2.OrthographicCamera(1 / -2, 1 / 2, 1 / 2, 1 / -2, -1e4, 1e4);
              self2.canvas = document.createElement("canvas");
              self2.ctx = self2.canvas.getContext("2d");
              if (el.camera) {
                el.camera.add(self2.quad);
              }
              self2.onKeyDown = self2.onKeyDown.bind(self2);
              self2.onCameraActive = self2.onCameraActive.bind(self2);
              el.addEventListener("camera-set-active", self2.onCameraActive);
            }
          },
          getRenderTarget: function(width, height) {
            return new THREE2.WebGLRenderTarget(width, height, {
              minFilter: THREE2.LinearFilter,
              magFilter: THREE2.LinearFilter,
              wrapS: THREE2.ClampToEdgeWrapping,
              wrapT: THREE2.ClampToEdgeWrapping,
              format: THREE2.RGBAFormat,
              type: THREE2.UnsignedByteType
            });
          },
          resize: function(width, height) {
            this.quad.scale.set(width, height, 1);
            this.camera.left = width / -2;
            this.camera.right = width / 2;
            this.camera.top = height / 2;
            this.camera.bottom = height / -2;
            this.camera.updateProjectionMatrix();
            this.canvas.width = width;
            this.canvas.height = height;
          },
          play: function() {
            window.addEventListener("keydown", this.onKeyDown);
          },
          onCameraActive: function(evt) {
            var cameraParent = this.quad.parent;
            if (cameraParent) {
              cameraParent.remove(this.quad);
            }
            evt.detail.cameraEl.getObject3D("camera").add(this.quad);
          },
          /**
           * <ctrl> + <alt> + s = regular screenshot
           * <ctrl> + <alt> + <shift> + s = equirectangular screenshot
           */
          onKeyDown: function(evt) {
            var shortcutPressed = evt.keyCode === 83 && evt.ctrlKey && evt.altKey;
            if (!this.data || !shortcutPressed) {
              return;
            }
            var projection = evt.shiftKey ? "equirectangular" : "perspective";
            this.capture(projection);
          },
          /**
           * Captures a screenshot of the scene
           *
           * @param {string} projection - Screenshot projection (equirectangular | perspective)
           */
          capture: function(projection) {
            var el = this.el;
            var renderer = el.renderer;
            var size;
            var camera;
            var cubeCamera;
            if (projection === "perspective") {
              this.quad.visible = false;
              camera = el.camera;
              size = renderer.getSize();
            } else {
              camera = this.camera;
              camera.position.copy(el.camera.getWorldPosition());
              camera.rotation.copy(el.camera.getWorldRotation());
              cubeCamera = new THREE2.CubeCamera(el.camera.near, el.camera.far, Math.min(this.cubeMapSize, 2048));
              cubeCamera.position.copy(el.camera.getWorldPosition());
              cubeCamera.rotation.copy(el.camera.getWorldRotation());
              cubeCamera.updateCubeMap(el.renderer, el.object3D);
              this.quad.material.uniforms.map.value = cubeCamera.renderTarget.texture;
              size = { width: this.data.width, height: this.data.height };
              this.quad.visible = true;
            }
            this.renderCapture(camera, size, projection);
            this.saveCapture();
          },
          renderCapture: function(camera, size, projection) {
            var autoClear = this.el.renderer.autoClear;
            var el = this.el;
            var imageData;
            var output;
            var pixels;
            var renderer = this.el.renderer;
            output = this.getRenderTarget(size.width, size.height);
            pixels = new Uint8Array(4 * size.width * size.height);
            this.resize(size.width, size.height);
            renderer.autoClear = true;
            renderer.render(el.object3D, camera, output, true);
            renderer.autoClear = autoClear;
            renderer.readRenderTargetPixels(output, 0, 0, size.width, size.height, pixels);
            if (projection === "perspective") {
              pixels = this.flipPixelsVertically(pixels, size.width, size.height);
            }
            imageData = new ImageData(new Uint8ClampedArray(pixels), size.width, size.height);
            this.quad.visible = false;
            this.ctx.putImageData(imageData, 0, 0);
          },
          flipPixelsVertically: function(pixels, width, height) {
            var flippedPixels = pixels.slice(0);
            for (var x = 0; x < width; ++x) {
              for (var y = 0; y < height; ++y) {
                flippedPixels[x * 4 + y * width * 4] = pixels[x * 4 + (height - y) * width * 4];
                flippedPixels[x * 4 + 1 + y * width * 4] = pixels[x * 4 + 1 + (height - y) * width * 4];
                flippedPixels[x * 4 + 2 + y * width * 4] = pixels[x * 4 + 2 + (height - y) * width * 4];
                flippedPixels[x * 4 + 3 + y * width * 4] = pixels[x * 4 + 3 + (height - y) * width * 4];
              }
            }
            return flippedPixels;
          },
          saveCapture: function() {
            this.canvas.toBlob(function(blob) {
              var url = URL.createObjectURL(blob);
              var fileName = "screenshot-" + document.title + "-" + Date.now() + ".png";
              var aEl = document.createElement("a");
              aEl.href = url;
              aEl.setAttribute("download", fileName);
              aEl.innerHTML = "downloading...";
              aEl.style.display = "none";
              document.body.appendChild(aEl);
              setTimeout(function() {
                aEl.click();
                document.body.removeChild(aEl);
              }, 1);
            }, "image/png");
          }
        });
      }, { "../../core/component": 63, "../../lib/three": 106 }], 46: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var RStats = _dereq_("../../../vendor/rStats");
        var utils = _dereq_("../../utils");
        _dereq_("../../../vendor/rStats.extras");
        _dereq_("../../lib/rStatsAframe");
        var AFrameStats = window.aframeStats;
        var bind = utils.bind;
        var HIDDEN_CLASS = "a-hidden";
        var ThreeStats = window.threeStats;
        module3.exports.Component = registerComponent("stats", {
          schema: { default: true },
          init: function() {
            var scene = this.el;
            if (utils.getUrlParameter("stats") === "false") {
              return;
            }
            this.stats = createStats(scene);
            this.statsEl = document.querySelector(".rs-base");
            this.hideBound = bind(this.hide, this);
            this.showBound = bind(this.show, this);
            scene.addEventListener("enter-vr", this.hideBound);
            scene.addEventListener("exit-vr", this.showBound);
          },
          update: function() {
            if (!this.stats) {
              return;
            }
            return !this.data ? this.hide() : this.show();
          },
          remove: function() {
            this.el.removeEventListener("enter-vr", this.hideBound);
            this.el.removeEventListener("exit-vr", this.showBound);
            this.statsEl.parentNode.removeChild(this.statsEl);
          },
          tick: function() {
            var stats = this.stats;
            if (!stats) {
              return;
            }
            stats("rAF").tick();
            stats("FPS").frame();
            stats().update();
          },
          hide: function() {
            this.statsEl.classList.add(HIDDEN_CLASS);
          },
          show: function() {
            this.statsEl.classList.remove(HIDDEN_CLASS);
          }
        });
        function createStats(scene) {
          var threeStats = new ThreeStats(scene.renderer);
          var aframeStats = new AFrameStats(scene);
          var plugins = scene.isMobile ? [] : [threeStats, aframeStats];
          return new RStats({
            css: [],
            // Our stylesheet is injected from `src/index.js`.
            values: {
              fps: { caption: "fps", below: 30 }
            },
            groups: [
              { caption: "Framerate", values: ["fps", "raf"] }
            ],
            plugins
          });
        }
      }, { "../../../vendor/rStats": 132, "../../../vendor/rStats.extras": 131, "../../core/component": 63, "../../lib/rStatsAframe": 105, "../../utils": 124 }], 47: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var constants = _dereq_("../../constants/");
        var utils = _dereq_("../../utils/");
        var bind = utils.bind;
        var ENTER_VR_CLASS = "a-enter-vr";
        var ENTER_VR_BTN_CLASS = "a-enter-vr-button";
        var HIDDEN_CLASS = "a-hidden";
        var ORIENTATION_MODAL_CLASS = "a-orientation-modal";
        module3.exports.Component = registerComponent("vr-mode-ui", {
          dependencies: ["canvas"],
          schema: {
            enabled: { default: true }
          },
          init: function() {
            var self2 = this;
            var sceneEl = this.el;
            if (utils.getUrlParameter("ui") === "false") {
              return;
            }
            this.enterVR = bind(sceneEl.enterVR, sceneEl);
            this.exitVR = bind(sceneEl.exitVR, sceneEl);
            this.insideLoader = false;
            this.enterVREl = null;
            this.orientationModalEl = null;
            sceneEl.addEventListener("enter-vr", bind(this.updateEnterVRInterface, this));
            sceneEl.addEventListener("exit-vr", bind(this.updateEnterVRInterface, this));
            window.addEventListener("message", function(event) {
              if (event.data.type === "loaderReady") {
                self2.insideLoader = true;
                self2.remove();
              }
            });
            window.addEventListener("orientationchange", bind(this.toggleOrientationModalIfNeeded, this));
          },
          update: function() {
            var sceneEl = this.el;
            if (!this.data.enabled || this.insideLoader || utils.getUrlParameter("ui") === "false") {
              return this.remove();
            }
            if (this.enterVREl || this.orientationModalEl) {
              return;
            }
            this.enterVREl = createEnterVRButton(this.enterVR);
            sceneEl.appendChild(this.enterVREl);
            this.orientationModalEl = createOrientationModal(this.exitVR);
            sceneEl.appendChild(this.orientationModalEl);
            this.updateEnterVRInterface();
          },
          remove: function() {
            [this.enterVREl, this.orientationModalEl].forEach(function(uiElement) {
              if (uiElement) {
                uiElement.parentNode.removeChild(uiElement);
              }
            });
          },
          updateEnterVRInterface: function() {
            this.toggleEnterVRButtonIfNeeded();
            this.toggleOrientationModalIfNeeded();
          },
          toggleEnterVRButtonIfNeeded: function() {
            var sceneEl = this.el;
            if (!this.enterVREl) {
              return;
            }
            if (sceneEl.is("vr-mode")) {
              this.enterVREl.classList.add(HIDDEN_CLASS);
            } else {
              this.enterVREl.classList.remove(HIDDEN_CLASS);
            }
          },
          toggleOrientationModalIfNeeded: function() {
            var sceneEl = this.el;
            var orientationModalEl = this.orientationModalEl;
            if (!orientationModalEl || !sceneEl.isMobile) {
              return;
            }
            if (!utils.device.isLandscape() && sceneEl.is("vr-mode")) {
              orientationModalEl.classList.remove(HIDDEN_CLASS);
            } else {
              orientationModalEl.classList.add(HIDDEN_CLASS);
            }
          }
        });
        function createEnterVRButton(enterVRHandler) {
          var vrButton;
          var wrapper;
          wrapper = document.createElement("div");
          wrapper.classList.add(ENTER_VR_CLASS);
          wrapper.setAttribute(constants.AFRAME_INJECTED, "");
          vrButton = document.createElement("button");
          vrButton.className = ENTER_VR_BTN_CLASS;
          vrButton.setAttribute(constants.AFRAME_INJECTED, "");
          wrapper.appendChild(vrButton);
          vrButton.addEventListener("click", enterVRHandler);
          return wrapper;
        }
        function createOrientationModal(exitVRHandler) {
          var modal = document.createElement("div");
          modal.className = ORIENTATION_MODAL_CLASS;
          modal.classList.add(HIDDEN_CLASS);
          modal.setAttribute(constants.AFRAME_INJECTED, "");
          var exit = document.createElement("button");
          exit.setAttribute(constants.AFRAME_INJECTED, "");
          exit.innerHTML = "Exit VR";
          exit.addEventListener("click", exitVRHandler);
          modal.appendChild(exit);
          return modal;
        }
      }, { "../../constants/": 54, "../../core/component": 63, "../../utils/": 124 }], 48: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var debug = _dereq_("../utils/debug");
        var bind = _dereq_("../utils/bind");
        var THREE2 = _dereq_("../lib/three");
        var warn = debug("components:sound:warn");
        module3.exports.Component = registerComponent("sound", {
          schema: {
            autoplay: { default: false },
            loop: { default: false },
            on: { default: "" },
            poolSize: { default: 1 },
            src: { type: "audio" },
            volume: { default: 1 }
          },
          multiple: true,
          init: function() {
            this.listener = null;
            this.audioLoader = new THREE2.AudioLoader();
            this.pool = new THREE2.Group();
            this.playSound = bind(this.playSound, this);
          },
          update: function(oldData) {
            var data = this.data;
            var srcChanged = data.src !== oldData.src;
            if (srcChanged) {
              if (!data.src) {
                warn("Audio source was not specified with `src`");
                return;
              }
              this.setupSound();
            }
            this.pool.children.forEach(function(sound) {
              sound.autoplay = data.autoplay;
              sound.setLoop(data.loop);
              sound.setVolume(data.volume);
            });
            if (data.on !== oldData.on) {
              this.updateEventListener(oldData.on);
            }
            if (srcChanged) {
              var self2 = this;
              this.audioLoader.load(data.src, function(buffer) {
                self2.pool.children.forEach(function(sound) {
                  sound.setBuffer(buffer);
                });
                THREE2.Cache.remove(data.src);
              });
            }
          },
          pause: function() {
            this.pauseSound();
            this.removeEventListener();
          },
          play: function() {
            if (this.data.autoplay) {
              this.playSound();
            }
            this.updateEventListener();
          },
          remove: function() {
            this.removeEventListener();
            this.el.removeObject3D(this.attrName);
            try {
              this.pool.children.forEach(function(sound) {
                sound.disconnect();
              });
            } catch (e2) {
              warn("Audio source not properly disconnected");
            }
          },
          /**
          *  Update listener attached to the user defined on event.
          */
          updateEventListener: function(oldEvt) {
            var el = this.el;
            if (oldEvt) {
              el.removeEventListener(oldEvt, this.playSound);
            }
            el.addEventListener(this.data.on, this.playSound);
          },
          removeEventListener: function() {
            this.el.removeEventListener(this.data.on, this.playSound);
          },
          /**
           * Removes current sound object, creates new sound object, adds to entity.
           *
           * @returns {object} sound
           */
          setupSound: function() {
            var el = this.el;
            var sceneEl = el.sceneEl;
            if (this.pool.children.length > 0) {
              this.stopSound();
              el.removeObject3D("sound");
            }
            var listener = this.listener = sceneEl.audioListener || new THREE2.AudioListener();
            sceneEl.audioListener = listener;
            if (sceneEl.camera) {
              sceneEl.camera.add(listener);
            }
            sceneEl.addEventListener("camera-set-active", function(evt) {
              evt.detail.cameraEl.getObject3D("camera").add(listener);
            });
            this.pool = new THREE2.Group();
            for (var i = 0; i < this.data.poolSize; i++) {
              var sound = new THREE2.PositionalAudio(listener);
              this.pool.add(sound);
            }
            el.setObject3D(this.attrName, this.pool);
            this.pool.children.forEach(function(sound2) {
              sound2.source.onended = function() {
                sound2.onEnded();
                el.emit("sound-ended", { index: i });
              };
            });
          },
          /**
           * Pause all the sounds in the pool.
           */
          pauseSound: function() {
            this.pool.children.forEach(function(sound) {
              if (!sound.source.buffer || !sound.isPlaying || !sound.pause) {
                return;
              }
              sound.pause();
            });
          },
          /**
           * Look for an unused sound in the pool and play it if found.
           */
          playSound: function() {
            var found = false;
            this.pool.children.forEach(function(sound) {
              if (!sound.isPlaying && sound.source.buffer && !found) {
                sound.play();
                found = true;
                return;
              }
            });
            if (!found) {
              warn("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.");
            }
          },
          /**
           * Stop all the sounds in the pool.
           */
          stopSound: function() {
            this.pool.children.forEach(function(sound) {
              if (!sound.source.buffer) {
                return;
              }
              sound.stop();
            });
          }
        });
      }, { "../core/component": 63, "../lib/three": 106, "../utils/bind": 118, "../utils/debug": 120 }], 49: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        module3.exports.Component = registerComponent("tracked-controls", {
          schema: {
            controller: { default: 0 },
            id: { default: "Match none by default!" },
            rotationOffset: { default: 0 }
          },
          init: function() {
            this.buttonStates = {};
            this.previousAxis = [];
            this.previousControllerPosition = new THREE2.Vector3();
          },
          update: function() {
            var controllers = this.system.controllers;
            var data = this.data;
            controllers = controllers.filter(hasId);
            this.controller = controllers[data.controller];
            function hasId(controller) {
              return controller.id === data.id;
            }
          },
          tick: function(time, delta) {
            var mesh = this.el.getObject3D("mesh");
            if (mesh && mesh.update) {
              mesh.update(delta / 1e3);
            }
            this.updatePose();
            this.updateButtons();
          },
          updatePose: function() {
            var controllerEuler = new THREE2.Euler();
            var controllerPosition = new THREE2.Vector3();
            var controllerQuaternion = new THREE2.Quaternion();
            var deltaControllerPosition = new THREE2.Vector3();
            var dolly = new THREE2.Object3D();
            var standingMatrix = new THREE2.Matrix4();
            controllerEuler.order = "YXZ";
            return function() {
              var controller;
              var pose;
              var orientation;
              var position;
              var el = this.el;
              var vrDisplay = this.system.vrDisplay;
              this.update();
              controller = this.controller;
              if (!controller) {
                return;
              }
              pose = controller.pose;
              orientation = pose.orientation || [0, 0, 0, 1];
              position = pose.position || [0, 0, 0];
              controllerQuaternion.fromArray(orientation);
              dolly.quaternion.fromArray(orientation);
              dolly.position.fromArray(position);
              dolly.updateMatrix();
              if (vrDisplay && vrDisplay.stageParameters) {
                standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
                dolly.applyMatrix(standingMatrix);
              }
              controllerEuler.setFromRotationMatrix(dolly.matrix);
              controllerPosition.setFromMatrixPosition(dolly.matrix);
              el.setAttribute("rotation", {
                x: THREE2.Math.radToDeg(controllerEuler.x),
                y: THREE2.Math.radToDeg(controllerEuler.y),
                z: THREE2.Math.radToDeg(controllerEuler.z) + this.data.rotationOffset
              });
              deltaControllerPosition.copy(controllerPosition).sub(this.previousControllerPosition);
              this.previousControllerPosition.copy(controllerPosition);
              var currentPosition = el.getAttribute("position");
              el.setAttribute("position", {
                x: currentPosition.x + deltaControllerPosition.x,
                y: currentPosition.y + deltaControllerPosition.y,
                z: currentPosition.z + deltaControllerPosition.z
              });
            };
          }(),
          updateButtons: function() {
            var i;
            var buttonState;
            var controller = this.controller;
            if (!this.controller) {
              return;
            }
            for (i = 0; i < controller.buttons.length; ++i) {
              buttonState = controller.buttons[i];
              this.handleButton(i, buttonState);
            }
            this.handleAxes(controller.axes);
          },
          handleAxes: function(controllerAxes) {
            var previousAxis = this.previousAxis;
            var changed = false;
            var i;
            for (i = 0; i < controllerAxes.length; ++i) {
              if (previousAxis[i] !== controllerAxes[i]) {
                changed = true;
                break;
              }
            }
            if (!changed) {
              return;
            }
            this.previousAxis = controllerAxes.slice();
            this.el.emit("axismove", { axis: this.previousAxis });
          },
          handleButton: function(id, buttonState) {
            var changed = false;
            changed = changed || this.handlePress(id, buttonState);
            changed = changed || this.handleTouch(id, buttonState);
            changed = changed || this.handleValue(id, buttonState);
            if (!changed) {
              return;
            }
            this.el.emit("buttonchanged", { id, state: buttonState });
          },
          handlePress: function(id, buttonState) {
            var buttonStates = this.buttonStates;
            var evtName;
            var previousButtonState = buttonStates[id] = buttonStates[id] || {};
            if (buttonState.pressed === previousButtonState.pressed) {
              return;
            }
            if (buttonState.pressed) {
              evtName = "down";
            } else {
              evtName = "up";
            }
            this.el.emit("button" + evtName, { id });
            previousButtonState.pressed = buttonState.pressed;
          },
          handleTouch: function(id, buttonState) {
            var buttonStates = this.buttonStates;
            var evtName;
            var previousButtonState = buttonStates[id] = buttonStates[id] || {};
            if (buttonState.touched === previousButtonState.touched) {
              return false;
            }
            if (buttonState.touched) {
              evtName = "start";
            } else {
              evtName = "end";
            }
            previousButtonState.touched = buttonState.touched;
            this.el.emit("touch" + evtName, { id, state: previousButtonState });
            return true;
          },
          handleValue: function(id, buttonState) {
            var buttonStates = this.buttonStates;
            var previousButtonState = buttonStates[id] = buttonStates[id] || {};
            if (buttonState.value === previousButtonState.value) {
              return false;
            }
            previousButtonState.value = buttonState.value;
            return true;
          }
        });
      }, { "../core/component": 63, "../lib/three": 106 }], 50: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        module3.exports.Component = registerComponent("visible", {
          schema: { default: true },
          update: function() {
            this.el.object3D.visible = this.data;
          }
        });
      }, { "../core/component": 63 }], 51: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../core/component").registerComponent;
        var bind = _dereq_("../utils/bind");
        var isControllerPresent = _dereq_("../utils/tracked-controls").isControllerPresent;
        var VIVE_CONTROLLER_MODEL_OBJ_URL = "https://cdn.aframe.io/controllers/vive/vr_controller_vive.obj";
        var VIVE_CONTROLLER_MODEL_OBJ_MTL = "https://cdn.aframe.io/controllers/vive/vr_controller_vive.mtl";
        var GAMEPAD_ID_PREFIX = "OpenVR Gamepad";
        module3.exports.Component = registerComponent("vive-controls", {
          schema: {
            hand: { default: "left" },
            buttonColor: { default: "#FAFAFA" },
            // Off-white.
            buttonHighlightColor: { default: "#22D1EE" },
            // Light blue.
            model: { default: true },
            rotationOffset: { default: 0 }
            // use -999 as sentinel value to auto-determine based on hand
          },
          // buttonId
          // 0 - trackpad
          // 1 - trigger ( intensity value from 0.5 to 1 )
          // 2 - grip
          // 3 - menu ( dispatch but better for menu options )
          // 4 - system ( never dispatched on this layer )
          mapping: {
            axis0: "trackpad",
            axis1: "trackpad",
            button0: "trackpad",
            button1: "trigger",
            button2: "grip",
            button3: "menu",
            button4: "system"
          },
          bindMethods: function() {
            this.onModelLoaded = bind(this.onModelLoaded, this);
            this.onControllersUpdate = bind(this.onControllersUpdate, this);
            this.checkIfControllerPresent = bind(this.checkIfControllerPresent, this);
            this.removeControllersUpdateListener = bind(this.removeControllersUpdateListener, this);
            this.onGamepadConnected = bind(this.onGamepadConnected, this);
            this.onGamepadDisconnected = bind(this.onGamepadDisconnected, this);
          },
          init: function() {
            var self2 = this;
            this.animationActive = "pointing";
            this.onButtonChanged = bind(this.onButtonChanged, this);
            this.onButtonDown = function(evt) {
              self2.onButtonEvent(evt.detail.id, "down");
            };
            this.onButtonUp = function(evt) {
              self2.onButtonEvent(evt.detail.id, "up");
            };
            this.onButtonTouchStart = function(evt) {
              self2.onButtonEvent(evt.detail.id, "touchstart");
            };
            this.onButtonTouchEnd = function(evt) {
              self2.onButtonEvent(evt.detail.id, "touchend");
            };
            this.controllerPresent = false;
            this.everGotGamepadEvent = false;
            this.lastControllerCheck = 0;
            this.bindMethods();
            this.isControllerPresent = isControllerPresent;
          },
          addEventListeners: function() {
            var el = this.el;
            el.addEventListener("buttonchanged", this.onButtonChanged);
            el.addEventListener("buttondown", this.onButtonDown);
            el.addEventListener("buttonup", this.onButtonUp);
            el.addEventListener("touchstart", this.onButtonTouchStart);
            el.addEventListener("touchend", this.onButtonTouchEnd);
            el.addEventListener("model-loaded", this.onModelLoaded);
          },
          removeEventListeners: function() {
            var el = this.el;
            el.removeEventListener("buttonchanged", this.onButtonChanged);
            el.removeEventListener("buttondown", this.onButtonDown);
            el.removeEventListener("buttonup", this.onButtonUp);
            el.removeEventListener("touchstart", this.onButtonTouchStart);
            el.removeEventListener("touchend", this.onButtonTouchEnd);
            el.removeEventListener("model-loaded", this.onModelLoaded);
          },
          checkIfControllerPresent: function() {
            var data = this.data;
            var controller = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            var isPresent = this.isControllerPresent(this.el.sceneEl, GAMEPAD_ID_PREFIX, { index: controller });
            if (isPresent === this.controllerPresent) {
              return;
            }
            this.controllerPresent = isPresent;
            if (isPresent) {
              this.injectTrackedControls();
              this.addEventListeners();
            } else {
              this.removeEventListeners();
            }
          },
          onGamepadConnected: function(evt) {
            this.checkIfControllerPresent();
          },
          onGamepadDisconnected: function(evt) {
            this.checkIfControllerPresent();
          },
          play: function() {
            this.checkIfControllerPresent();
            window.addEventListener("gamepadconnected", this.onGamepadConnected, false);
            window.addEventListener("gamepaddisconnected", this.onGamepadDisconnected, false);
            this.addControllersUpdateListener();
          },
          pause: function() {
            window.removeEventListener("gamepadconnected", this.onGamepadConnected, false);
            window.removeEventListener("gamepaddisconnected", this.onGamepadDisconnected, false);
            this.removeControllersUpdateListener();
            this.removeEventListeners();
          },
          injectTrackedControls: function() {
            var el = this.el;
            var data = this.data;
            var objUrl = "url(" + VIVE_CONTROLLER_MODEL_OBJ_URL + ")";
            var mtlUrl = "url(" + VIVE_CONTROLLER_MODEL_OBJ_MTL + ")";
            var controller = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            el.setAttribute("tracked-controls", { id: GAMEPAD_ID_PREFIX, controller, rotationOffset: data.rotationOffset });
            if (!data.model) {
              return;
            }
            el.setAttribute("obj-model", { obj: objUrl, mtl: mtlUrl });
          },
          addControllersUpdateListener: function() {
            this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, false);
          },
          removeControllersUpdateListener: function() {
            this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, false);
          },
          onControllersUpdate: function() {
            if (!this.everGotGamepadEvent) {
              this.checkIfControllerPresent();
            }
          },
          onButtonChanged: function(evt) {
            var button = this.mapping["button" + evt.detail.id];
            var buttonMeshes = this.buttonMeshes;
            var value;
            if (!button || !buttonMeshes || button !== "trigger") {
              return;
            }
            value = evt.detail.state.value;
            buttonMeshes.trigger.rotation.x = -value * (Math.PI / 12);
          },
          onModelLoaded: function(evt) {
            var controllerObject3D = evt.detail.model;
            var buttonMeshes;
            if (!this.data.model) {
              return;
            }
            buttonMeshes = this.buttonMeshes = {};
            buttonMeshes.grip = {
              left: controllerObject3D.getObjectByName("leftgrip"),
              right: controllerObject3D.getObjectByName("rightgrip")
            };
            buttonMeshes.menu = controllerObject3D.getObjectByName("menubutton");
            buttonMeshes.system = controllerObject3D.getObjectByName("systembutton");
            buttonMeshes.trackpad = controllerObject3D.getObjectByName("touchpad");
            buttonMeshes.trigger = controllerObject3D.getObjectByName("trigger");
            controllerObject3D.position.set(0, -0.015, 0.04);
          },
          onButtonEvent: function(id, evtName) {
            var buttonName = this.mapping["button" + id];
            var i;
            if (Array.isArray(buttonName)) {
              for (i = 0; i < buttonName.length; i++) {
                this.el.emit(buttonName[i] + evtName);
              }
            } else {
              this.el.emit(buttonName + evtName);
            }
            this.updateModel(buttonName, evtName);
          },
          updateModel: function(buttonName, evtName) {
            var i;
            if (!this.data.model) {
              return;
            }
            if (Array.isArray(buttonName)) {
              for (i = 0; i < buttonName.length; i++) {
                this.updateButtonModel(buttonName[i], evtName);
              }
            } else {
              this.updateButtonModel(buttonName, evtName);
            }
          },
          updateButtonModel: function(buttonName, state) {
            var color = state === "up" ? this.data.buttonColor : this.data.buttonHighlightColor;
            var buttonMeshes = this.buttonMeshes;
            if (!buttonMeshes) {
              return;
            }
            if (buttonName === "grip") {
              buttonMeshes.grip.left.material.color.set(color);
              buttonMeshes.grip.right.material.color.set(color);
              return;
            }
            buttonMeshes[buttonName].material.color.set(color);
          }
        });
      }, { "../core/component": 63, "../utils/bind": 118, "../utils/tracked-controls": 128 }], 52: [function(_dereq_, module3, exports3) {
        var KEYCODE_TO_CODE = _dereq_("../constants").keyboardevent.KEYCODE_TO_CODE;
        var registerComponent = _dereq_("../core/component").registerComponent;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var bind = utils.bind;
        var shouldCaptureKeyEvent = utils.shouldCaptureKeyEvent;
        var CLAMP_VELOCITY = 1e-5;
        var MAX_DELTA = 0.2;
        module3.exports.Component = registerComponent("wasd-controls", {
          schema: {
            acceleration: { default: 65 },
            adAxis: { default: "x", oneOf: ["x", "y", "z"] },
            adEnabled: { default: true },
            adInverted: { default: false },
            easing: { default: 20 },
            enabled: { default: true },
            fly: { default: false },
            wsAxis: { default: "z", oneOf: ["x", "y", "z"] },
            wsEnabled: { default: true },
            wsInverted: { default: false }
          },
          init: function() {
            this.keys = {};
            this.velocity = new THREE2.Vector3();
            this.onBlur = bind(this.onBlur, this);
            this.onFocus = bind(this.onFocus, this);
            this.onKeyDown = bind(this.onKeyDown, this);
            this.onKeyUp = bind(this.onKeyUp, this);
            this.onVisibilityChange = bind(this.onVisibilityChange, this);
            this.attachVisibilityEventListeners();
          },
          tick: function(time, delta) {
            var data = this.data;
            var el = this.el;
            var movementVector;
            var position;
            var velocity = this.velocity;
            delta = delta / 1e3;
            this.updateVelocity(delta);
            if (!velocity[data.adAxis] && !velocity[data.wsAxis]) {
              return;
            }
            movementVector = this.getMovementVector(delta);
            position = el.getAttribute("position");
            el.setAttribute("position", {
              x: position.x + movementVector.x,
              y: position.y + movementVector.y,
              z: position.z + movementVector.z
            });
          },
          remove: function() {
            this.removeKeyEventListeners();
            this.removeVisibilityEventListeners();
          },
          play: function() {
            this.attachKeyEventListeners();
          },
          pause: function() {
            this.keys = {};
            this.removeKeyEventListeners();
          },
          updateVelocity: function(delta) {
            var acceleration;
            var adAxis;
            var adSign;
            var data = this.data;
            var keys = this.keys;
            var velocity = this.velocity;
            var wsAxis;
            var wsSign;
            adAxis = data.adAxis;
            wsAxis = data.wsAxis;
            if (delta > MAX_DELTA) {
              velocity[adAxis] = 0;
              velocity[wsAxis] = 0;
              return;
            }
            if (velocity[adAxis] !== 0) {
              velocity[adAxis] -= velocity[adAxis] * data.easing * delta;
            }
            if (velocity[wsAxis] !== 0) {
              velocity[wsAxis] -= velocity[wsAxis] * data.easing * delta;
            }
            if (Math.abs(velocity[adAxis]) < CLAMP_VELOCITY) {
              velocity[adAxis] = 0;
            }
            if (Math.abs(velocity[wsAxis]) < CLAMP_VELOCITY) {
              velocity[wsAxis] = 0;
            }
            if (!data.enabled) {
              return;
            }
            acceleration = data.acceleration;
            if (data.adEnabled) {
              adSign = data.adInverted ? -1 : 1;
              if (keys.KeyA || keys.ArrowLeft) {
                velocity[adAxis] -= adSign * acceleration * delta;
              }
              if (keys.KeyD || keys.ArrowRight) {
                velocity[adAxis] += adSign * acceleration * delta;
              }
            }
            if (data.wsEnabled) {
              wsSign = data.wsInverted ? -1 : 1;
              if (keys.KeyW || keys.ArrowUp) {
                velocity[wsAxis] -= wsSign * acceleration * delta;
              }
              if (keys.KeyS || keys.ArrowDown) {
                velocity[wsAxis] += wsSign * acceleration * delta;
              }
            }
          },
          getMovementVector: function() {
            var directionVector = new THREE2.Vector3(0, 0, 0);
            var rotationEuler = new THREE2.Euler(0, 0, 0, "YXZ");
            return function(delta) {
              var rotation = this.el.getAttribute("rotation");
              var velocity = this.velocity;
              directionVector.copy(velocity);
              directionVector.multiplyScalar(delta);
              if (!rotation) {
                return directionVector;
              }
              if (!this.data.fly) {
                rotation.x = 0;
              }
              rotationEuler.set(THREE2.Math.degToRad(rotation.x), THREE2.Math.degToRad(rotation.y), 0);
              directionVector.applyEuler(rotationEuler);
              return directionVector;
            };
          }(),
          attachVisibilityEventListeners: function() {
            window.addEventListener("blur", this.onBlur);
            window.addEventListener("focus", this.onFocus);
            document.addEventListener("visibilitychange", this.onVisibilityChange);
          },
          removeVisibilityEventListeners: function() {
            window.removeEventListener("blur", this.onBlur);
            window.removeEventListener("focus", this.onFocus);
            document.removeEventListener("visibilitychange", this.onVisibilityChange);
          },
          attachKeyEventListeners: function() {
            window.addEventListener("keydown", this.onKeyDown);
            window.addEventListener("keyup", this.onKeyUp);
          },
          removeKeyEventListeners: function() {
            window.removeEventListener("keydown", this.onKeyDown);
            window.removeEventListener("keyup", this.onKeyUp);
          },
          onBlur: function() {
            this.pause();
          },
          onFocus: function() {
            this.play();
          },
          onVisibilityChange: function() {
            if (document.hidden) {
              this.onBlur();
            } else {
              this.onFocus();
            }
          },
          onKeyDown: function(event) {
            var code;
            if (!shouldCaptureKeyEvent(event)) {
              return;
            }
            code = event.code || KEYCODE_TO_CODE[event.keyCode];
            this.keys[code] = true;
          },
          onKeyUp: function(event) {
            var code;
            code = event.code || KEYCODE_TO_CODE[event.keyCode];
            this.keys[code] = false;
          }
        });
      }, { "../constants": 54, "../core/component": 63, "../lib/three": 106, "../utils/": 124 }], 53: [function(_dereq_, module3, exports3) {
        var TWEEN = _dereq_("tween.js");
        var DIRECTIONS = {
          alternate: "alternate",
          alternateReverse: "alternate-reverse",
          normal: "normal",
          reverse: "reverse"
        };
        var EASING_FUNCTIONS = {
          "linear": TWEEN.Easing.Linear.None,
          "ease": TWEEN.Easing.Cubic.InOut,
          "ease-in": TWEEN.Easing.Cubic.In,
          "ease-out": TWEEN.Easing.Cubic.Out,
          "ease-in-out": TWEEN.Easing.Cubic.InOut,
          "ease-cubic": TWEEN.Easing.Cubic.In,
          "ease-in-cubic": TWEEN.Easing.Cubic.In,
          "ease-out-cubic": TWEEN.Easing.Cubic.Out,
          "ease-in-out-cubic": TWEEN.Easing.Cubic.InOut,
          "ease-quad": TWEEN.Easing.Quadratic.InOut,
          "ease-in-quad": TWEEN.Easing.Quadratic.In,
          "ease-out-quad": TWEEN.Easing.Quadratic.Out,
          "ease-in-out-quad": TWEEN.Easing.Quadratic.InOut,
          "ease-quart": TWEEN.Easing.Quartic.InOut,
          "ease-in-quart": TWEEN.Easing.Quartic.In,
          "ease-out-quart": TWEEN.Easing.Quartic.Out,
          "ease-in-out-quart": TWEEN.Easing.Quartic.InOut,
          "ease-quint": TWEEN.Easing.Quintic.InOut,
          "ease-in-quint": TWEEN.Easing.Quintic.In,
          "ease-out-quint": TWEEN.Easing.Quintic.Out,
          "ease-in-out-quint": TWEEN.Easing.Quintic.InOut,
          "ease-sine": TWEEN.Easing.Sinusoidal.InOut,
          "ease-in-sine": TWEEN.Easing.Sinusoidal.In,
          "ease-out-sine": TWEEN.Easing.Sinusoidal.Out,
          "ease-in-out-sine": TWEEN.Easing.Sinusoidal.InOut,
          "ease-expo": TWEEN.Easing.Exponential.InOut,
          "ease-in-expo": TWEEN.Easing.Exponential.In,
          "ease-out-expo": TWEEN.Easing.Exponential.Out,
          "ease-in-out-expo": TWEEN.Easing.Exponential.InOut,
          "ease-circ": TWEEN.Easing.Circular.InOut,
          "ease-in-circ": TWEEN.Easing.Circular.In,
          "ease-out-circ": TWEEN.Easing.Circular.Out,
          "ease-in-out-circ": TWEEN.Easing.Circular.InOut,
          "ease-elastic": TWEEN.Easing.Elastic.InOut,
          "ease-in-elastic": TWEEN.Easing.Elastic.In,
          "ease-out-elastic": TWEEN.Easing.Elastic.Out,
          "ease-in-out-elastic": TWEEN.Easing.Elastic.InOut,
          "ease-back": TWEEN.Easing.Back.InOut,
          "ease-in-back": TWEEN.Easing.Back.In,
          "ease-out-back": TWEEN.Easing.Back.Out,
          "ease-in-out-back": TWEEN.Easing.Back.InOut,
          "ease-bounce": TWEEN.Easing.Bounce.InOut,
          "ease-in-bounce": TWEEN.Easing.Bounce.In,
          "ease-out-bounce": TWEEN.Easing.Bounce.Out,
          "ease-in-out-bounce": TWEEN.Easing.Bounce.InOut
        };
        var FILLS = {
          backwards: "backwards",
          both: "both",
          forwards: "forwards",
          none: "none"
        };
        var REPEATS = {
          indefinite: "indefinite"
        };
        var DEFAULTS = {
          attribute: "rotation",
          begin: "",
          end: "",
          delay: 0,
          dur: 1e3,
          easing: "ease",
          direction: DIRECTIONS.normal,
          fill: FILLS.forwards,
          from: void 0,
          repeat: 0,
          to: void 0
        };
        module3.exports.defaults = DEFAULTS;
        module3.exports.directions = DIRECTIONS;
        module3.exports.easingFunctions = EASING_FUNCTIONS;
        module3.exports.fills = FILLS;
        module3.exports.repeats = REPEATS;
      }, { "tween.js": 18 }], 54: [function(_dereq_, module3, exports3) {
        module3.exports = {
          AFRAME_INJECTED: "aframe-injected",
          DEFAULT_CAMERA_HEIGHT: 1.6,
          animation: _dereq_("./animation"),
          keyboardevent: _dereq_("./keyboardevent")
        };
      }, { "./animation": 53, "./keyboardevent": 55 }], 55: [function(_dereq_, module3, exports3) {
        module3.exports = {
          // Tiny KeyboardEvent.code polyfill.
          KEYCODE_TO_CODE: {
            "38": "ArrowUp",
            "37": "ArrowLeft",
            "40": "ArrowDown",
            "39": "ArrowRight",
            "87": "KeyW",
            "65": "KeyA",
            "83": "KeyS",
            "68": "KeyD"
          }
        };
      }, {}], 56: [function(_dereq_, module3, exports3) {
        var ANode = _dereq_("./a-node");
        var animationConstants = _dereq_("../constants/animation");
        var coordinates = _dereq_("../utils/").coordinates;
        var parseProperty = _dereq_("./schema").parseProperty;
        var registerElement = _dereq_("./a-register-element").registerElement;
        var TWEEN = _dereq_("tween.js");
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var bind = utils.bind;
        var getComponentProperty = utils.entity.getComponentProperty;
        var DEFAULTS = animationConstants.defaults;
        var DIRECTIONS = animationConstants.directions;
        var EASING_FUNCTIONS = animationConstants.easingFunctions;
        var FILLS = animationConstants.fills;
        var REPEATS = animationConstants.repeats;
        var isCoordinate = coordinates.isCoordinate;
        module3.exports.AAnimation = registerElement("a-animation", {
          prototype: Object.create(ANode.prototype, {
            createdCallback: {
              value: function() {
                this.bindMethods();
                this.isRunning = false;
                this.partialSetAttribute = function() {
                };
                this.tween = null;
              }
            },
            attachedCallback: {
              value: function() {
                this.el = this.parentNode;
                this.handleMixinUpdate();
                this.update();
                this.load();
              }
            },
            attributeChangedCallback: {
              value: function(attr, oldVal, newVal) {
                if (!this.hasLoaded || !this.isRunning) {
                  return;
                }
                this.stop();
                this.handleMixinUpdate();
                this.update();
              }
            },
            detachedCallback: {
              value: function() {
                if (!this.isRunning) {
                  return;
                }
                this.stop();
              }
            },
            /**
             * Builds a Tween object to handle animations.
             * Uses tween.js's from, to, delay, easing, repeat, onUpdate, and onComplete.
             * Note: tween.js takes objects for its `from` and `to` values.
             *
             * @returns {object}
             */
            getTween: {
              value: function() {
                var self2 = this;
                var data = self2.data;
                var el = self2.el;
                var animationValues;
                var attribute = data.attribute;
                var delay = parseInt(data.delay, 10);
                var currentValue = getComponentProperty(el, attribute);
                var direction = self2.getDirection(data.direction);
                var easing = EASING_FUNCTIONS[data.easing];
                var fill = data.fill;
                var from;
                var repeat = data.repeat === REPEATS.indefinite ? Infinity : 0;
                var to;
                var toTemp;
                var yoyo = false;
                animationValues = getAnimationValues(el, attribute, data.from || self2.initialValue, data.to, currentValue);
                from = animationValues.from;
                to = animationValues.to;
                self2.partialSetAttribute = animationValues.partialSetAttribute;
                if (self2.count === void 0) {
                  self2.count = repeat === Infinity ? 0 : parseInt(data.repeat, 10);
                }
                if (isNaN(delay)) {
                  delay = 0;
                }
                self2.initialValue = self2.initialValue || cloneValue(currentValue);
                if (repeat === Infinity && fill === FILLS.forwards && [
                  DIRECTIONS.alternate,
                  DIRECTIONS.alternateReverse
                ].indexOf(data.direction) !== -1) {
                  yoyo = true;
                }
                if (direction === DIRECTIONS.reverse) {
                  toTemp = to;
                  to = cloneValue(from);
                  from = cloneValue(toTemp);
                }
                if ([FILLS.backwards, FILLS.both].indexOf(fill) !== -1) {
                  self2.partialSetAttribute(from);
                }
                return new TWEEN.Tween(cloneValue(from)).to(to, data.dur).delay(delay).easing(easing).repeat(repeat).yoyo(yoyo).onUpdate(function() {
                  self2.partialSetAttribute(this);
                }).onComplete(bind(self2.onCompleted, self2));
              }
            },
            /**
             * Animation parameters changed. Stop current animation, get a new one, and start it.
             */
            update: {
              value: function() {
                var data = this.data;
                if (data.repeat === "infinite") {
                  console.warn("Using 'infinite' as 'repeat' value is invalid.  Use 'indefinite' instead.");
                }
                if (data.begin !== "" && !isNaN(data.begin)) {
                  console.warn("Using 'begin' to specify a delay is deprecated. Use 'delay' instead.");
                  data.delay = data.begin;
                  data.begin = "";
                }
                var begin = data.begin;
                var end = data.end;
                if (this.evt) {
                  this.removeEventListeners(this.evt);
                }
                this.evt = { begin, end };
                this.addEventListeners(this.evt);
                if (begin === "") {
                  this.stop();
                  this.start();
                }
              },
              writable: window.debug
            },
            /**
             * Callback for when a cycle of an animation is complete. Handles when to completely
             * finish the animation.
             *
             * If `repeat` is set to a value, this method is called after each repeat. Repeats are
             * handled by ending the current animation and creating a new one with `count` updated.
             * Note that this method is *not* called if repeat is set to `indefinite`.
             */
            onCompleted: {
              value: function() {
                var data = this.data;
                this.isRunning = false;
                if ([FILLS.backwards, FILLS.none].indexOf(data.fill) !== -1) {
                  this.partialSetAttribute(this.initialValue);
                }
                if (this.count === 0) {
                  this.count = void 0;
                  this.emit("animationend");
                  return;
                }
                this.isRunning = false;
                this.count--;
                this.start();
              }
            },
            start: {
              value: function() {
                var self2 = this;
                if (!this.el.hasLoaded) {
                  this.el.addEventListener("loaded", function() {
                    self2.start();
                  });
                  return;
                }
                if (this.isRunning || !this.el.isPlaying) {
                  return;
                }
                this.tween = this.getTween();
                this.isRunning = true;
                this.tween.start();
                this.emit("animationstart");
              },
              writable: true
            },
            stop: {
              value: function() {
                var tween = this.tween;
                if (!tween) {
                  return;
                }
                tween.stop();
                this.isRunning = false;
                if ([FILLS.backwards, FILLS.none].indexOf(this.data.fill) !== -1) {
                  this.partialSetAttribute(this.initialValue);
                }
                this.emit("animationstop");
              },
              writable: true
            },
            /**
             * Handle alternating directions. Given the current direction, calculate the next one,
             * and store the current one.
             *
             * @param {string} direction
             * @returns {string} Direction that the next individual cycle of the animation will go
             *          towards.
             */
            getDirection: {
              value: function(direction) {
                if (direction === DIRECTIONS.alternate) {
                  this.prevDirection = this.prevDirection === DIRECTIONS.normal ? DIRECTIONS.reverse : DIRECTIONS.normal;
                  return this.prevDirection;
                }
                if (direction === DIRECTIONS.alternateReverse) {
                  this.prevDirection = this.prevDirection === DIRECTIONS.reverse ? DIRECTIONS.normal : DIRECTIONS.reverse;
                  return this.prevDirection;
                }
                return direction;
              }
            },
            /**
             * Preemptive binding to attach/detach event listeners (see `update`).
             */
            bindMethods: {
              value: function() {
                this.start = bind(this.start, this);
                this.stop = bind(this.stop, this);
                this.onStateAdded = bind(this.onStateAdded, this);
                this.onStateRemoved = bind(this.onStateRemoved, this);
              }
            },
            addEventListeners: {
              value: function(evts) {
                var el = this.el;
                var self2 = this;
                utils.splitString(evts.begin).forEach(function(evt) {
                  el.addEventListener(evt, self2.start);
                });
                utils.splitString(evts.end).forEach(function(evt) {
                  el.addEventListener(evt, self2.stop);
                });
                if (evts.begin === "") {
                  el.addEventListener("play", this.start);
                }
                el.addEventListener("pause", this.stop);
                el.addEventListener("stateadded", this.onStateAdded);
                el.addEventListener("stateremoved", this.onStateRemoved);
              }
            },
            removeEventListeners: {
              value: function(evts) {
                var el = this.el;
                var start = this.start;
                var stop = this.stop;
                utils.splitString(evts.begin).forEach(function(evt) {
                  el.removeEventListener(evt, start);
                });
                utils.splitString(evts.end).forEach(function(evt) {
                  el.removeEventListener(evt, stop);
                });
                el.removeEventListener("stateadded", this.onStateAdded);
                el.removeEventListener("stateremoved", this.onStateRemoved);
              }
            },
            onStateAdded: {
              value: function(evt) {
                if (evt.detail.state === this.data.begin) {
                  this.start();
                }
              },
              writable: true
            },
            onStateRemoved: {
              value: function(evt) {
                if (evt.detail.state === this.data.begin) {
                  this.stop();
                }
              },
              writable: true
            },
            /**
             * Applies animation data from a mixin element.
             * Works the same as component mixins but reimplemented because animations
             * aren't components.
             */
            handleMixinUpdate: {
              value: function() {
                var data = {};
                var elData;
                var mixinData;
                var mixinEl;
                mixinEl = document.querySelector("#" + this.getAttribute("mixin"));
                mixinData = mixinEl ? utils.getElData(mixinEl, DEFAULTS) : {};
                elData = utils.getElData(this, DEFAULTS);
                utils.extend(data, DEFAULTS, mixinData, elData);
                this.data = data;
              }
            }
          })
        });
        function cloneValue(val) {
          return utils.extend({}, val);
        }
        function getAnimationValues(el, attribute, dataFrom, dataTo, currentValue) {
          var attributeSplit = attribute.split(".");
          var schema;
          var component;
          var componentPropName;
          var componentName;
          var from = {};
          var partialSetAttribute;
          var to = {};
          if (attributeSplit.length === 2) {
            if (isColor()) {
              getForColorComponent();
            } else {
              getForComponentAttribute();
            }
          } else if (dataTo && isCoordinate(dataTo)) {
            getForCoordinateComponent();
          } else if (["true", "false"].indexOf(dataTo) !== -1) {
            getForBoolean();
          } else if (isNaN(dataTo)) {
            getForColorComponent();
          } else {
            getForNumber();
          }
          return {
            from,
            partialSetAttribute,
            to
          };
          function isColor() {
            var componentName2 = attributeSplit[0];
            var propertyName = attributeSplit[1];
            var component2 = el.components[componentName2];
            var schema2 = component2 && component2.schema;
            return schema2 && schema2[propertyName] && schema2[propertyName].type === "color";
          }
          function getForComponentAttribute() {
            componentName = attributeSplit[0];
            componentPropName = attributeSplit[1];
            component = el.components[componentName];
            if (!component) {
              el.setAttribute(componentName, "");
              component = el.components[componentName];
            }
            schema = component.schema;
            if (dataFrom === void 0) {
              from[attribute] = getComponentProperty(el, attribute);
            } else {
              from[attribute] = dataFrom;
            }
            from[attribute] = parseProperty(from[attribute], schema[componentPropName]);
            to[attribute] = parseProperty(dataTo, schema[componentPropName]);
            partialSetAttribute = function(value) {
              if (!(attribute in value)) {
                return;
              }
              el.setAttribute(componentName, componentPropName, value[attribute]);
            };
          }
          function getForCoordinateComponent() {
            from = dataFrom ? coordinates.parse(dataFrom) : currentValue;
            to = coordinates.parse(dataTo);
            partialSetAttribute = function(value) {
              el.setAttribute(attribute, value);
            };
          }
          function getForBoolean() {
            if (dataFrom === void 0) {
              from[attribute] = false;
            } else {
              from[attribute] = strToBool(dataFrom);
            }
            from[attribute] = boolToNum(from[attribute]);
            to[attribute] = boolToNum(strToBool(dataTo));
            partialSetAttribute = function(value) {
              el.setAttribute(attribute, !!value[attribute]);
            };
          }
          function getForColorComponent() {
            from = new THREE2.Color(dataFrom);
            to = new THREE2.Color(dataTo);
            partialSetAttribute = function(value) {
              if (attributeSplit.length > 1) {
                el.setAttribute(attributeSplit[0], attributeSplit[1], rgbVectorToHex(value));
              }
              el.setAttribute(attribute, rgbVectorToHex(value));
            };
          }
          function getForNumber() {
            if (dataFrom === void 0) {
              from[attribute] = parseFloat(el.getAttribute(attribute));
            } else {
              from[attribute] = parseFloat(dataFrom);
            }
            to[attribute] = parseFloat(dataTo);
            partialSetAttribute = function(value) {
              el.setAttribute(attribute, value[attribute]);
            };
          }
        }
        module3.exports.getAnimationValues = getAnimationValues;
        function strToBool(str) {
          if (str === "true") {
            return true;
          }
          return false;
        }
        function boolToNum(bool) {
          return bool ? 1 : 0;
        }
        function componentToHex(color) {
          var hex = color.toString(16);
          return hex.length === 1 ? "0" + hex : hex;
        }
        function convertToIntegerColor(color) {
          return Math.floor(Math.min(Math.abs(color), 1) * 255);
        }
        function rgbVectorToHex(color) {
          return "#" + ["r", "g", "b"].map(function(prop) {
            return componentToHex(convertToIntegerColor(color[prop]));
          }).join("");
        }
      }, { "../constants/animation": 53, "../lib/three": 106, "../utils/": 124, "./a-node": 61, "./a-register-element": 62, "./schema": 70, "tween.js": 18 }], 57: [function(_dereq_, module3, exports3) {
        var ANode = _dereq_("./a-node");
        var bind = _dereq_("../utils/bind");
        var debug = _dereq_("../utils/debug");
        var registerElement = _dereq_("./a-register-element").registerElement;
        var THREE2 = _dereq_("../lib/three");
        var fileLoader = new THREE2.XHRLoader();
        var warn = debug("core:a-assets:warn");
        module3.exports = registerElement("a-assets", {
          prototype: Object.create(ANode.prototype, {
            createdCallback: {
              value: function() {
                this.isAssets = true;
                this.fileLoader = fileLoader;
                this.timeout = null;
              }
            },
            attachedCallback: {
              value: function() {
                var self2 = this;
                var i;
                var loaded = [];
                var mediaEl;
                var mediaEls;
                var imgEl;
                var imgEls;
                var timeout;
                if (!this.parentNode.isScene) {
                  throw new Error("<a-assets> must be a child of a <a-scene>.");
                }
                imgEls = this.querySelectorAll("img");
                for (i = 0; i < imgEls.length; i++) {
                  imgEl = fixUpMediaElement(imgEls[i]);
                  loaded.push(new Promise(function(resolve, reject) {
                    imgEl.onload = resolve;
                    imgEl.onerror = reject;
                  }));
                }
                mediaEls = this.querySelectorAll("audio, video");
                for (i = 0; i < mediaEls.length; i++) {
                  mediaEl = fixUpMediaElement(mediaEls[i]);
                  loaded.push(mediaElementLoaded(mediaEl));
                }
                Promise.all(loaded).then(bind(this.load, this));
                timeout = parseInt(this.getAttribute("timeout"), 10) || 3e3;
                this.timeout = setTimeout(function() {
                  if (self2.hasLoaded) {
                    return;
                  }
                  warn("Asset loading timed out in ", timeout, "ms");
                  self2.emit("timeout");
                  self2.load();
                }, timeout);
              }
            },
            detachedCallback: {
              value: function() {
                if (this.timeout) {
                  clearTimeout(this.timeout);
                }
              }
            },
            load: {
              value: function() {
                ANode.prototype.load.call(this, null, function waitOnFilter(el) {
                  return el.isAssetItem && el.hasAttribute("src");
                });
              }
            }
          })
        });
        registerElement("a-asset-item", {
          prototype: Object.create(ANode.prototype, {
            createdCallback: {
              value: function() {
                this.data = null;
                this.isAssetItem = true;
              }
            },
            attachedCallback: {
              value: function() {
                var self2 = this;
                var src = this.getAttribute("src");
                fileLoader.load(src, function handleOnLoad(textResponse) {
                  THREE2.Cache.files[src] = textResponse;
                  self2.data = textResponse;
                  setTimeout(function load() {
                    ANode.prototype.load.call(self2);
                  });
                }, function handleOnProgress(xhr) {
                  self2.emit("progress", {
                    loadedBytes: xhr.loaded,
                    totalBytes: xhr.total,
                    xhr
                  });
                }, function handleOnError(xhr) {
                  self2.emit("error", { xhr });
                });
              }
            }
          })
        });
        function mediaElementLoaded(el) {
          if (!el.hasAttribute("autoplay") && el.getAttribute("preload") !== "auto") {
            return;
          }
          return new Promise(function(resolve, reject) {
            if (el.readyState === 4) {
              return resolve();
            }
            if (el.error) {
              return reject();
            }
            el.addEventListener("loadeddata", checkProgress, false);
            el.addEventListener("progress", checkProgress, false);
            el.addEventListener("error", reject, false);
            function checkProgress() {
              var secondsBuffered = 0;
              for (var i = 0; i < el.buffered.length; i++) {
                secondsBuffered += el.buffered.end(i) - el.buffered.start(i);
              }
              if (secondsBuffered >= el.duration) {
                resolve();
              }
            }
          });
        }
        function fixUpMediaElement(mediaEl) {
          var newMediaEl = setCrossOrigin(mediaEl);
          if (newMediaEl.tagName === "VIDEO") {
            newMediaEl.setAttribute("playsinline", "");
            newMediaEl.setAttribute("webkit-playsinline", "");
          }
          if (newMediaEl !== mediaEl) {
            mediaEl.parentNode.appendChild(newMediaEl);
            mediaEl.parentNode.removeChild(mediaEl);
          }
          return newMediaEl;
        }
        function setCrossOrigin(mediaEl) {
          var newMediaEl;
          var src;
          if (mediaEl.hasAttribute("crossorigin")) {
            return mediaEl;
          }
          src = mediaEl.getAttribute("src");
          if (src !== null) {
            if (src.indexOf("://") === -1) {
              return mediaEl;
            }
            if (extractDomain(src) === window.location.host) {
              return mediaEl;
            }
          }
          warn("Cross-origin element was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set.", src);
          mediaEl.crossOrigin = "anonymous";
          newMediaEl = mediaEl.cloneNode(true);
          return newMediaEl;
        }
        function extractDomain(url) {
          var domain = url.indexOf("://") > -1 ? url.split("/")[2] : url.split("/")[0];
          return domain.split(":")[0];
        }
      }, { "../lib/three": 106, "../utils/bind": 118, "../utils/debug": 120, "./a-node": 61, "./a-register-element": 62 }], 58: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("../utils/debug");
        var registerElement = _dereq_("./a-register-element").registerElement;
        var warn = debug("core:cubemap:warn");
        module3.exports = registerElement("a-cubemap", {
          prototype: Object.create(HTMLElement.prototype, {
            /**
             * Calculates this.srcs.
             */
            attachedCallback: {
              value: function() {
                this.srcs = this.validate();
              },
              writable: window.debug
            },
            /**
             * Checks for exactly six elements with [src].
             * Does not check explicitly for <img>s in case user does not want
             * prefetching.
             *
             * @returns {Array|null} - six URLs if valid, else null.
             */
            validate: {
              value: function() {
                var elements = this.querySelectorAll("[src]");
                var i;
                var srcs = [];
                if (elements.length === 6) {
                  for (i = 0; i < elements.length; i++) {
                    srcs.push(elements[i].getAttribute("src"));
                  }
                  return srcs;
                }
                warn(
                  "<a-cubemap> did not contain exactly six elements each with a `src` attribute."
                );
              },
              writable: window.debug
            }
          })
        });
      }, { "../utils/debug": 120, "./a-register-element": 62 }], 59: [function(_dereq_, module3, exports3) {
        var ANode = _dereq_("./a-node");
        var COMPONENTS = _dereq_("./component").components;
        var registerElement = _dereq_("./a-register-element").registerElement;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var AEntity;
        var bind = utils.bind;
        var debug = utils.debug("core:a-entity:debug");
        var warn = utils.debug("core:a-entity:warn");
        var MULTIPLE_COMPONENT_DELIMITER = "__";
        var proto = Object.create(ANode.prototype, {
          defaultComponents: {
            value: {
              position: "",
              rotation: "",
              scale: "",
              visible: ""
            }
          },
          createdCallback: {
            value: function() {
              this.components = {};
              this.isEntity = true;
              this.isPlaying = false;
              this.object3D = new THREE2.Group();
              this.object3D.el = this;
              this.object3DMap = {};
              this.parentEl = null;
              this.states = [];
            }
          },
          /**
           * Handle changes coming from the browser DOM inspector.
           */
          attributeChangedCallback: {
            value: function(attr, oldVal, newVal) {
              var component = this.components[attr];
              if (component && component.justInitialized && newVal === "") {
                delete component.justInitialized;
                return;
              }
              if (!component && newVal === null) {
                return;
              }
              this.setEntityAttribute(attr, oldVal, newVal);
            }
          },
          /**
           * Add to parent, load, play.
           */
          attachedCallback: {
            value: function() {
              var assetsEl;
              var sceneEl = this.sceneEl;
              var self2 = this;
              this.addToParent();
              if (this.isScene) {
                return;
              }
              if (!sceneEl) {
                this.load();
                return;
              }
              assetsEl = sceneEl.querySelector("a-assets");
              if (assetsEl && !assetsEl.hasLoaded) {
                assetsEl.addEventListener("loaded", function() {
                  self2.load();
                });
                return;
              }
              this.load();
            }
          },
          /**
           * Tell parent to remove this element's object3D from its object3D.
           * Do not call on scene element because that will cause a call to document.body.remove().
           */
          detachedCallback: {
            value: function() {
              if (!this.parentEl || this.isScene) {
                return;
              }
              Object.keys(this.components).forEach(bind(this.removeComponent, this));
              this.removeFromParent();
              ANode.prototype.detachedCallback.call(this);
            }
          },
          /**
           * Apply mixin to component.
           */
          handleMixinUpdate: {
            value: function(attrName) {
              if (!attrName) {
                this.updateComponents();
                return;
              }
              this.updateComponent(attrName, this.getDOMAttribute(attrName));
            }
          },
          mapStateMixins: {
            value: function(state, op) {
              var mixins = this.getAttribute("mixin");
              var mixinIds;
              if (!mixins) {
                return;
              }
              mixinIds = mixins.split(" ");
              mixinIds.forEach(function(id) {
                var mixinId = id + "-" + state;
                op(mixinId);
              });
              this.updateComponents();
            }
          },
          updateStateMixins: {
            value: function(newMixins, oldMixins) {
              var self2 = this;
              oldMixins = oldMixins || "";
              var newMixinsIds = newMixins.split(" ");
              var oldMixinsIds = oldMixins ? oldMixins.split(" ") : [];
              var diff = oldMixinsIds.filter(function(i) {
                return newMixinsIds.indexOf(i) < 0;
              });
              diff.forEach(function(mixinId) {
                var forEach = Array.prototype.forEach;
                var stateMixinsEls = document.querySelectorAll("[id^=" + mixinId + "-]");
                forEach.call(stateMixinsEls, function(el) {
                  self2.unregisterMixin(el.id);
                });
              });
              this.states.forEach(function(state) {
                newMixinsIds.forEach(function(id) {
                  var mixinId = id + "-" + state;
                  self2.registerMixin(mixinId);
                });
              });
            }
          },
          getObject3D: {
            value: function(type) {
              return this.object3DMap[type];
            }
          },
          /**
           * Set a THREE.Object3D into the map.
           *
           * @param {string} type - Developer-set name of the type of object, will be unique per type.
           * @param {object} obj - A THREE.Object3D.
           */
          setObject3D: {
            value: function(type, obj) {
              var oldObj;
              var self2 = this;
              if (!(obj instanceof THREE2.Object3D)) {
                throw new Error(
                  "`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D."
                );
              }
              oldObj = this.getObject3D(type);
              if (oldObj) {
                this.object3D.remove(oldObj);
              }
              obj.el = this;
              if (obj.children.length) {
                obj.traverse(function bindEl(child) {
                  child.el = self2;
                });
              }
              this.object3D.add(obj);
              this.object3DMap[type] = obj;
              this.emit("object3dset", { object: obj, type });
            }
          },
          /**
           * Remove object from scene and entity object3D map.
           */
          removeObject3D: {
            value: function(type) {
              var obj = this.getObject3D(type);
              if (!obj) {
                warn("Tried to remove `Object3D` of type:", type, "which was not defined.");
                return;
              }
              this.object3D.remove(obj);
              delete this.object3DMap[type];
              this.emit("object3dremove", { type });
            }
          },
          /**
           * Gets or creates an object3D of a given type.
           *
           * @param {string} type - Type of the object3D.
           * @param {string} Constructor - Constructor to use to create the object3D if needed.
           * @returns {object}
           */
          getOrCreateObject3D: {
            value: function(type, Constructor) {
              var object3D = this.getObject3D(type);
              if (!object3D && Constructor) {
                object3D = new Constructor();
                this.setObject3D(type, object3D);
              }
              return object3D;
            }
          },
          /**
           * Add child entity.
           *
           * @param {Element} el - Child entity.
           */
          add: {
            value: function(el) {
              if (!el.object3D) {
                throw new Error("Trying to add an element that doesn't have an `object3D`");
              }
              this.object3D.add(el.object3D);
              this.emit("child-attached", { el });
            }
          },
          /**
           * Tell parentNode to add this entity to itself.
           */
          addToParent: {
            value: function() {
              var parentNode = this.parentEl = this.parentNode;
              if (!parentNode || !parentNode.add || this.attachedToParent) {
                return;
              }
              parentNode.add(this);
              this.attachedToParent = true;
            }
          },
          /**
           * Tell parentNode to remove this entity from itself.
           */
          removeFromParent: {
            value: function() {
              var parentEl = this.parentEl;
              this.parentEl.remove(this);
              this.attachedToParent = false;
              this.parentEl = this.parentNode = null;
              parentEl.emit("child-detached", { el: this });
            }
          },
          load: {
            value: function() {
              var self2 = this;
              if (this.hasLoaded) {
                return;
              }
              ANode.prototype.load.call(this, function entityLoadCallback() {
                self2.updateComponents();
                if (self2.isScene || self2.parentEl.isPlaying) {
                  self2.play();
                }
              });
            },
            writable: window.debug
          },
          /**
           * Remove child entity.
           *
           * @param {Element} el - Child entity.
           */
          remove: {
            value: function(el) {
              this.object3D.remove(el.object3D);
            }
          },
          /**
           * @returns {array} Direct children that are entities.
           */
          getChildEntities: {
            value: function() {
              var children = this.children;
              var childEntities = [];
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child instanceof AEntity) {
                  childEntities.push(child);
                }
              }
              return childEntities;
            }
          },
          /**
           * Initialize component.
           *
           * @param {string} attrName - Attribute name asociated to the component.
           * @param {object} data - Component data
           * @param {boolean} isDependency - True if the component is a dependency.
           */
          initComponent: {
            value: function(attrName, data, isDependency) {
              var component;
              var componentInfo = attrName.split(MULTIPLE_COMPONENT_DELIMITER);
              var componentId = componentInfo[1];
              var componentName = componentInfo[0];
              var isComponentDefined = checkComponentDefined(this, attrName) || data !== void 0;
              if (!COMPONENTS[componentName]) {
                return;
              }
              if (!isComponentDefined && !isDependency) {
                return;
              }
              if (attrName in this.components) {
                return;
              }
              this.initComponentDependencies(componentName);
              if (componentId && !COMPONENTS[componentName].multiple) {
                throw new Error("Trying to initialize multiple components of type `" + componentName + "`. There can only be one component of this type per entity.");
              }
              component = this.components[attrName] = new COMPONENTS[componentName].Component(
                this,
                data,
                componentId
              );
              if (this.isPlaying) {
                component.play();
              }
              if (!this.hasAttribute(attrName)) {
                component.justInitialized = true;
                HTMLElement.prototype.setAttribute.call(this, attrName, "");
              }
              debug("Component initialized: %s", attrName);
            },
            writable: window.debug
          },
          /**
           * Initialize dependencies of a component.
           *
           * @param {string} name - Root component name.
           */
          initComponentDependencies: {
            value: function(name) {
              var self2 = this;
              var component = COMPONENTS[name];
              var dependencies;
              if (!component) {
                return;
              }
              dependencies = COMPONENTS[name].dependencies;
              if (!dependencies) {
                return;
              }
              dependencies.forEach(function initializeDependency(componentName) {
                self2.initComponent(
                  componentName,
                  HTMLElement.prototype.getAttribute.call(self2, componentName) || void 0,
                  true
                );
              });
            }
          },
          removeComponent: {
            value: function(name) {
              var component;
              var isDefault;
              var isMixedIn;
              isDefault = name in this.defaultComponents;
              isMixedIn = isComponentMixedIn(name, this.mixinEls);
              if (isDefault || isMixedIn) {
                return;
              }
              component = this.components[name];
              component.pause();
              component.remove();
              delete this.components[name];
              this.emit("componentremoved", {
                id: component.id,
                name
              });
            }
          },
          /**
           * Initialize or update all components.
           * Build data using initial components, defined attributes, mixins, and defaults.
           * Update default components before the rest.
           *
           * @member {function} getExtraComponents - Can be implemented to include component data
           *   from other sources (e.g., implemented by primitives).
           */
          updateComponents: {
            value: function() {
              var componentsToUpdate = {};
              var extraComponents = {};
              var i;
              var self2 = this;
              if (!this.hasLoaded) {
                return;
              }
              getMixedInComponents(this).forEach(addComponent);
              if (this.getExtraComponents) {
                extraComponents = this.getExtraComponents();
                Object.keys(extraComponents).forEach(addComponent);
              }
              for (i = 0; i < this.attributes.length; ++i) {
                addComponent(this.attributes[i].name);
              }
              Object.keys(this.defaultComponents).forEach(doUpdateComponent);
              Object.keys(componentsToUpdate).forEach(doUpdateComponent);
              function addComponent(componentName) {
                var name = componentName.split(MULTIPLE_COMPONENT_DELIMITER)[0];
                if (!COMPONENTS[name]) {
                  return;
                }
                componentsToUpdate[componentName] = true;
              }
              function doUpdateComponent(name) {
                var data = mergeComponentData(self2.getDOMAttribute(name), extraComponents[name]);
                delete componentsToUpdate[name];
                self2.updateComponent(name, data);
              }
            }
          },
          /**
           * Initialize, update, or remove a single component.
           *
           * When initializing, we set the component on `this.components`.
           *
           * @param {string} attr - Component name.
           * @param {object} attrValue - The value of the DOM attribute.
           */
          updateComponent: {
            value: function(attr, attrValue) {
              var component = this.components[attr];
              var isDefault = attr in this.defaultComponents;
              if (component) {
                if (attrValue === null && !isDefault) {
                  this.removeComponent(attr);
                  return;
                }
                component.updateProperties(attrValue);
                return;
              }
              this.initComponent(attr, attrValue, false);
            }
          },
          /**
           * Updates one property of the component
           *
           * @param {string} name - Component name
           * @param {string} property - Component property name
           * @param {any} propertyValue - New property value
           */
          updateComponentProperty: {
            value: function(name, property, propertyValue) {
              var component = this.components[name];
              var attrValue = component && component.attrValue;
              var componentObj = attrValue ? utils.extend({}, attrValue) : {};
              componentObj[property] = propertyValue;
              this.updateComponent(name, componentObj);
            }
          },
          /**
           * If `attr` is a component name, removeAttribute detaches the component from the
           * entity.
           *
           * @param {string} attr - Attribute name, which could also be a component name.
           */
          removeAttribute: {
            value: function(attr) {
              var component = this.components[attr];
              if (component) {
                this.setEntityAttribute(attr, void 0, null);
                if (this.components[attr]) {
                  return;
                }
              }
              HTMLElement.prototype.removeAttribute.call(this, attr);
            }
          },
          /**
           * Start dynamic behavior associated with entity such as dynamic components and animations.
           * Tell all children entities to also play.
           */
          play: {
            value: function() {
              var components = this.components;
              var componentKeys = Object.keys(components);
              if (this.isPlaying || !this.hasLoaded) {
                return;
              }
              this.isPlaying = true;
              componentKeys.forEach(function playComponent(key) {
                components[key].play();
              });
              this.getChildEntities().forEach(function play(entity) {
                entity.play();
              });
              this.emit("play");
            },
            writable: true
          },
          /**
           * Pause dynamic behavior associated with entity such as dynamic components and animations.
           * Tell all children entities to also pause.
           */
          pause: {
            value: function() {
              var components = this.components;
              var componentKeys = Object.keys(components);
              if (!this.isPlaying) {
                return;
              }
              this.isPlaying = false;
              componentKeys.forEach(function pauseComponent(key) {
                components[key].pause();
              });
              this.getChildEntities().forEach(function pause(obj) {
                obj.pause();
              });
              this.emit("pause");
            },
            writable: true
          },
          /**
           * Deals with updates on entity-specific attributes (i.e., components and mixins).
           *
           * @param {string} attr
           * @param {string} oldVal
           * @param {string|object} newVal
           */
          setEntityAttribute: {
            value: function(attr, oldVal, newVal) {
              if (COMPONENTS[attr] || this.components[attr]) {
                this.updateComponent(attr, newVal);
                return;
              }
              if (attr === "mixin") {
                this.mixinUpdate(newVal, oldVal);
                return;
              }
            }
          },
          mixinUpdate: {
            value: function(newMixins, oldMixins) {
              oldMixins = oldMixins || this.getAttribute("mixin");
              this.updateStateMixins(newMixins, oldMixins);
              this.updateComponents();
            }
          },
          /**
           * setAttribute can:
           *
           * 1. Set a single property of a multi-property component.
           * 2. Set multiple properties of a multi-property component.
           * 3. Replace properties of a multi-property component.
           * 4. Set a value for a single-property component, mixin, or normal HTML attribute.
           *
           * @param {string} attrName - Component or attribute name.
           * @param {string|object} arg1 - Can be a property name or object of properties.
           * @param {string|bool} arg2 - Can be a value, or boolean indicating whether to update or
           *   replace.
           */
          setAttribute: {
            value: function(attrName, arg1, arg2) {
              var componentName;
              var isDebugMode;
              componentName = attrName.split(MULTIPLE_COMPONENT_DELIMITER)[0];
              if (COMPONENTS[componentName]) {
                if (typeof arg1 === "string" && typeof arg2 !== "undefined") {
                  singlePropertyUpdate(this, attrName, arg1, arg2);
                } else if (typeof arg1 === "object" && arg2 === true) {
                  multiPropertyClobber(this, attrName, arg1);
                } else {
                  componentUpdate(this, attrName, arg1);
                }
                isDebugMode = this.sceneEl && this.sceneEl.getAttribute("debug");
                if (isDebugMode) {
                  this.components[attrName].flushToDOM();
                }
                return;
              } else {
                normalSetAttribute(this, attrName, arg1);
              }
              function singlePropertyUpdate(el, componentName2, propName, propertyValue) {
                el.updateComponentProperty(componentName2, propName, propertyValue);
              }
              function componentUpdate(el, componentName2, propValue) {
                var component = el.components[componentName2];
                if (component && typeof propValue === "object") {
                  el.updateComponent(
                    componentName2,
                    utils.extendDeep(utils.extendDeep({}, component.data), propValue)
                  );
                } else {
                  el.updateComponent(componentName2, propValue);
                }
              }
              function multiPropertyClobber(el, componentName2, propObject) {
                el.updateComponent(componentName2, propObject);
              }
              function normalSetAttribute(el, attrName2, value) {
                ANode.prototype.setAttribute.call(el, attrName2, value);
                if (attrName2 === "mixin") {
                  el.mixinUpdate(value);
                }
              }
            },
            writable: window.debug
          },
          /**
           * Reflect component data in the DOM (as seen from the browser DOM Inspector).
           *
           * @param {bool} recursive - Also flushToDOM on the children.
           **/
          flushToDOM: {
            value: function(recursive) {
              var components = this.components;
              var defaultComponents = this.defaultComponents;
              var child;
              var children = this.children;
              var i;
              Object.keys(components).forEach(function flushComponent(componentName) {
                components[componentName].flushToDOM(componentName in defaultComponents);
              });
              if (!recursive) {
                return;
              }
              for (i = 0; i < children.length; ++i) {
                child = children[i];
                if (!child.flushToDOM) {
                  continue;
                }
                child.flushToDOM(recursive);
              }
            }
          },
          /**
           * If `attr` is a component, returns ALL component data including applied mixins and
           * defaults.
           *
           * If `attr` is not a component, fall back to HTML getAttribute.
           *
           * @param {string} attr
           * @returns {object|string} Object if component, else string.
           */
          getAttribute: {
            value: function(attr) {
              var component = this.components[attr];
              if (component) {
                return component.getData();
              }
              return HTMLElement.prototype.getAttribute.call(this, attr);
            },
            writable: window.debug
          },
          /**
           * `getAttribute` used to be `getDOMAttribute` and `getComputedAttribute` used to be
           * what `getAttribute` is now. Now legacy code.
           *
           * @param {string} attr
           * @returns {object|string} Object if component, else string.
           */
          getComputedAttribute: {
            value: function(attr) {
              warn("`getComputedAttribute` is deprecated. Use `getAttribute` instead.");
              return this.getAttribute(attr);
            }
          },
          /**
           * If `attr` is a component, returns JUST the component data defined on the entity.
           * Like a partial version of `getComputedAttribute` as returned component data
           * does not include applied mixins or defaults.
           *
           * If `attr` is not a component, fall back to HTML getAttribute.
           *
           * @param {string} attr
           * @returns {object|string} Object if component, else string.
           */
          getDOMAttribute: {
            value: function(attr) {
              var component = this.components[attr];
              if (component) {
                return component.attrValue;
              }
              return HTMLElement.prototype.getAttribute.call(this, attr);
            },
            writable: window.debug
          },
          addState: {
            value: function(state) {
              if (this.is(state)) {
                return;
              }
              this.states.push(state);
              this.mapStateMixins(state, bind(this.registerMixin, this));
              this.emit("stateadded", { state });
            }
          },
          removeState: {
            value: function(state) {
              var stateIndex = this.states.indexOf(state);
              if (stateIndex === -1) {
                return;
              }
              this.states.splice(stateIndex, 1);
              this.mapStateMixins(state, bind(this.unregisterMixin, this));
              this.emit("stateremoved", { state });
            }
          },
          /**
           * Checks if the element is in a given state. e.g. el.is('alive');
           * @type {string} state - Name of the state we want to check
           */
          is: {
            value: function(state) {
              return this.states.indexOf(state) !== -1;
            }
          }
        });
        function checkComponentDefined(el, name) {
          if (el.defaultComponents[name] !== void 0) {
            return true;
          }
          if (el.components[name] && el.components[name].attrValue) {
            return true;
          }
          return isComponentMixedIn(name, el.mixinEls);
        }
        function getMixedInComponents(entityEl) {
          var components = [];
          entityEl.mixinEls.forEach(function getMixedComponents(mixinEl) {
            Object.keys(mixinEl.componentCache).forEach(addComponent);
            function addComponent(key) {
              components.push(key);
            }
          });
          return components;
        }
        function isComponentMixedIn(name, mixinEls) {
          var i;
          var inMixin = false;
          for (i = 0; i < mixinEls.length; ++i) {
            inMixin = mixinEls[i].hasAttribute(name);
            if (inMixin) {
              break;
            }
          }
          return inMixin;
        }
        function mergeComponentData(attrValue, extraData) {
          if (!extraData) {
            return attrValue;
          }
          if (extraData.constructor === Object) {
            return utils.extend(extraData, utils.styleParser.parse(attrValue || {}));
          }
          return attrValue || extraData;
        }
        AEntity = registerElement("a-entity", {
          prototype: proto
        });
        module3.exports = AEntity;
      }, { "../lib/three": 106, "../utils/": 124, "./a-node": 61, "./a-register-element": 62, "./component": 63 }], 60: [function(_dereq_, module3, exports3) {
        var ANode = _dereq_("./a-node");
        var registerElement = _dereq_("./a-register-element").registerElement;
        var components = _dereq_("./component").components;
        var MULTIPLE_COMPONENT_DELIMITER = "__";
        module3.exports = registerElement("a-mixin", {
          prototype: Object.create(ANode.prototype, {
            createdCallback: {
              value: function() {
                this.componentCache = {};
                this.id = this.getAttribute("id");
              }
            },
            attributeChangedCallback: {
              value: function(attr, oldVal, newVal) {
                this.cacheAttribute(attr, newVal);
              }
            },
            attachedCallback: {
              value: function() {
                this.sceneEl = this.closestScene();
                this.cacheAttributes();
                this.updateEntities();
                this.load();
              }
            },
            /**
             * setAttribute that parses and caches component values.
             */
            setAttribute: {
              value: function(attr, value) {
                this.cacheAttribute(attr, value);
                HTMLElement.prototype.setAttribute.call(this, attr, value);
              }
            },
            /**
             * If `attr` is a component, then parse the value using the schema and store it.
             */
            cacheAttribute: {
              value: function(attr, value) {
                var componentName = attr.split(MULTIPLE_COMPONENT_DELIMITER)[0];
                var component = components[componentName];
                if (!component) {
                  return;
                }
                if (value === void 0) {
                  value = HTMLElement.prototype.getAttribute.call(this, attr);
                }
                this.componentCache[attr] = component.parseAttrValueForCache(value);
              }
            },
            /**
             * If `attr` is a component, then grab pre-parsed value from the cache.
             * Else do a normal getAttribute.
             */
            getAttribute: {
              value: function(attr) {
                return this.componentCache[attr] || HTMLElement.prototype.getAttribute.call(this, attr);
              }
            },
            /**
             * Parse and cache every component defined on the mixin.
             */
            cacheAttributes: {
              value: function() {
                var attributes = this.attributes;
                var attrName;
                var i;
                for (i = 0; i < attributes.length; i++) {
                  attrName = attributes[i].name;
                  this.cacheAttribute(attrName);
                }
              }
            },
            /**
             * For entities that already have been loaded by the time the mixin was attached, tell
             * those entities to register the mixin and refresh their component data.
             */
            updateEntities: {
              value: function() {
                if (!this.sceneEl) {
                  return;
                }
                var entities = this.sceneEl.querySelectorAll("[mixin~=" + this.id + "]");
                for (var i = 0; i < entities.length; i++) {
                  var entity = entities[i];
                  if (!entity.hasLoaded) {
                    continue;
                  }
                  entity.registerMixin(this.id);
                  Object.keys(this.componentCache).forEach(function updateComponent(componentName) {
                    entity.updateComponent(componentName);
                  });
                }
              }
            }
          })
        });
      }, { "./a-node": 61, "./a-register-element": 62, "./component": 63 }], 61: [function(_dereq_, module3, exports3) {
        var registerElement = _dereq_("./a-register-element").registerElement;
        var utils = _dereq_("../utils/");
        var bind = utils.bind;
        module3.exports = registerElement("a-node", {
          prototype: Object.create(HTMLElement.prototype, {
            createdCallback: {
              value: function() {
                this.hasLoaded = false;
                this.isNode = true;
                this.mixinEls = [];
                this.mixinObservers = {};
              },
              writable: window.debug
            },
            attachedCallback: {
              value: function() {
                var mixins;
                this.hasLoaded = false;
                this.sceneEl = this.closestScene();
                this.emit("nodeready", {}, false);
                mixins = this.getAttribute("mixin");
                if (mixins) {
                  this.updateMixins(mixins);
                }
              },
              writable: window.debug
            },
            attributeChangedCallback: {
              value: function(attr, oldVal, newVal) {
                if (attr === "mixin") {
                  this.updateMixins(newVal, oldVal);
                }
              }
            },
            /**
             * Returns the first scene by traversing up the tree starting from and
             * including receiver element.
             */
            closestScene: {
              value: function closest() {
                var element = this;
                while (element) {
                  if (element.isScene) {
                    break;
                  }
                  element = element.parentElement;
                }
                return element;
              }
            },
            /**
             * Returns first element matching a selector by traversing up the tree starting
             * from and including receiver element.
             *
             * @param {string} selector - Selector of element to find.
             */
            closest: {
              value: function closest(selector) {
                var matches = this.matches || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
                var element = this;
                while (element) {
                  if (matches.call(element, selector)) {
                    break;
                  }
                  element = element.parentElement;
                }
                return element;
              }
            },
            detachedCallback: {
              value: function() {
                this.hasLoaded = false;
              }
            },
            /**
             * Wait for children to load, if any.
             * Then emit `loaded` event and set `hasLoaded`.
             */
            load: {
              value: function(cb, childFilter) {
                var children;
                var childrenLoaded;
                var self2 = this;
                if (this.hasLoaded) {
                  return;
                }
                childFilter = childFilter || function(el) {
                  return el.isNode;
                };
                children = this.getChildren();
                childrenLoaded = children.filter(childFilter).map(function(child) {
                  return new Promise(function waitForLoaded(resolve) {
                    if (child.hasLoaded) {
                      return resolve();
                    }
                    child.addEventListener("loaded", resolve);
                  });
                });
                Promise.all(childrenLoaded).then(function emitLoaded() {
                  self2.hasLoaded = true;
                  if (cb) {
                    cb();
                  }
                  self2.emit("loaded", {}, false);
                });
              },
              writable: true
            },
            getChildren: {
              value: function() {
                return Array.prototype.slice.call(this.children, 0);
              }
            },
            updateMixins: {
              value: function(newMixins, oldMixins) {
                var newMixinsIds = newMixins.split(" ");
                var oldMixinsIds = oldMixins ? oldMixins.split(" ") : [];
                var diff = oldMixinsIds.filter(function(i) {
                  return newMixinsIds.indexOf(i) < 0;
                });
                this.mixinEls = [];
                diff.forEach(bind(this.unregisterMixin, this));
                newMixinsIds.forEach(bind(this.registerMixin, this));
              }
            },
            registerMixin: {
              value: function(mixinId) {
                if (!this.sceneEl) {
                  return;
                }
                var mixinEl = this.sceneEl.querySelector("a-mixin#" + mixinId);
                if (!mixinEl) {
                  return;
                }
                this.attachMixinListener(mixinEl);
                this.mixinEls.push(mixinEl);
              }
            },
            setAttribute: {
              value: function(attr, newValue) {
                if (attr === "mixin") {
                  this.updateMixins(newValue);
                }
                HTMLElement.prototype.setAttribute.call(this, attr, newValue);
              }
            },
            unregisterMixin: {
              value: function(mixinId) {
                var mixinEls = this.mixinEls;
                var mixinEl;
                var i;
                for (i = 0; i < mixinEls.length; ++i) {
                  mixinEl = mixinEls[i];
                  if (mixinId === mixinEl.id) {
                    mixinEls.splice(i, 1);
                    break;
                  }
                }
                this.removeMixinListener(mixinId);
              }
            },
            removeMixinListener: {
              value: function(mixinId) {
                var observer = this.mixinObservers[mixinId];
                if (!observer) {
                  return;
                }
                observer.disconnect();
                this.mixinObservers[mixinId] = null;
              }
            },
            attachMixinListener: {
              value: function(mixinEl) {
                var self2 = this;
                var mixinId = mixinEl.id;
                var currentObserver = this.mixinObservers[mixinId];
                if (!mixinEl) {
                  return;
                }
                if (currentObserver) {
                  return;
                }
                var observer = new MutationObserver(function(mutations) {
                  var attr = mutations[0].attributeName;
                  self2.handleMixinUpdate(attr);
                });
                var config = { attributes: true };
                observer.observe(mixinEl, config);
                this.mixinObservers[mixinId] = observer;
              }
            },
            handleMixinUpdate: {
              value: function() {
              }
            },
            /**
             * Emits a DOM event.
             *
             * @param {String} name
             *   Name of event (use a space-delimited string for multiple events).
             * @param {Object=} [detail={}]
             *   Custom data to pass as `detail` to the event.
             * @param {Boolean=} [bubbles=true]
             *   Whether the event should bubble.
             */
            emit: {
              value: function(name, detail, bubbles) {
                var self2 = this;
                detail = detail || {};
                if (bubbles === void 0) {
                  bubbles = true;
                }
                var data = { bubbles: !!bubbles, detail };
                return name.split(" ").map(function(eventName) {
                  return utils.fireEvent(self2, eventName, data);
                });
              }
            },
            /**
             * Returns a closure that emits a DOM event.
             *
             * @param {String} name
             *   Name of event (use a space-delimited string for multiple events).
             * @param {Object} detail
             *   Custom data (optional) to pass as `detail` if the event is to
             *   be a `CustomEvent`.
             * @param {Boolean} bubbles
             *   Whether the event should be bubble.
             */
            emitter: {
              value: function(name, detail, bubbles) {
                var self2 = this;
                return function() {
                  self2.emit(name, detail, bubbles);
                };
              }
            }
          })
        });
      }, { "../utils/": 124, "./a-register-element": 62 }], 62: [function(_dereq_, module3, exports3) {
        _dereq_("document-register-element");
        var ANode;
        var AEntity;
        var knownTags = module3.exports.knownTags = {};
        function addTagName(tagName) {
          knownTags[tagName.toLowerCase()] = true;
        }
        module3.exports.isNode = function(node) {
          return node.tagName.toLowerCase() in knownTags || node.isNode;
        };
        module3.exports.registerElement = function(tagName, obj) {
          var proto = Object.getPrototypeOf(obj.prototype);
          var newObj = obj;
          var isANode = ANode && proto === ANode.prototype;
          var isAEntity = AEntity && proto === AEntity.prototype;
          if (isANode || isAEntity) {
            addTagName(tagName);
          }
          if (isANode) {
            newObj = wrapANodeMethods(obj.prototype);
            newObj = { prototype: Object.create(proto, newObj) };
          }
          if (isAEntity) {
            newObj = wrapAEntityMethods(obj.prototype);
            newObj = { prototype: Object.create(proto, newObj) };
          }
          return document.registerElement(tagName, newObj);
        };
        function wrapANodeMethods(obj) {
          var newObj = {};
          var ANodeMethods = [
            "attachedCallback",
            "attributeChangedCallback",
            "createdCallback"
          ];
          wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
          copyProperties(obj, newObj);
          return newObj;
        }
        function wrapAEntityMethods(obj) {
          var newObj = {};
          var ANodeMethods = [
            "attachedCallback",
            "attributeChangedCallback",
            "createdCallback"
          ];
          var AEntityMethods = [
            "attachedCallback",
            "attributeChangedCallback",
            "createdCallback",
            "detachedCallback"
          ];
          wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
          wrapMethods(newObj, AEntityMethods, obj, AEntity.prototype);
          copyProperties(obj, newObj);
          return newObj;
        }
        function wrapMethods(targetObj, methodList, derivedObj, baseObj) {
          methodList.forEach(function(methodName) {
            wrapMethod(targetObj, methodName, derivedObj, baseObj);
          });
        }
        module3.exports.wrapMethods = wrapMethods;
        function wrapMethod(obj, methodName, derivedObj, baseObj) {
          var derivedMethod = derivedObj[methodName];
          var baseMethod = baseObj[methodName];
          if (!derivedMethod || !baseMethod) {
            return;
          }
          if (derivedMethod === baseMethod) {
            return;
          }
          obj[methodName] = {
            value: function wrappedMethod() {
              baseMethod.apply(this, arguments);
              return derivedMethod.apply(this, arguments);
            },
            writable: window.debug
          };
        }
        function copyProperties(source, destination) {
          var props = Object.getOwnPropertyNames(source);
          props.forEach(function(prop) {
            var desc;
            if (!destination[prop]) {
              desc = Object.getOwnPropertyDescriptor(source, prop);
              destination[prop] = { value: source[prop], writable: desc.writable };
            }
          });
        }
        ANode = _dereq_("./a-node");
        AEntity = _dereq_("./a-entity");
      }, { "./a-entity": 59, "./a-node": 61, "document-register-element": 8 }], 63: [function(_dereq_, module3, exports3) {
        var schema = _dereq_("./schema");
        var systems = _dereq_("./system");
        var utils = _dereq_("../utils/");
        var components = module3.exports.components = {};
        var parseProperties = schema.parseProperties;
        var parseProperty = schema.parseProperty;
        var processSchema = schema.process;
        var isSingleProp = schema.isSingleProperty;
        var stringifyProperties = schema.stringifyProperties;
        var stringifyProperty = schema.stringifyProperty;
        var styleParser = utils.styleParser;
        var Component = module3.exports.Component = function(el, attr, id) {
          this.el = el;
          this.id = id;
          this.attrName = this.name + (id ? "__" + id : "");
          this.updateCachedAttrValue(attr);
          if (!el.hasLoaded) {
            return;
          }
          this.updateProperties(this.attrValue);
        };
        Component.prototype = {
          /**
           * Contains the type schema and defaults for the data values.
           * Data is coerced into the types of the values of the defaults.
           */
          schema: {},
          /**
           * Init handler. Similar to attachedCallback.
           * Called during component initialization and is only run once.
           * Components can use this to set initial state.
           */
          init: function() {
          },
          /**
           * Update handler. Similar to attributeChangedCallback.
           * Called whenever component's data changes.
           * Also called on component initialization when the component receives initial data.
           *
           * @param {object} prevData - Previous attributes of the component.
           */
          update: function(prevData) {
          },
          updateSchema: void 0,
          /**
           * Tick handler.
           * Called on each tick of the scene render loop.
           * Affected by play and pause.
           *
           * @param {number} time - Scene tick time.
           * @param {number} timeDelta - Difference in current render time and previous render time.
           */
          tick: void 0,
          /**
           * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
           */
          play: function() {
          },
          /**
           * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
           */
          pause: function() {
          },
          /**
           * Remove handler. Similar to detachedCallback.
           * Called whenever component is removed from the entity (i.e., removeAttribute).
           * Components can use this to reset behavior on the entity.
           */
          remove: function() {
          },
          /**
           * Parses each property based on property type.
           * If component is single-property, then parses the single property value.
           *
           * @param {string} value - HTML attribute value.
           * @param {boolean} silent - Suppress warning messages.
           * @returns {object} Component data.
           */
          parse: function(value, silent) {
            var schema2 = this.schema;
            if (isSingleProp(schema2)) {
              return parseProperty(value, schema2);
            }
            return parseProperties(styleParser.parse(value), schema2, true, this.name, silent);
          },
          /**
           * Stringify properties if necessary.
           *
           * Only called from `Entity.setAttribute` for properties whose parsers accept a non-string
           * value (e.g., selector, vec3 property types).
           *
           * @param {object} data - Complete component data.
           * @returns {string}
           */
          stringify: function(data) {
            var schema2 = this.schema;
            if (typeof data === "string") {
              return data;
            }
            if (isSingleProp(schema2)) {
              return stringifyProperty(data, schema2);
            }
            data = stringifyProperties(data, schema2);
            return styleParser.stringify(data);
          },
          /**
           * Returns a copy of data such that we don't expose the private this.data.
           *
           * @returns {object} data
           */
          getData: function() {
            var data = this.data;
            if (typeof data !== "object") {
              return data;
            }
            return utils.extend({}, data);
          },
          /**
           * Update the cache of the pre-parsed attribute value.
           *
           * @param {string} value - HTML attribute value.
           */
          updateCachedAttrValue: function(value) {
            var isSinglePropSchema = isSingleProp(this.schema);
            var attrValue = this.parseAttrValueForCache(value);
            this.attrValue = extendProperties({}, attrValue, isSinglePropSchema);
          },
          /**
           * Given an HTML attribute value parses the string
           * based on the component schema. To avoid double parsings of
           * strings into strings we store the original instead
           * of the parsed one
           *
           * @param {string} value - HTML attribute value
           */
          parseAttrValueForCache: function(value) {
            var parsedValue;
            if (typeof value !== "string") {
              return value;
            }
            if (isSingleProp(this.schema)) {
              parsedValue = this.schema.parse(value);
              if (typeof parsedValue === "string") {
                parsedValue = value;
              }
            } else {
              parsedValue = styleParser.parse(value);
            }
            return parsedValue;
          },
          /**
           * Write cached attribute data to the entity DOM element.
           *
           * @param {bool} isDefault - Whether component is a default component. Always flush for
           *   default components.
           */
          flushToDOM: function(isDefault) {
            var attrValue = isDefault ? this.data : this.attrValue;
            if (!attrValue) {
              return;
            }
            HTMLElement.prototype.setAttribute.call(
              this.el,
              this.attrName,
              this.stringify(attrValue)
            );
          },
          /**
           * Apply new component data if data has changed.
           *
           * @param {string} value - HTML attribute value.
           *        If undefined, use the cached attribute value and continue updating properties.
           */
          updateProperties: function(value) {
            var el = this.el;
            var isSinglePropSchema = isSingleProp(this.schema);
            var oldData = extendProperties({}, this.data, isSinglePropSchema);
            if (value !== void 0) {
              this.updateCachedAttrValue(value);
            }
            if (this.updateSchema) {
              this.updateSchema(buildData(el, this.name, this.attrName, this.schema, this.attrValue, true));
            }
            this.data = buildData(el, this.name, this.attrName, this.schema, this.attrValue);
            if (!isSinglePropSchema && utils.deepEqual(oldData, this.data)) {
              return;
            }
            if (!this.initialized) {
              this.init();
              this.initialized = true;
              this.update(oldData);
              if (el.isPlaying) {
                this.play();
              }
              el.emit("componentinitialized", {
                id: this.id,
                name: this.name,
                data: this.getData()
              }, false);
            } else {
              this.update(oldData);
              el.emit("componentchanged", {
                id: this.id,
                name: this.name,
                newData: this.getData(),
                oldData
              }, false);
            }
          },
          /**
           * Extend schema of component given a partial schema.
           *
           * Some components might want to mutate their schema based on certain properties.
           * e.g., Material component changes its schema based on `shader` to account for different
           * uniforms
           *
           * @param {object} schemaAddon - Schema chunk that extend base schema.
           */
          extendSchema: function(schemaAddon) {
            var extendedSchema = utils.extend({}, components[this.name].schema);
            utils.extend(extendedSchema, schemaAddon);
            this.schema = processSchema(extendedSchema);
            this.el.emit("schemachanged", { component: this.name });
          }
        };
        module3.exports.registerComponent = function(name, definition) {
          var NewComponent;
          var proto = {};
          if (name.indexOf("__") !== -1) {
            throw new Error("The component name `" + name + "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");
          }
          Object.keys(definition).forEach(function(key) {
            proto[key] = {
              value: definition[key],
              writable: true
            };
          });
          if (components[name]) {
            throw new Error("The component `" + name + "` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");
          }
          NewComponent = function(el, attr, id) {
            Component.call(this, el, attr, id);
          };
          NewComponent.prototype = Object.create(Component.prototype, proto);
          NewComponent.prototype.name = name;
          NewComponent.prototype.constructor = NewComponent;
          NewComponent.prototype.system = systems && systems.systems[name];
          NewComponent.prototype.play = wrapPlay(NewComponent.prototype.play);
          NewComponent.prototype.pause = wrapPause(NewComponent.prototype.pause);
          components[name] = {
            Component: NewComponent,
            dependencies: NewComponent.prototype.dependencies,
            isSingleProp: isSingleProp(NewComponent.prototype.schema),
            multiple: NewComponent.prototype.multiple,
            parse: NewComponent.prototype.parse,
            parseAttrValueForCache: NewComponent.prototype.parseAttrValueForCache,
            schema: utils.extend(processSchema(NewComponent.prototype.schema)),
            stringify: NewComponent.prototype.stringify,
            type: NewComponent.prototype.type
          };
          return NewComponent;
        };
        function buildData(el, name, attrName, schema2, elData, silent) {
          var componentDefined = elData !== void 0 && elData !== null;
          var data;
          var isSinglePropSchema = isSingleProp(schema2);
          var mixinEls = el.mixinEls;
          if (isSinglePropSchema) {
            data = schema2.default;
          } else {
            data = {};
            Object.keys(schema2).forEach(function applyDefault(key) {
              var defaultValue = schema2[key].default;
              data[key] = defaultValue && defaultValue.constructor === Object ? utils.extend({}, defaultValue) : defaultValue;
            });
          }
          mixinEls.forEach(handleMixinUpdate);
          function handleMixinUpdate(mixinEl) {
            var mixinData = mixinEl.getAttribute(attrName);
            if (mixinData) {
              data = extendProperties(data, mixinData, isSinglePropSchema);
            }
          }
          if (componentDefined) {
            if (isSinglePropSchema) {
              return parseProperty(elData, schema2);
            }
            data = extendProperties(data, elData, isSinglePropSchema);
            return parseProperties(data, schema2, void 0, name, silent);
          } else {
            if (isSinglePropSchema) {
              return parseProperty(data, schema2);
            }
            return parseProperties(data, schema2, void 0, name, silent);
          }
        }
        module3.exports.buildData = buildData;
        function extendProperties(dest, source, isSinglePropSchema) {
          if (isSinglePropSchema) {
            return source;
          }
          return utils.extend(dest, source);
        }
        function wrapPause(pauseMethod) {
          return function pause() {
            var sceneEl = this.el.sceneEl;
            if (!this.isPlaying) {
              return;
            }
            pauseMethod.call(this);
            this.isPlaying = false;
            if (!this.tick) {
              return;
            }
            sceneEl.removeBehavior(this);
          };
        }
        function wrapPlay(playMethod) {
          return function play() {
            var sceneEl = this.el.sceneEl;
            var shouldPlay = this.el.isPlaying && !this.isPlaying;
            if (!this.initialized || !shouldPlay) {
              return;
            }
            playMethod.call(this);
            this.isPlaying = true;
            if (!this.tick) {
              return;
            }
            sceneEl.addBehavior(this);
          };
        }
      }, { "../utils/": 124, "./schema": 70, "./system": 72 }], 64: [function(_dereq_, module3, exports3) {
        var schema = _dereq_("./schema");
        var processSchema = schema.process;
        var geometries = module3.exports.geometries = {};
        var geometryNames = module3.exports.geometryNames = [];
        var THREE2 = _dereq_("../lib/three");
        var Geometry = module3.exports.Geometry = function() {
        };
        Geometry.prototype = {
          /**
           * Contains the type schema and defaults for the data values.
           * Data is coerced into the types of the values of the defaults.
           */
          schema: {},
          /**
           * Init handler. Similar to attachedCallback.
           * Called during shader initialization and is only run once.
           */
          init: function(data) {
            this.geometry = new THREE2.Geometry();
            return this.geometry;
          },
          /**
           * Update handler. Similar to attributeChangedCallback.
           * Called whenever the associated geometry data changes.
           *
           * @param {object} data - New geometry data.
           */
          update: function(data) {
          }
        };
        module3.exports.registerGeometry = function(name, definition) {
          var NewGeometry;
          var proto = {};
          Object.keys(definition).forEach(function expandDefinition(key) {
            proto[key] = {
              value: definition[key],
              writable: true
            };
          });
          if (geometries[name]) {
            throw new Error("The geometry `" + name + "` has been already registered");
          }
          NewGeometry = function() {
            Geometry.call(this);
          };
          NewGeometry.prototype = Object.create(Geometry.prototype, proto);
          NewGeometry.prototype.name = name;
          NewGeometry.prototype.constructor = NewGeometry;
          geometries[name] = {
            Geometry: NewGeometry,
            schema: processSchema(NewGeometry.prototype.schema)
          };
          geometryNames.push(name);
          return NewGeometry;
        };
      }, { "../lib/three": 106, "./schema": 70 }], 65: [function(_dereq_, module3, exports3) {
        var coordinates = _dereq_("../utils/coordinates");
        var debug = _dereq_("debug");
        var error = debug("core:propertyTypes:warn");
        var warn = debug("core:propertyTypes:warn");
        var propertyTypes = module3.exports.propertyTypes = {};
        registerPropertyType("audio", "", assetParse);
        registerPropertyType("array", [], arrayParse, arrayStringify);
        registerPropertyType("asset", "", assetParse);
        registerPropertyType("boolean", false, boolParse);
        registerPropertyType("color", "#FFF", defaultParse, defaultStringify);
        registerPropertyType("int", 0, intParse);
        registerPropertyType("number", 0, numberParse);
        registerPropertyType("map", "", assetParse);
        registerPropertyType("model", "", assetParse);
        registerPropertyType("selector", "", selectorParse, selectorStringify);
        registerPropertyType("selectorAll", "", selectorAllParse, selectorAllStringify);
        registerPropertyType("src", "", srcParse);
        registerPropertyType("string", "", defaultParse, defaultStringify);
        registerPropertyType("time", 0, intParse);
        registerPropertyType("vec2", { x: 0, y: 0 }, vecParse, coordinates.stringify);
        registerPropertyType("vec3", { x: 0, y: 0, z: 0 }, vecParse, coordinates.stringify);
        registerPropertyType("vec4", { x: 0, y: 0, z: 0, w: 0 }, vecParse, coordinates.stringify);
        function registerPropertyType(type, defaultValue, parse, stringify) {
          if ("type" in propertyTypes) {
            error("Property type " + type + " is already registered.");
            return;
          }
          propertyTypes[type] = {
            default: defaultValue,
            parse: parse || defaultParse,
            stringify: stringify || defaultStringify
          };
        }
        module3.exports.registerPropertyType = registerPropertyType;
        function arrayParse(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (!value || typeof value !== "string") {
            return [];
          }
          return value.split(",").map(trim);
          function trim(str) {
            return str.trim();
          }
        }
        function arrayStringify(value) {
          return value.join(", ");
        }
        function assetParse(value) {
          var el;
          var parsedUrl;
          parsedUrl = value.match(/\url\((.+)\)/);
          if (parsedUrl) {
            return parsedUrl[1];
          }
          if (value.charAt(0) === "#") {
            el = selectorParse(value);
            if (el) {
              if (el.tagName === "CANVAS" || el.tagName === "VIDEO") {
                return el;
              }
              return el.getAttribute("src");
            }
            warn('"' + value + '" asset not found.');
            return;
          }
          return value;
        }
        function defaultParse(value) {
          return value;
        }
        function defaultStringify(value) {
          if (value === null) {
            return "null";
          }
          return value.toString();
        }
        function boolParse(value) {
          return value !== "false" && value !== false;
        }
        function intParse(value) {
          return parseInt(value, 10);
        }
        function numberParse(value) {
          return parseFloat(value, 10);
        }
        function selectorParse(value) {
          if (!value) {
            return null;
          }
          if (typeof value !== "string") {
            return value;
          }
          return document.querySelector(value);
        }
        function selectorAllParse(value) {
          if (!value) {
            return null;
          }
          if (typeof value !== "string") {
            return value;
          }
          return Array.prototype.slice.call(document.querySelectorAll(value), 0);
        }
        function selectorStringify(value) {
          if (value.getAttribute) {
            return "#" + value.getAttribute("id");
          }
          return defaultStringify(value);
        }
        function selectorAllStringify(value) {
          if (value instanceof Array) {
            return value.map(function(element) {
              return "#" + element.getAttribute("id");
            }).join(", ");
          }
          return defaultStringify(value);
        }
        function srcParse(value) {
          warn("`src` property type is deprecated. Use `asset` instead.");
          return assetParse(value);
        }
        function vecParse(value) {
          return coordinates.parse(value, this.default);
        }
      }, { "../utils/coordinates": 119, "debug": 3 }], 66: [function(_dereq_, module3, exports3) {
        var initMetaTags = _dereq_("./metaTags").inject;
        var initWakelock = _dereq_("./wakelock");
        var re = _dereq_("../a-register-element");
        var systems = _dereq_("../system").systems;
        var THREE2 = _dereq_("../../lib/three");
        var TWEEN = _dereq_("tween.js");
        var utils = _dereq_("../../utils/");
        var AEntity = _dereq_("../a-entity");
        var ANode = _dereq_("../a-node");
        var initPostMessageAPI = _dereq_("./postMessage");
        var bind = utils.bind;
        var checkHeadsetConnected = utils.device.checkHeadsetConnected;
        var isIOS = utils.device.isIOS();
        var isMobile = utils.device.isMobile();
        var registerElement = re.registerElement;
        var warn = utils.debug("core:a-scene:warn");
        module3.exports = registerElement("a-scene", {
          prototype: Object.create(AEntity.prototype, {
            defaultComponents: {
              value: {
                "canvas": "",
                "inspector": "",
                "keyboard-shortcuts": "",
                "screenshot": "",
                "vr-mode-ui": "",
                "auto-enter-vr": ""
              }
            },
            createdCallback: {
              value: function() {
                this.isIOS = isIOS;
                this.isMobile = isMobile;
                this.isScene = true;
                this.object3D = new THREE2.Scene();
                this.render = bind(this.render, this);
                this.systems = {};
                this.time = 0;
                this.init();
              }
            },
            init: {
              value: function() {
                this.behaviors = [];
                this.hasLoaded = false;
                this.isPlaying = false;
                this.originalHTML = this.innerHTML;
                this.addEventListener("render-target-loaded", function() {
                  this.setupRenderer();
                  this.resize();
                });
                this.addFullScreenStyles();
                initPostMessageAPI(this);
              },
              writable: true
            },
            addFullScreenStyles: {
              value: function() {
                var htmlEl = document.documentElement;
                htmlEl.classList.add("a-html");
                document.body.classList.add("a-body");
                this.classList.add("fullscreen");
              }
            },
            removeFullScreenStyles: {
              value: function() {
                var htmlEl = document.documentElement;
                htmlEl.classList.remove("a-html");
                document.body.classList.remove("a-body");
                this.classList.remove("fullscreen");
              }
            },
            attachedCallback: {
              value: function() {
                var resize = bind(this.resize, this);
                initMetaTags(this);
                initWakelock(this);
                this.initSystems();
                window.addEventListener("load", resize);
                window.addEventListener("resize", resize);
                this.play();
              },
              writable: window.debug
            },
            initSystems: {
              value: function() {
                Object.keys(systems).forEach(bind(this.initSystem, this));
              }
            },
            initSystem: {
              value: function(name) {
                var system;
                if (this.systems[name]) {
                  return;
                }
                system = this.systems[name] = new systems[name](this);
                system.init();
              }
            },
            /**
             * Shuts down scene on detach.
             */
            detachedCallback: {
              value: function() {
                window.cancelAnimationFrame(this.animationFrameID);
                this.animationFrameID = null;
              }
            },
            /**
             * @param {object} behavior - Generally a component. Must implement a .update() method to
             *        be called on every tick.
             */
            addBehavior: {
              value: function(behavior) {
                var behaviors = this.behaviors;
                if (behaviors.indexOf(behavior) !== -1) {
                  return;
                }
                behaviors.push(behavior);
              }
            },
            enterVR: {
              value: function(event) {
                var self2 = this;
                if (this.is("vr-mode")) {
                  return;
                }
                if (checkHeadsetConnected() || this.isMobile) {
                  return this.effect.requestPresent().then(enterVRSuccess, enterVRFailure);
                }
                enterVRSuccess();
                function enterVRSuccess() {
                  self2.addState("vr-mode");
                  self2.emit("enter-vr", event);
                  if (self2.isMobile && screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock("landscape");
                  }
                  self2.addFullScreenStyles();
                  if (!self2.isMobile && !checkHeadsetConnected()) {
                    requestFullscreen(self2.canvas);
                  }
                  self2.resize();
                }
                function enterVRFailure(err) {
                  if (err && err.message) {
                    throw new Error("Failed to enter VR mode (`requestPresent`): " + err.message);
                  } else {
                    throw new Error("Failed to enter VR mode (`requestPresent`).");
                  }
                }
              }
            },
            exitVR: {
              value: function() {
                var self2 = this;
                if (!this.is("vr-mode")) {
                  return Promise.resolve();
                }
                if (checkHeadsetConnected() || this.isMobile) {
                  return this.effect.exitPresent().then(exitVRSuccess, exitVRFailure);
                }
                exitVRSuccess();
                function exitVRSuccess() {
                  var embedded = self2.getAttribute("embedded");
                  self2.removeState("vr-mode");
                  if (self2.isMobile && screen.orientation && screen.orientation.unlock) {
                    screen.orientation.unlock();
                  }
                  if (embedded) {
                    self2.removeFullScreenStyles();
                  }
                  self2.resize();
                  if (self2.isIOS) {
                    utils.forceCanvasResizeSafariMobile(this.canvas);
                  }
                  self2.emit("exit-vr", { target: self2 });
                }
                function exitVRFailure(err) {
                  if (err && err.message) {
                    throw new Error("Failed to exit VR mode (`exitPresent`): " + err.message);
                  } else {
                    throw new Error("Failed to exit VR mode (`exitPresent`).");
                  }
                }
              }
            },
            /**
             * Wraps Entity.getAttribute to take into account for systems.
             * If system exists, then return system data rather than possible component data.
             */
            getAttribute: {
              value: function(attr) {
                var system = this.systems[attr];
                if (system) {
                  return system.data;
                }
                return AEntity.prototype.getAttribute.call(this, attr);
              }
            },
            /**
             * `getAttribute` used to be `getDOMAttribute` and `getComputedAttribute` used to be
             * what `getAttribute` is now. Now legacy code.
             */
            getComputedAttribute: {
              value: function(attr) {
                warn("`getComputedAttribute` is deprecated. Use `getAttribute` instead.");
                this.getAttribute(attr);
              }
            },
            /**
             * Wraps Entity.getDOMAttribute to take into account for systems.
             * If system exists, then return system data rather than possible component data.
             */
            getDOMAttribute: {
              value: function(attr) {
                var system = this.systems[attr];
                if (system) {
                  return system.data;
                }
                return AEntity.prototype.getDOMAttribute.call(this, attr);
              }
            },
            /**
             * Wraps Entity.setAttribute to take into account for systems.
             * If system exists, then skip component initialization checks and do a normal
             * setAttribute.
             */
            setAttribute: {
              value: function(attr, value, componentPropValue) {
                var system = this.systems[attr];
                if (system) {
                  ANode.prototype.setAttribute.call(this, attr, value);
                  return;
                }
                AEntity.prototype.setAttribute.call(this, attr, value, componentPropValue);
              }
            },
            /**
             * @param {object} behavior - Generally a component. Has registered itself to behaviors.
             */
            removeBehavior: {
              value: function(behavior) {
                var behaviors = this.behaviors;
                var index = behaviors.indexOf(behavior);
                if (index === -1) {
                  return;
                }
                behaviors.splice(index, 1);
              }
            },
            resize: {
              value: function() {
                var camera = this.camera;
                var canvas = this.canvas;
                var embedded = this.getAttribute("embedded") && !this.is("vr-mode");
                var size;
                if (!camera || !canvas || this.is("vr-mode") && isMobile) {
                  return;
                }
                size = getCanvasSize(canvas, embedded);
                camera.aspect = size.width / size.height;
                camera.updateProjectionMatrix();
                this.renderer.setSize(size.width, size.height);
              },
              writable: window.debug
            },
            setupRenderer: {
              value: function() {
                var canvas = this.canvas;
                var antialias = this.getAttribute("antialias") === "true";
                var renderer = this.renderer = new THREE2.WebGLRenderer({
                  canvas,
                  antialias: antialias || window.hasNativeWebVRImplementation,
                  alpha: true
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.sortObjects = false;
                this.effect = new THREE2.VREffect(renderer);
              },
              writable: window.debug
            },
            /**
             * Handler attached to elements to help scene know when to kick off.
             * Scene waits for all entities to load.
             */
            play: {
              value: function() {
                var self2 = this;
                if (this.renderStarted) {
                  AEntity.prototype.play.call(this);
                  return;
                }
                this.addEventListener("loaded", function() {
                  AEntity.prototype.play.call(this);
                  if (this.camera) {
                    startRender(this);
                    return;
                  }
                  this.addEventListener("camera-set-active", function() {
                    startRender(this);
                  });
                  function startRender(sceneEl) {
                    if (sceneEl.renderStarted) {
                      return;
                    }
                    sceneEl.resize();
                    if (sceneEl.renderer) {
                      if (window.performance) {
                        window.performance.mark("render-started");
                      }
                      sceneEl.render(0);
                      sceneEl.renderStarted = true;
                      sceneEl.emit("renderstart");
                    }
                  }
                });
                setTimeout(function() {
                  AEntity.prototype.load.call(self2);
                });
              }
            },
            /**
             * Reload the scene to the original DOM content.
             *
             * @param {bool} doPause - Whether to reload the scene with all dynamic behavior paused.
             */
            reload: {
              value: function(doPause) {
                var self2 = this;
                if (doPause) {
                  this.pause();
                }
                this.innerHTML = this.originalHTML;
                this.init();
                ANode.prototype.load.call(this, play);
                function play() {
                  if (!self2.isPlaying) {
                    return;
                  }
                  AEntity.prototype.play.call(self2);
                }
              }
            },
            /**
             * Behavior-updater meant to be called from scene render.
             * Abstracted to a different function to facilitate unit testing (`scene.tick()`) without
             * needing to render.
             */
            tick: {
              value: function(time, timeDelta) {
                var systems2 = this.systems;
                TWEEN.update(time);
                this.behaviors.forEach(function(component) {
                  if (!component.el.isPlaying) {
                    return;
                  }
                  component.tick(time, timeDelta);
                });
                Object.keys(systems2).forEach(function(key) {
                  if (!systems2[key].tick) {
                    return;
                  }
                  systems2[key].tick(time, timeDelta);
                });
              }
            },
            /**
             * The render loop.
             *
             * Updates animations.
             * Updates behaviors.
             * Renders with request animation frame.
             */
            render: {
              value: function(time) {
                var effect = this.effect;
                var timeDelta = time - this.time;
                if (this.isPlaying) {
                  this.tick(time, timeDelta);
                }
                this.animationFrameID = effect.requestAnimationFrame(this.render);
                effect.render(this.object3D, this.camera);
                this.time = time;
              },
              writable: true
            }
          })
        });
        function getCanvasSize(canvasEl, embedded) {
          if (embedded) {
            return {
              height: canvasEl.parentElement.offsetHeight,
              width: canvasEl.parentElement.offsetWidth
            };
          }
          return {
            height: window.innerHeight,
            width: window.innerWidth
          };
        }
        function requestFullscreen(canvas) {
          var requestFullscreen2 = canvas.requestFullscreen || canvas.webkitRequestFullscreen || canvas.mozRequestFullScreen || // The capitalized `S` is not a typo.
          canvas.msRequestFullscreen;
          requestFullscreen2.apply(canvas);
        }
      }, { "../../lib/three": 106, "../../utils/": 124, "../a-entity": 59, "../a-node": 61, "../a-register-element": 62, "../system": 72, "./metaTags": 67, "./postMessage": 68, "./wakelock": 69, "tween.js": 18 }], 67: [function(_dereq_, module3, exports3) {
        var constants = _dereq_("../../constants/");
        var extend = _dereq_("../../utils").extend;
        var MOBILE_HEAD_TAGS = module3.exports.MOBILE_HEAD_TAGS = [
          Meta({ name: "viewport", content: "width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui" }),
          // W3C-standardised meta tags.
          Meta({ name: "mobile-web-app-capable", content: "yes" }),
          Meta({ name: "theme-color", content: "black" })
        ];
        var MOBILE_IOS_HEAD_TAGS = [
          // iOS-specific meta tags for fullscreen when pinning to homescreen.
          Meta({ name: "apple-mobile-web-app-capable", content: "yes" }),
          Meta({ name: "apple-mobile-web-app-status-bar-style", content: "black" }),
          Link({ rel: "apple-touch-icon", href: "https://aframe.io/images/aframe-logo-152.png" })
        ];
        function Meta(attrs) {
          return {
            tagName: "meta",
            attributes: attrs,
            exists: function() {
              return document.querySelector('meta[name="' + attrs.name + '"]');
            }
          };
        }
        function Link(attrs) {
          return {
            tagName: "link",
            attributes: attrs,
            exists: function() {
              return document.querySelector('link[rel="' + attrs.rel + '"]');
            }
          };
        }
        module3.exports.inject = function injectHeadTags(scene) {
          var headEl = document.head;
          var headScriptEl = headEl.querySelector("script");
          var tag;
          var headTags = [];
          MOBILE_HEAD_TAGS.forEach(createAndInjectTag);
          if (scene.isIOS) {
            MOBILE_IOS_HEAD_TAGS.forEach(createAndInjectTag);
          }
          return headTags;
          function createAndInjectTag(tagObj) {
            if (!tagObj || tagObj.exists()) {
              return;
            }
            tag = createTag(tagObj);
            if (!tag) {
              return;
            }
            if (headScriptEl) {
              headScriptEl.parentNode.insertBefore(tag, headScriptEl);
            } else {
              headEl.appendChild(tag);
            }
            headTags.push(tag);
          }
        };
        function createTag(tagObj) {
          if (!tagObj || !tagObj.tagName) {
            return;
          }
          var meta = document.createElement(tagObj.tagName);
          meta.setAttribute(constants.AFRAME_INJECTED, "");
          return extend(meta, tagObj.attributes);
        }
      }, { "../../constants/": 54, "../../utils": 124 }], 68: [function(_dereq_, module3, exports3) {
        var bind = _dereq_("../../utils/bind");
        var isIframed = _dereq_("../../utils/").isIframed;
        module3.exports = function initPostMessageAPI(scene) {
          if (!isIframed()) {
            return;
          }
          window.addEventListener("message", bind(postMessageAPIHandler, scene));
        };
        function postMessageAPIHandler(event) {
          var scene = this;
          if (!event.data) {
            return;
          }
          switch (event.data.type) {
            case "vr": {
              switch (event.data.data) {
                case "enter":
                  scene.enterVR();
                  break;
                case "exit":
                  scene.exitVR();
                  break;
              }
            }
          }
        }
      }, { "../../utils/": 124, "../../utils/bind": 118 }], 69: [function(_dereq_, module3, exports3) {
        var Wakelock = _dereq_("../../../vendor/wakelock/wakelock");
        module3.exports = function initWakelock(scene) {
          if (!scene.isMobile) {
            return;
          }
          var wakelock = scene.wakelock = new Wakelock();
          scene.addEventListener("enter-vr", function() {
            wakelock.request();
          });
          scene.addEventListener("exit-vr", function() {
            wakelock.release();
          });
        };
      }, { "../../../vendor/wakelock/wakelock": 134 }], 70: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("../utils/debug");
        var propertyTypes = _dereq_("./propertyTypes").propertyTypes;
        var warn = debug("core:schema:warn");
        function isSingleProperty(schema) {
          if ("type" in schema) {
            return typeof schema.type === "string";
          }
          return "default" in schema;
        }
        module3.exports.isSingleProperty = isSingleProperty;
        module3.exports.process = function(schema) {
          if (isSingleProperty(schema)) {
            return processPropertyDefinition(schema);
          }
          Object.keys(schema).forEach(function(propName) {
            schema[propName] = processPropertyDefinition(schema[propName]);
          });
          return schema;
        };
        function processPropertyDefinition(propDefinition) {
          var defaultVal = propDefinition.default;
          var propType;
          var typeName = propDefinition.type;
          if (!propDefinition.type) {
            if (defaultVal !== void 0 && ["boolean", "number"].indexOf(typeof defaultVal) !== -1) {
              typeName = typeof defaultVal;
            } else if (Array.isArray(defaultVal)) {
              typeName = "array";
            } else {
              typeName = "string";
            }
          } else if (propDefinition.type === "bool") {
            typeName = "boolean";
          } else if (propDefinition.type === "float") {
            typeName = "number";
          }
          propType = propertyTypes[typeName];
          if (!propType) {
            warn("Unknown property type: " + typeName);
          }
          propDefinition.parse = propDefinition.parse || propType.parse;
          propDefinition.stringify = propDefinition.stringify || propType.stringify;
          propDefinition.type = typeName;
          if (!("default" in propDefinition)) {
            propDefinition.default = propType.default;
          }
          return propDefinition;
        }
        module3.exports.processPropertyDefinition = processPropertyDefinition;
        module3.exports.parseProperties = function(propData, schema, getPartialData, componentName, silent) {
          var propNames = Object.keys(getPartialData ? propData : schema);
          if (propData === null || typeof propData !== "object") {
            return propData;
          }
          Object.keys(propData).forEach(function(propName) {
            if (!schema[propName] && !silent) {
              warn("Unknown property `" + propName + "` for component/system `" + componentName + "`.");
            }
          });
          propNames.forEach(function parse(propName) {
            var propDefinition = schema[propName];
            var propValue = propData[propName];
            if (!schema[propName]) {
              return;
            }
            propData[propName] = parseProperty(propValue, propDefinition);
          });
          return propData;
        };
        function parseProperty(value, propDefinition) {
          if (value === void 0 || value === null || value === "") {
            value = propDefinition.default;
          }
          return propDefinition.parse(value, propDefinition.default);
        }
        module3.exports.parseProperty = parseProperty;
        module3.exports.stringifyProperties = function(propData, schema) {
          var stringifiedData = {};
          Object.keys(propData).forEach(function(propName) {
            var propDefinition = schema[propName];
            var propValue = propData[propName];
            var value = propValue;
            if (typeof value === "object") {
              value = stringifyProperty(propValue, propDefinition);
              if (!propDefinition) {
                warn("Unknown component property: " + propName);
              }
            }
            stringifiedData[propName] = value;
          });
          return stringifiedData;
        };
        function stringifyProperty(value, propDefinition) {
          if (typeof value !== "object") {
            return value;
          }
          if (!propDefinition || value === null) {
            return JSON.stringify(value);
          }
          return propDefinition.stringify(value);
        }
        module3.exports.stringifyProperty = stringifyProperty;
      }, { "../utils/debug": 120, "./propertyTypes": 65 }], 71: [function(_dereq_, module3, exports3) {
        var schema = _dereq_("./schema");
        var processSchema = schema.process;
        var shaders = module3.exports.shaders = {};
        var shaderNames = module3.exports.shaderNames = [];
        var THREE2 = _dereq_("../lib/three");
        var propertyToThreeMapping = {
          array: "v3",
          color: "v3",
          int: "i",
          number: "f",
          map: "t",
          time: "f",
          vec2: "v2",
          vec3: "v3",
          vec4: "v4"
        };
        var Shader = module3.exports.Shader = function() {
        };
        Shader.prototype = {
          /**
           * Contains the type schema and defaults for the data values.
           * Data is coerced into the types of the values of the defaults.
           */
          schema: {},
          vertexShader: "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
          fragmentShader: "void main() {gl_FragColor = vec4(1.0,0.0,1.0,1.0);}",
          /**
           * Init handler. Similar to attachedCallback.
           * Called during shader initialization and is only run once.
           */
          init: function(data) {
            this.attributes = this.initVariables(data, "attribute");
            this.uniforms = this.initVariables(data, "uniform");
            this.material = new THREE2.ShaderMaterial({
              // attributes: this.attributes,
              uniforms: this.uniforms,
              vertexShader: this.vertexShader,
              fragmentShader: this.fragmentShader
            });
            return this.material;
          },
          initVariables: function(data, type) {
            var self2 = this;
            var variables = {};
            var schema2 = this.schema;
            var schemaKeys = Object.keys(schema2);
            schemaKeys.forEach(processSchema2);
            function processSchema2(key) {
              if (schema2[key].is !== type) {
                return;
              }
              var varType = propertyToThreeMapping[schema2[key].type];
              var varValue = schema2[key].parse(data[key] || schema2[key].default);
              variables[key] = {
                type: varType,
                value: self2.parseValue(schema2[key].type, varValue)
              };
            }
            return variables;
          },
          /**
           * Update handler. Similar to attributeChangedCallback.
           * Called whenever the associated material data changes.
           *
           * @param {object} data - New material data.
           */
          update: function(data) {
            this.updateVariables(data, "attribute");
            this.updateVariables(data, "uniform");
          },
          updateVariables: function(data, type) {
            var self2 = this;
            var variables = type === "uniform" ? this.uniforms : this.attributes;
            var dataKeys = Object.keys(data);
            var schema2 = this.schema;
            dataKeys.forEach(processData);
            function processData(key) {
              if (!schema2[key] || schema2[key].is !== type) {
                return;
              }
              if (variables[key].value === data[key]) {
                return;
              }
              variables[key].value = self2.parseValue(schema2[key].type, data[key]);
              variables[key].needsUpdate = true;
            }
          },
          parseValue: function(type, value) {
            var color;
            switch (type) {
              case "vec2": {
                return new THREE2.Vector2(value.x, value.y);
              }
              case "vec3": {
                return new THREE2.Vector3(value.x, value.y, value.z);
              }
              case "vec4": {
                return new THREE2.Vector4(value.x, value.y, value.z, value.w);
              }
              case "color": {
                color = new THREE2.Color(value);
                return new THREE2.Vector3(color.r, color.g, color.b);
              }
              default: {
                return value;
              }
            }
          }
        };
        module3.exports.registerShader = function(name, definition) {
          var NewShader;
          var proto = {};
          Object.keys(definition).forEach(function(key) {
            proto[key] = {
              value: definition[key],
              writable: true
            };
          });
          if (shaders[name]) {
            throw new Error("The shader " + name + " has been already registered");
          }
          NewShader = function() {
            Shader.call(this);
          };
          NewShader.prototype = Object.create(Shader.prototype, proto);
          NewShader.prototype.name = name;
          NewShader.prototype.constructor = NewShader;
          shaders[name] = {
            Shader: NewShader,
            schema: processSchema(NewShader.prototype.schema)
          };
          shaderNames.push(name);
          return NewShader;
        };
      }, { "../lib/three": 106, "./schema": 70 }], 72: [function(_dereq_, module3, exports3) {
        var components = _dereq_("./component");
        var schema = _dereq_("./schema");
        var utils = _dereq_("../utils/");
        var parseProperties = schema.parseProperties;
        var parseProperty = schema.parseProperty;
        var processSchema = schema.process;
        var isSingleProp = schema.isSingleProperty;
        var styleParser = utils.styleParser;
        var systems = module3.exports.systems = {};
        var System = module3.exports.System = function(sceneEl) {
          var component = components && components.components[this.name];
          var schema2 = this.schema;
          var rawData;
          this.sceneEl = sceneEl;
          if (component) {
            component.Component.prototype.system = this;
          }
          if (!Object.keys(schema2).length) {
            return;
          }
          rawData = HTMLElement.prototype.getAttribute.call(sceneEl, this.name);
          if (isSingleProp(schema2)) {
            this.data = parseProperty(rawData, schema2);
            return;
          }
          this.data = parseProperties(styleParser.parse(rawData) || {}, schema2, false, this.name);
        };
        System.prototype = {
          /**
           * Schema to configure system.
           */
          schema: {},
          /**
           * Init handler. Called during scene initialization and is only run once.
           * Systems can use this to set initial state.
           */
          init: function() {
          },
          /**
           * Tick handler.
           * Called on each tick of the scene render loop.
           * Affected by play and pause.
           *
           * @param {number} time - Scene tick time.
           * @param {number} timeDelta - Difference in current render time and previous render time.
           */
          tick: void 0,
          /**
           * Called to start any dynamic behavior (e.g., animation, AI, events, physics).
           */
          play: function() {
          },
          /**
           * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).
           */
          pause: function() {
          }
        };
        module3.exports.registerSystem = function(name, definition) {
          var i;
          var NewSystem;
          var proto = {};
          var scenes = utils.findAllScenes(document);
          Object.keys(definition).forEach(function(key) {
            proto[key] = {
              value: definition[key],
              writable: true
            };
          });
          if (systems[name]) {
            throw new Error("The system `" + name + "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");
          }
          NewSystem = function(sceneEl) {
            System.call(this, sceneEl);
          };
          NewSystem.prototype = Object.create(System.prototype, proto);
          NewSystem.prototype.name = name;
          NewSystem.prototype.constructor = NewSystem;
          NewSystem.prototype.schema = utils.extend(processSchema(NewSystem.prototype.schema));
          systems[name] = NewSystem;
          for (i = 0; i < scenes.length; i++) {
            scenes[i].initSystem(name);
          }
        };
      }, { "../utils/": 124, "./component": 63, "./schema": 70 }], 73: [function(_dereq_, module3, exports3) {
        _dereq_("./pivot");
      }, { "./pivot": 74 }], 74: [function(_dereq_, module3, exports3) {
        var registerComponent = _dereq_("../../core/component").registerComponent;
        var THREE2 = _dereq_("../../lib/three");
        var originalPosition = new THREE2.Vector3();
        var originalRotation = new THREE2.Vector3();
        registerComponent("pivot", {
          dependencies: ["position"],
          schema: { type: "vec3" },
          init: function() {
            var data = this.data;
            var el = this.el;
            var originalParent = el.object3D.parent;
            var originalGroup = el.object3D;
            var outerGroup = new THREE2.Group();
            originalPosition.copy(originalGroup.position);
            originalRotation.copy(originalGroup.rotation);
            originalParent.remove(originalGroup);
            outerGroup.add(originalGroup);
            originalParent.add(outerGroup);
            el.object3D = outerGroup;
            originalGroup.position.set(-1 * data.x, -1 * data.y, -1 * data.z);
            outerGroup.position.set(
              data.x + originalPosition.x,
              data.y + originalPosition.y,
              data.z + originalPosition.z
            );
            outerGroup.rotation.copy(originalGroup.rotation);
            originalGroup.rotation.set(0, 0, 0);
          }
        });
      }, { "../../core/component": 63, "../../lib/three": 106 }], 75: [function(_dereq_, module3, exports3) {
        var components = _dereq_("../../core/component").components;
        var shaders = _dereq_("../../core/shader").shaders;
        var utils = _dereq_("../../utils/");
        var materialMappings = {};
        Object.keys(components.material.schema).forEach(addMapping);
        Object.keys(shaders.standard.schema).forEach(addMapping);
        function addMapping(prop) {
          var htmlAttrName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          materialMappings[htmlAttrName] = "material." + prop;
        }
        module3.exports = function getMeshMixin() {
          return {
            defaultComponents: { material: {} },
            mappings: utils.extend({}, materialMappings)
          };
        };
      }, { "../../core/component": 63, "../../core/shader": 71, "../../utils/": 124 }], 76: [function(_dereq_, module3, exports3) {
        _dereq_("./primitives/a-camera");
        _dereq_("./primitives/a-collada-model");
        _dereq_("./primitives/a-cursor");
        _dereq_("./primitives/a-curvedimage");
        _dereq_("./primitives/a-image");
        _dereq_("./primitives/a-light");
        _dereq_("./primitives/a-obj-model");
        _dereq_("./primitives/a-sky");
        _dereq_("./primitives/a-sound");
        _dereq_("./primitives/a-video");
        _dereq_("./primitives/a-videosphere");
        _dereq_("./primitives/meshPrimitives");
      }, { "./primitives/a-camera": 78, "./primitives/a-collada-model": 79, "./primitives/a-cursor": 80, "./primitives/a-curvedimage": 81, "./primitives/a-image": 82, "./primitives/a-light": 83, "./primitives/a-obj-model": 84, "./primitives/a-sky": 85, "./primitives/a-sound": 86, "./primitives/a-video": 87, "./primitives/a-videosphere": 88, "./primitives/meshPrimitives": 89 }], 77: [function(_dereq_, module3, exports3) {
        var AEntity = _dereq_("../../core/a-entity");
        var components = _dereq_("../../core/component").components;
        var registerElement = _dereq_("../../core/a-register-element").registerElement;
        var utils = _dereq_("../../utils/");
        var debug = utils.debug;
        var setComponentProperty = utils.entity.setComponentProperty;
        var log = debug("extras:primitives:debug");
        var warn = debug("extras:primitives:warn");
        var primitives = module3.exports.primitives = {};
        module3.exports.registerPrimitive = function registerPrimitive(name, definition) {
          name = name.toLowerCase();
          log("Registering <%s>", name);
          if (definition.defaultAttributes) {
            warn("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");
          }
          var primitive = registerElement(name, {
            prototype: Object.create(AEntity.prototype, {
              defaultComponentsFromPrimitive: {
                value: definition.defaultComponents || definition.defaultAttributes || {}
              },
              deprecated: { value: definition.deprecated || null },
              deprecatedMappings: { value: definition.deprecatedMappings || {} },
              mappings: { value: definition.mappings || {} },
              createdCallback: {
                value: function() {
                  if (definition.deprecated) {
                    console.warn(definition.deprecated);
                  }
                  this.resolveMappingCollisions();
                }
              },
              /**
               * If a mapping collides with a registered component name
               * it renames the mapping to componentname-property
               */
              resolveMappingCollisions: {
                value: function() {
                  var mappings = this.mappings;
                  var self2 = this;
                  Object.keys(mappings).forEach(function resolveCollision(key) {
                    var newAttribute;
                    if (components[key]) {
                      newAttribute = mappings[key].replace(".", "-");
                      mappings[newAttribute] = mappings[key];
                      delete mappings[key];
                      console.warn("The primitive " + self2.tagName.toLowerCase() + " has a mapping collision. The attribute " + key + " has the same name as a registered component and has been renamed to " + newAttribute);
                    }
                  });
                }
              },
              getExtraComponents: {
                value: function() {
                  var attr;
                  var data;
                  var i;
                  var mapping;
                  var mixins;
                  var path;
                  var self2 = this;
                  data = utils.clone(this.defaultComponentsFromPrimitive);
                  mixins = this.getAttribute("mixin");
                  if (mixins) {
                    mixins = mixins.trim().split(" ");
                    mixins.forEach(function applyMixin(mixinId) {
                      var mixinComponents = self2.sceneEl.querySelector("#" + mixinId).componentCache;
                      Object.keys(mixinComponents).forEach(function setComponent(name2) {
                        data[name2] = utils.extendDeep(data[name2] || {}, mixinComponents[name2]);
                      });
                    });
                  }
                  for (i = 0; i < this.attributes.length; i++) {
                    attr = this.attributes[i];
                    mapping = this.mappings[attr.name];
                    if (mapping) {
                      path = utils.entity.getComponentPropertyPath(mapping);
                      if (path.constructor === Array) {
                        data[path[0]][path[1]] = attr.value;
                      } else {
                        data[path] = attr.value;
                      }
                      continue;
                    }
                  }
                  return data;
                }
              },
              /**
               * Sync to attribute to component property whenever mapped attribute changes.
               * If attribute is mapped to a component property, set the component property using
               * the attribute value.
               */
              attributeChangedCallback: {
                value: function(attr, oldVal, value) {
                  var componentName = this.mappings[attr];
                  if (attr in this.deprecatedMappings) {
                    console.warn(this.deprecatedMappings[attr]);
                  }
                  if (!attr || !componentName) {
                    return;
                  }
                  setComponentProperty(this, componentName, value);
                }
              }
            })
          });
          primitives[name] = primitive;
          return primitive;
        };
      }, { "../../core/a-entity": 59, "../../core/a-register-element": 62, "../../core/component": 63, "../../utils/": 124 }], 78: [function(_dereq_, module3, exports3) {
        var DEFAULT_CAMERA_HEIGHT = _dereq_("../../../constants/").DEFAULT_CAMERA_HEIGHT;
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        registerPrimitive("a-camera", {
          defaultComponents: {
            camera: {
              userHeight: DEFAULT_CAMERA_HEIGHT
            },
            "look-controls": {},
            "wasd-controls": {}
          },
          mappings: {
            active: "camera.active",
            far: "camera.far",
            fov: "camera.fov",
            "look-controls-enabled": "look-controls.enabled",
            near: "camera.near",
            "wasd-controls-enabled": "wasd-controls.enabled",
            "reverse-mouse-drag": "look-controls.reverseMouseDrag",
            "user-height": "camera.userHeight",
            zoom: "camera.zoom"
          },
          deprecatedMappings: {
            "cursor-color": "a-camera[cursor-color] has been removed. Use a-cursor[color] instead.",
            "cursor-maxdistance": "a-camera[cursor-maxdistance] has been removed. Use a-cursor[max-distance] instead.",
            "cursor-offset": "a-camera[cursor-offset] has been removed. Use a-cursor[position] instead.",
            "cursor-opacity": "a-camera[cursor-offset] has been removed. Use a-cursor[opacity] instead.",
            "cursor-scale": "a-camera[cursor-scale] has been removed. Use a-cursor[scale] instead.",
            "cursor-visible": "a-camera[cursor-visible] has been removed. Use a-cursor[visible] instead."
          }
        });
      }, { "../../../constants/": 54, "../primitives": 77 }], 79: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-collada-model", utils.extendDeep({}, getMeshMixin(), {
          mappings: {
            src: "collada-model"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 80: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-cursor", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            cursor: {},
            geometry: {
              primitive: "ring",
              radiusOuter: 0.016,
              radiusInner: 0.01,
              segmentsTheta: 64
            },
            material: {
              color: "#000",
              shader: "flat",
              opacity: 0.8
            },
            position: {
              x: 0,
              y: 0,
              z: -1
            },
            raycaster: {
              far: 1e3
            }
          },
          mappings: {
            far: "raycaster.far",
            fuse: "cursor.fuse",
            interval: "raycaster.interval",
            objects: "raycaster.objects",
            "fuse-timeout": "cursor.fuseTimeout"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 81: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-curvedimage", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            geometry: {
              height: 1,
              primitive: "cylinder",
              radius: 2,
              segmentsRadial: 48,
              thetaLength: 270,
              openEnded: true,
              thetaStart: 0
            },
            material: {
              color: "#FFF",
              shader: "flat",
              side: "double",
              transparent: true,
              repeat: "-1 1"
            }
          },
          mappings: {
            height: "geometry.height",
            "open-ended": "geometry.openEnded",
            radius: "geometry.radius",
            segments: "geometry.segmentsRadial",
            start: "geometry.thetaStart",
            "theta-length": "geometry.thetaLength",
            "theta-start": "geometry.thetaStart",
            "width": "geometry.thetaLength"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 82: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-image", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            geometry: {
              primitive: "plane"
            },
            material: {
              color: "#FFF",
              shader: "flat",
              side: "double",
              transparent: true
            }
          },
          mappings: {
            height: "geometry.height",
            width: "geometry.width"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 83: [function(_dereq_, module3, exports3) {
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        registerPrimitive("a-light", {
          defaultComponents: {
            light: {}
          },
          mappings: {
            angle: "light.angle",
            color: "light.color",
            "ground-color": "light.groundColor",
            decay: "light.decay",
            distance: "light.distance",
            intensity: "light.intensity",
            penumbra: "light.penumbra",
            type: "light.type",
            target: "light.target"
          }
        });
      }, { "../primitives": 77 }], 84: [function(_dereq_, module3, exports3) {
        var meshMixin = _dereq_("../getMeshMixin")();
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-obj-model", utils.extendDeep({}, meshMixin, {
          defaultComponents: {
            "obj-model": {}
          },
          mappings: {
            src: "obj-model.obj",
            mtl: "obj-model.mtl"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 85: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        var meshPrimitives = _dereq_("./meshPrimitives");
        registerPrimitive("a-sky", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            geometry: {
              primitive: "sphere",
              radius: 5e3,
              segmentsWidth: 64,
              segmentsHeight: 20
            },
            material: {
              color: "#FFF",
              shader: "flat"
            },
            scale: "-1 1 1"
          },
          mappings: utils.extendDeep({}, meshPrimitives["a-sphere"].prototype.mappings)
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77, "./meshPrimitives": 89 }], 86: [function(_dereq_, module3, exports3) {
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        registerPrimitive("a-sound", {
          defaultComponents: {
            sound: {}
          },
          mappings: {
            src: "sound.src",
            on: "sound.on",
            autoplay: "sound.autoplay",
            loop: "sound.loop",
            volume: "sound.volume"
          }
        });
      }, { "../primitives": 77 }], 87: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-video", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            geometry: {
              primitive: "plane"
            },
            material: {
              color: "#FFF",
              shader: "flat",
              side: "double",
              transparent: true
            }
          },
          mappings: {
            height: "geometry.height",
            width: "geometry.width"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 88: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        registerPrimitive("a-videosphere", utils.extendDeep({}, getMeshMixin(), {
          defaultComponents: {
            geometry: {
              primitive: "sphere",
              radius: 5e3,
              segmentsWidth: 64,
              segmentsHeight: 20
            },
            material: {
              color: "#FFF",
              shader: "flat"
            },
            scale: "-1 1 1"
          },
          mappings: {
            radius: "geometry.radius",
            "segments-height": "geometry.segmentsHeight",
            "segments-width": "geometry.segmentsWidth"
          }
        }));
      }, { "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 89: [function(_dereq_, module3, exports3) {
        var getMeshMixin = _dereq_("../getMeshMixin");
        var geometries = _dereq_("../../../core/geometry").geometries;
        var geometryNames = _dereq_("../../../core/geometry").geometryNames;
        var registerPrimitive = _dereq_("../primitives").registerPrimitive;
        var utils = _dereq_("../../../utils/");
        var meshPrimitives = module3.exports = {};
        geometryNames.forEach(function registerMeshPrimitive(geometryName) {
          var geometry = geometries[geometryName];
          var geometryHyphened = unCamelCase(geometryName);
          var mappings = {};
          Object.keys(geometry.schema).forEach(function createMapping(property) {
            mappings[unCamelCase(property)] = "geometry." + property;
          });
          var tagName = "a-" + geometryHyphened;
          var primitive = registerPrimitive(tagName, utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: { geometry: { primitive: geometryName } },
            mappings
          }));
          meshPrimitives[tagName] = primitive;
        });
        function unCamelCase(str) {
          return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        }
      }, { "../../../core/geometry": 64, "../../../utils/": 124, "../getMeshMixin": 75, "../primitives": 77 }], 90: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("box", {
          schema: {
            depth: { default: 1, min: 0 },
            height: { default: 1, min: 0 },
            width: { default: 1, min: 0 },
            segmentsHeight: { default: 1, min: 1, max: 20, type: "int" },
            segmentsWidth: { default: 1, min: 1, max: 20, type: "int" },
            segmentsDepth: { default: 1, min: 1, max: 20, type: "int" }
          },
          init: function(data) {
            this.geometry = new THREE2.BoxGeometry(data.width, data.height, data.depth);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 91: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("circle", {
          schema: {
            radius: { default: 1, min: 0 },
            segments: { default: 32, min: 3, type: "int" },
            thetaLength: { default: 360, min: 0 },
            thetaStart: { default: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.CircleGeometry(
              data.radius,
              data.segments,
              degToRad(data.thetaStart),
              degToRad(data.thetaLength)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 92: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("cone", {
          schema: {
            height: { default: 1, min: 0 },
            openEnded: { default: false },
            radiusBottom: { default: 1, min: 0 },
            radiusTop: { default: 0.8, min: 0 },
            segmentsHeight: { default: 18, min: 1, type: "int" },
            segmentsRadial: { default: 36, min: 3, type: "int" },
            thetaLength: { default: 360, min: 0 },
            thetaStart: { default: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.segmentsRadial,
              data.segmentsHeight,
              data.openEnded,
              degToRad(data.thetaStart),
              degToRad(data.thetaLength)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 93: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("cylinder", {
          schema: {
            height: { default: 1, min: 0 },
            openEnded: { default: false },
            radius: { default: 1, min: 0 },
            segmentsHeight: { default: 18, min: 1, type: "int" },
            segmentsRadial: { default: 36, min: 3, type: "int" },
            thetaLength: { default: 360, min: 0 },
            thetaStart: { default: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.CylinderGeometry(
              data.radius,
              data.radius,
              data.height,
              data.segmentsRadial,
              data.segmentsHeight,
              data.openEnded,
              degToRad(data.thetaStart),
              degToRad(data.thetaLength)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 94: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("dodecahedron", {
          schema: {
            detail: { default: 0, min: 0, max: 5, type: "int" },
            radius: { default: 1, min: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.DodecahedronGeometry(data.radius, data.detail);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 95: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("icosahedron", {
          schema: {
            detail: { default: 0, min: 0, max: 5, type: "int" },
            radius: { default: 1, min: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.IcosahedronGeometry(data.radius, data.detail);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 96: [function(_dereq_, module3, exports3) {
        _dereq_("./box.js");
        _dereq_("./circle.js");
        _dereq_("./cone.js");
        _dereq_("./cylinder.js");
        _dereq_("./dodecahedron.js");
        _dereq_("./icosahedron.js");
        _dereq_("./octahedron.js");
        _dereq_("./plane.js");
        _dereq_("./ring.js");
        _dereq_("./sphere.js");
        _dereq_("./tetrahedron.js");
        _dereq_("./torus.js");
        _dereq_("./torusKnot.js");
      }, { "./box.js": 90, "./circle.js": 91, "./cone.js": 92, "./cylinder.js": 93, "./dodecahedron.js": 94, "./icosahedron.js": 95, "./octahedron.js": 97, "./plane.js": 98, "./ring.js": 99, "./sphere.js": 100, "./tetrahedron.js": 101, "./torus.js": 102, "./torusKnot.js": 103 }], 97: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("octahedron", {
          schema: {
            detail: { default: 0, min: 0, max: 5, type: "int" },
            radius: { default: 1, min: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.OctahedronGeometry(data.radius, data.detail);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 98: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("plane", {
          schema: {
            height: { default: 1, min: 0 },
            width: { default: 1, min: 0 },
            segmentsHeight: { default: 1, min: 1, max: 20, type: "int" },
            segmentsWidth: { default: 1, min: 1, max: 20, type: "int" }
          },
          init: function(data) {
            this.geometry = new THREE2.PlaneGeometry(data.width, data.height);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 99: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("ring", {
          schema: {
            radiusInner: { default: 0.8, min: 0 },
            radiusOuter: { default: 1.2, min: 0 },
            segmentsPhi: { default: 10, min: 1, type: "int" },
            segmentsTheta: { default: 32, min: 3, type: "int" },
            thetaLength: { default: 360, min: 0 },
            thetaStart: { default: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.RingGeometry(
              data.radiusInner,
              data.radiusOuter,
              data.segmentsTheta,
              data.segmentsPhi,
              degToRad(data.thetaStart),
              degToRad(data.thetaLength)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 100: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("sphere", {
          schema: {
            radius: { default: 1, min: 0 },
            phiLength: { default: 360 },
            phiStart: { default: 0, min: 0 },
            thetaLength: { default: 180, min: 0 },
            thetaStart: { default: 0 },
            segmentsHeight: { default: 18, min: 2, type: "int" },
            segmentsWidth: { default: 36, min: 3, type: "int" }
          },
          init: function(data) {
            this.geometry = new THREE2.SphereGeometry(
              data.radius,
              data.segmentsWidth,
              data.segmentsHeight,
              degToRad(data.phiStart),
              degToRad(data.phiLength),
              degToRad(data.thetaStart),
              degToRad(data.thetaLength)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 101: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("tetrahedron", {
          schema: {
            detail: { default: 0, min: 0, max: 5, type: "int" },
            radius: { default: 1, min: 0 }
          },
          init: function(data) {
            this.geometry = new THREE2.TetrahedronGeometry(data.radius, data.detail);
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 102: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        var degToRad = THREE2.Math.degToRad;
        registerGeometry("torus", {
          schema: {
            arc: { default: 360 },
            radius: { default: 1, min: 0 },
            radiusTubular: { default: 0.2, min: 0 },
            segmentsRadial: { default: 36, min: 2, type: "int" },
            segmentsTubular: { default: 32, min: 3, type: "int" }
          },
          init: function(data) {
            this.geometry = new THREE2.TorusGeometry(
              data.radius,
              data.radiusTubular * 2,
              data.segmentsRadial,
              data.segmentsTubular,
              degToRad(data.arc)
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 103: [function(_dereq_, module3, exports3) {
        var registerGeometry = _dereq_("../core/geometry").registerGeometry;
        var THREE2 = _dereq_("../lib/three");
        registerGeometry("torusKnot", {
          schema: {
            p: { default: 2, min: 1 },
            q: { default: 3, min: 1 },
            radius: { default: 1, min: 0 },
            radiusTubular: { default: 0.2, min: 0 },
            segmentsRadial: { default: 8, min: 3, type: "int" },
            segmentsTubular: { default: 100, min: 3, type: "int" }
          },
          init: function(data) {
            this.geometry = new THREE2.TorusKnotGeometry(
              data.radius,
              data.radiusTubular * 2,
              data.segmentsTubular,
              data.segmentsRadial,
              data.p,
              data.q
            );
          }
        });
      }, { "../core/geometry": 64, "../lib/three": 106 }], 104: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("./utils/debug");
        var error = debug("A-Frame:warn");
        var info = debug("A-Frame:info");
        if (document.currentScript && document.currentScript.parentNode !== document.head) {
          error("Put the A-Frame <script> tag in the <head> of the HTML before <a-scene> to ensure everything for A-Frame is properly registered before they are used in the <body>.");
          info("Also make sure that any component <script> tags are included after A-Frame, but still before <a-scene>.");
        }
        window.Promise = window.Promise || _dereq_("promise-polyfill");
        window.hasNativeWebVRImplementation = !!navigator.getVRDisplays || !!navigator.getVRDevices;
        window.WebVRConfig = window.WebVRConfig || {
          BUFFER_SCALE: 1,
          CARDBOARD_UI_DISABLED: true,
          ROTATE_INSTRUCTIONS_DISABLED: true,
          TOUCH_PANNER_DISABLED: true,
          MOUSE_KEYBOARD_CONTROLS_DISABLED: true
        };
        if (/(iphone|ipod|ipad).*os.*(7|8|9)/i.test(navigator.userAgent)) {
          window.WebVRConfig.BUFFER_SCALE = 1 / window.devicePixelRatio;
        }
        _dereq_("webvr-polyfill");
        _dereq_("present");
        _dereq_("./style/aframe.css");
        _dereq_("./style/rStats.css");
        var AScene = _dereq_("./core/scene/a-scene");
        var components = _dereq_("./core/component").components;
        var registerComponent = _dereq_("./core/component").registerComponent;
        var registerGeometry = _dereq_("./core/geometry").registerGeometry;
        var registerPrimitive = _dereq_("./extras/primitives/primitives").registerPrimitive;
        var registerShader = _dereq_("./core/shader").registerShader;
        var registerSystem = _dereq_("./core/system").registerSystem;
        var shaders = _dereq_("./core/shader").shaders;
        var systems = _dereq_("./core/system").systems;
        var THREE2 = window.THREE = _dereq_("./lib/three");
        var TWEEN = window.TWEEN = _dereq_("tween.js");
        var pkg = _dereq_("../package");
        var utils = _dereq_("./utils/");
        _dereq_("./components/index");
        _dereq_("./geometries/index");
        _dereq_("./shaders/index");
        _dereq_("./systems/index");
        var ANode = _dereq_("./core/a-node");
        var AEntity = _dereq_("./core/a-entity");
        _dereq_("./core/a-animation");
        _dereq_("./core/a-assets");
        _dereq_("./core/a-cubemap");
        _dereq_("./core/a-mixin");
        _dereq_("./extras/components/");
        _dereq_("./extras/primitives/");
        console.log("A-Frame Version:", pkg.version);
        console.log("three Version:", pkg.dependencies["three"]);
        console.log("WebVR Polyfill Version:", pkg.dependencies["webvr-polyfill"]);
        module3.exports = window.AFRAME = {
          AComponent: _dereq_("./core/component").Component,
          AEntity,
          ANode,
          AScene,
          components,
          geometries: _dereq_("./core/geometry").geometries,
          registerComponent,
          registerElement: _dereq_("./core/a-register-element").registerElement,
          registerGeometry,
          registerPrimitive,
          registerShader,
          registerSystem,
          primitives: {
            getMeshMixin: _dereq_("./extras/primitives/getMeshMixin"),
            primitives: _dereq_("./extras/primitives/primitives").primitives
          },
          schema: _dereq_("./core/schema"),
          shaders,
          systems,
          THREE: THREE2,
          TWEEN,
          utils,
          version: pkg.version
        };
      }, { "../package": 20, "./components/index": 27, "./core/a-animation": 56, "./core/a-assets": 57, "./core/a-cubemap": 58, "./core/a-entity": 59, "./core/a-mixin": 60, "./core/a-node": 61, "./core/a-register-element": 62, "./core/component": 63, "./core/geometry": 64, "./core/scene/a-scene": 66, "./core/schema": 70, "./core/shader": 71, "./core/system": 72, "./extras/components/": 73, "./extras/primitives/": 76, "./extras/primitives/getMeshMixin": 75, "./extras/primitives/primitives": 77, "./geometries/index": 96, "./lib/three": 106, "./shaders/index": 108, "./style/aframe.css": 110, "./style/rStats.css": 111, "./systems/index": 114, "./utils/": 124, "./utils/debug": 120, "present": 10, "promise-polyfill": 11, "tween.js": 18, "webvr-polyfill": 19 }], 105: [function(_dereq_, module3, exports3) {
        window.aframeStats = function(scene) {
          var _rS = null;
          var _scene = scene;
          var _values = {
            te: {
              caption: "Entities"
            },
            lt: {
              caption: "Load Time"
            }
          };
          var _groups = [{
            caption: "A-Frame",
            values: ["te", "lt"]
          }];
          function _update() {
            _rS("te").set(getEntityCount());
            if (window.performance.getEntriesByName) {
              _rS("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0));
            }
          }
          function getEntityCount() {
            var elements = _scene.querySelectorAll("*");
            Array.prototype.slice.call(elements).filter(function(el) {
              return el.isEntity;
            });
            return elements.length;
          }
          function _start() {
          }
          function _end() {
          }
          function _attach(r) {
            _rS = r;
          }
          return {
            update: _update,
            start: _start,
            end: _end,
            attach: _attach,
            values: _values,
            groups: _groups,
            fractions: []
          };
        };
        if (typeof module3 === "object") {
          module3.exports = {
            aframeStats: window.aframeStats
          };
        }
      }, {}], 106: [function(_dereq_, module3, exports3) {
        (function(global2) {
          var THREE2 = global2.THREE = _dereq_("three");
          if (THREE2.TextureLoader) {
            THREE2.TextureLoader.prototype.crossOrigin = "anonymous";
          }
          if (THREE2.ImageLoader) {
            THREE2.ImageLoader.prototype.crossOrigin = "anonymous";
          }
          if (THREE2.Cache) {
            THREE2.Cache.enabled = true;
          }
          _dereq_("three/examples/js/loaders/OBJLoader");
          _dereq_("three/examples/js/loaders/MTLLoader");
          _dereq_("three/examples/js/BlendCharacter");
          _dereq_("three/examples/js/loaders/ColladaLoader");
          _dereq_("../../vendor/VRControls");
          _dereq_("../../vendor/VREffect");
          THREE2.ColladaLoader.prototype.crossOrigin = "anonymous";
          THREE2.MTLLoader.prototype.crossOrigin = "anonymous";
          THREE2.OBJLoader.prototype.crossOrigin = "anonymous";
          module3.exports = THREE2;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../../vendor/VRControls": 129, "../../vendor/VREffect": 130, "three": 13, "three/examples/js/BlendCharacter": 14, "three/examples/js/loaders/ColladaLoader": 15, "three/examples/js/loaders/MTLLoader": 16, "three/examples/js/loaders/OBJLoader": 17 }], 107: [function(_dereq_, module3, exports3) {
        var registerShader = _dereq_("../core/shader").registerShader;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        module3.exports.Shader = registerShader("flat", {
          schema: {
            color: { type: "color" },
            fog: { default: true },
            height: { default: 256 },
            offset: { type: "vec2", default: { x: 1, y: 1 } },
            repeat: { type: "vec2", default: { x: 1, y: 1 } },
            src: { type: "map" },
            width: { default: 512 },
            wireframe: { default: false },
            wireframeLinewidth: { default: 2 }
          },
          /**
           * Initializes the shader.
           * Adds a reference from the scene to this entity as the camera.
           */
          init: function(data) {
            this.textureSrc = null;
            this.material = new THREE2.MeshBasicMaterial(getMaterialData(data));
            utils.material.updateMap(this, data);
          },
          update: function(data) {
            this.updateMaterial(data);
            utils.material.updateMap(this, data);
          },
          /**
           * Updating existing material.
           *
           * @param {object} data - Material component data.
           */
          updateMaterial: function(data) {
            var material = this.material;
            data = getMaterialData(data);
            Object.keys(data).forEach(function(key) {
              material[key] = data[key];
            });
          }
        });
        function getMaterialData(data) {
          return {
            fog: data.fog,
            color: new THREE2.Color(data.color),
            wireframe: data.wireframe,
            wireframeLinewidth: data.wireframeLinewidth
          };
        }
      }, { "../core/shader": 71, "../lib/three": 106, "../utils/": 124 }], 108: [function(_dereq_, module3, exports3) {
        _dereq_("./flat");
        _dereq_("./standard");
      }, { "./flat": 107, "./standard": 109 }], 109: [function(_dereq_, module3, exports3) {
        var registerShader = _dereq_("../core/shader").registerShader;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var CubeLoader = new THREE2.CubeTextureLoader();
        var texturePromises = {};
        module3.exports.Shader = registerShader("standard", {
          schema: {
            ambientOcclusionMap: { type: "map" },
            ambientOcclusionMapIntensity: { default: 1 },
            ambientOcclusionTextureOffset: { type: "vec2" },
            ambientOcclusionTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
            color: { type: "color" },
            displacementMap: { type: "map" },
            displacementScale: { default: 1 },
            displacementBias: { default: 0.5 },
            displacementTextureOffset: { type: "vec2" },
            displacementTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
            envMap: { default: "" },
            fog: { default: true },
            height: { default: 256 },
            metalness: { default: 0, min: 0, max: 1 },
            normalMap: { type: "map" },
            normalScale: { type: "vec2", default: "1 1" },
            normalTextureOffset: { type: "vec2" },
            normalTextureRepeat: { type: "vec2", default: { x: 1, y: 1 } },
            offset: { type: "vec2", default: { x: 1, y: 1 } },
            repeat: { type: "vec2", default: { x: 1, y: 1 } },
            roughness: { default: 0.5, min: 0, max: 1 },
            sphericalEnvMap: { type: "map" },
            src: { type: "map" },
            width: { default: 512 },
            wireframe: { default: false },
            wireframeLinewidth: { default: 2 }
          },
          /**
           * Initializes the shader.
           * Adds a reference from the scene to this entity as the camera.
           */
          init: function(data) {
            this.material = new THREE2.MeshStandardMaterial(getMaterialData(data));
            utils.material.updateMap(this, data);
            if (data.normalMap) {
              utils.material.updateDistortionMap("normal", this, data);
            }
            if (data.displacementMap) {
              utils.material.updateDistortionMap("displacement", this, data);
            }
            if (data.ambientOcclusionMap) {
              utils.material.updateDistortionMap("ambientOcclusion", this, data);
            }
            this.updateEnvMap(data);
          },
          update: function(data) {
            this.updateMaterial(data);
            utils.material.updateMap(this, data);
            if (data.normalMap) {
              utils.material.updateDistortionMap("normal", this, data);
            }
            if (data.displacementMap) {
              utils.material.updateDistortionMap("displacement", this, data);
            }
            if (data.ambientOcclusionMap) {
              utils.material.updateDistortionMap("ambientOcclusion", this, data);
            }
            this.updateEnvMap(data);
          },
          /**
           * Updating existing material.
           *
           * @param {object} data - Material component data.
           * @returns {object} Material.
           */
          updateMaterial: function(data) {
            var material = this.material;
            data = getMaterialData(data);
            Object.keys(data).forEach(function(key) {
              material[key] = data[key];
            });
          },
          /**
           * Handle environment cubemap. Textures are cached in texturePromises.
           */
          updateEnvMap: function(data) {
            var self2 = this;
            var material = this.material;
            var envMap = data.envMap;
            var sphericalEnvMap = data.sphericalEnvMap;
            if (!envMap && !sphericalEnvMap || this.isLoadingEnvMap) {
              material.envMap = null;
              material.needsUpdate = true;
              return;
            }
            this.isLoadingEnvMap = true;
            if (sphericalEnvMap) {
              this.el.sceneEl.systems.material.loadTexture(sphericalEnvMap, { src: sphericalEnvMap }, function textureLoaded(texture) {
                self2.isLoadingEnvMap = false;
                texture.mapping = THREE2.SphericalReflectionMapping;
                material.envMap = texture;
                utils.material.handleTextureEvents(self2.el, texture);
                material.needsUpdate = true;
              });
              return;
            }
            if (texturePromises[envMap]) {
              texturePromises[envMap].then(function(cube) {
                self2.isLoadingEnvMap = false;
                material.envMap = cube;
                utils.material.handleTextureEvents(self2.el, cube);
                material.needsUpdate = true;
              });
              return;
            }
            texturePromises[envMap] = new Promise(function(resolve) {
              utils.srcLoader.validateCubemapSrc(envMap, function loadEnvMap(urls) {
                CubeLoader.load(urls, function(cube) {
                  self2.isLoadingEnvMap = false;
                  material.envMap = cube;
                  utils.material.handleTextureEvents(self2.el, cube);
                  resolve(cube);
                });
              });
            });
          }
        });
        function getMaterialData(data) {
          var newData = {
            color: new THREE2.Color(data.color),
            fog: data.fog,
            metalness: data.metalness,
            roughness: data.roughness,
            wireframe: data.wireframe,
            wireframeLinewidth: data.wireframeLinewidth
          };
          if (data.normalMap) {
            newData.normalScale = data.normalScale;
          }
          if (data.ambientOcclusionMap) {
            newData.aoMapIntensity = data.ambientOcclusionMapIntensity;
          }
          if (data.displacementMap) {
            newData.displacementScale = data.displacementScale;
            newData.displacementBias = data.displacementBias;
          }
          return newData;
        }
      }, { "../core/shader": 71, "../lib/three": 106, "../utils/": 124 }], 110: [function(_dereq_, module3, exports3) {
        var css = `.a-html{bottom:0;left:0;position:fixed;right:0;top:0}.a-body{height:100%;margin:0;overflow:hidden;padding:0;width:100%}:-webkit-full-screen{background-color:transparent}.a-hidden{display:none!important}.a-canvas{height:100%;left:0;position:absolute;top:0;width:100%}.a-canvas.a-grab-cursor:hover{cursor:grab;cursor:-moz-grabbing;cursor:-webkit-grab}.a-canvas.a-grab-cursor:active,.a-grabbing{cursor:grabbing;cursor:-moz-grabbing;cursor:-webkit-grabbing}// Class is removed when doing <a-scene embedded>. .a-canvas.fullscreen{width:100%!important;height:100%!important;top:0!important;left:0!important;right:0!important;bottom:0!important;z-index:999999!important;position:fixed!important}.a-inspector-loader{background-color:#ed3160;position:fixed;left:3px;top:3px;padding:6px 10px;color:#fff;text-decoration:none;font-size:12px;font-family:Roboto,sans-serif;text-align:center;z-index:99999;width:174px}@keyframes dots-1{from{opacity:0}25%{opacity:1}}@keyframes dots-2{from{opacity:0}50%{opacity:1}}@keyframes dots-3{from{opacity:0}75%{opacity:1}}@-webkit-keyframes dots-1{from{opacity:0}25%{opacity:1}}@-webkit-keyframes dots-2{from{opacity:0}50%{opacity:1}}@-webkit-keyframes dots-3{from{opacity:0}75%{opacity:1}}.a-inspector-loader .dots span{animation:dots-1 2s infinite steps(1);-webkit-animation:dots-1 2s infinite steps(1)}.a-inspector-loader .dots span:first-child+span{animation-name:dots-2;-webkit-animation-name:dots-2}.a-inspector-loader .dots span:first-child+span+span{animation-name:dots-3;-webkit-animation-name:dots-3}a-scene{display:block;position:relative;height:100%;width:100%}a-assets,a-scene audio,a-scene img,a-scene video{display:none}.a-enter-vr-modal,.a-orientation-modal{font-family:Consolas,Andale Mono,Courier New,monospace}.a-enter-vr-modal a{border-bottom:1px solid #fff;padding:2px 0;text-decoration:none;transition:.1s color ease-in}.a-enter-vr-modal a:hover{background-color:#fff;color:#111;padding:2px 4px;position:relative;left:-4px}.a-enter-vr{font-family:sans-serif,monospace;font-size:13px;width:100%;font-weight:200;line-height:16px;height:10%;position:absolute;right:20px;bottom:20px}.a-enter-vr.embedded{right:5px;bottom:5px}.a-enter-vr-button,.a-enter-vr-modal,.a-enter-vr-modal a{color:#fff}.a-enter-vr-button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E) 50% 50%/70% 70% no-repeat rgba(0,0,0,.35);border:0;bottom:0;cursor:pointer;min-width:50px;min-height:30px;padding-right:5%;padding-top:4%;position:absolute;right:0;transition:background-color .05s ease;-webkit-transition:background-color .05s ease;z-index:9999}.a-enter-vr-button:active,.a-enter-vr-button:hover{background-color:#666}[data-a-enter-vr-no-webvr] .a-enter-vr-button{border-color:#666;opacity:.65}[data-a-enter-vr-no-webvr] .a-enter-vr-button:active,[data-a-enter-vr-no-webvr] .a-enter-vr-button:hover{background-color:rgba(0,0,0,.35);cursor:not-allowed}.a-enter-vr-modal{background-color:#666;border-radius:0;display:none;min-height:32px;margin-right:70px;padding:9px;width:280px;right:2%;position:absolute}.a-enter-vr-modal:after{border-bottom:10px solid transparent;border-left:10px solid #666;border-top:10px solid transparent;display:inline-block;content:'';position:absolute;right:-5px;top:5px;width:0;height:0}.a-enter-vr-modal a,.a-enter-vr-modal p{display:inline}.a-enter-vr-modal p{margin:0}.a-enter-vr-modal p:after{content:' '}[data-a-enter-vr-no-headset].a-enter-vr:hover .a-enter-vr-modal,[data-a-enter-vr-no-webvr].a-enter-vr:hover .a-enter-vr-modal{display:block}.a-orientation-modal{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center/50% 50% no-repeat rgba(244,244,244,1);bottom:0;font-size:14px;font-weight:600;left:0;line-height:20px;right:0;position:fixed;top:0;z-index:9999999}.a-orientation-modal:after{color:#666;content:"Insert phone into Cardboard holder.";display:block;position:absolute;text-align:center;top:70%;transform:translateY(-70%);width:100%}.a-orientation-modal button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;border:none;height:50px;text-indent:-9999px;width:50px}`;
        _dereq_("browserify-css").createStyle(css, { "href": "src/style/aframe.css" });
        module3.exports = css;
      }, { "browserify-css": 1 }], 111: [function(_dereq_, module3, exports3) {
        var css = ".rs-base{background-color:#333;border-radius:0;font:10px monospace;left:5px;line-height:1em;opacity:.85;overflow:hidden;padding:10px;position:fixed;top:5px;width:300px;z-index:10000}.rs-base div.hidden{display:none}.rs-base h1{color:#fff;cursor:pointer;font-size:1.4em;font-weight:300;margin:0 0 5px;padding:0}.rs-group{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-direction:column-reverse;flex-direction:column-reverse;margin-bottom:5px}.rs-group:last-child{margin-bottom:0}.rs-counter-base{align-items:center;display:-webkit-box;display:-webkit-flex;display:flex;height:10px;-webkit-justify-content:space-between;justify-content:space-between;margin:2px 0}.rs-counter-base.alarm{color:#b70000;text-shadow:0 0 0 #b70000,0 0 1px #fff,0 0 1px #fff,0 0 2px #fff,0 0 2px #fff,0 0 3px #fff,0 0 3px #fff,0 0 4px #fff,0 0 4px #fff}.rs-counter-id{font-weight:300;-webkit-box-ordinal-group:0;-webkit-order:0;order:0;width:54px}.rs-counter-value{font-weight:300;-webkit-box-ordinal-group:1;-webkit-order:1;order:1;text-align:right;width:35px}.rs-canvas{-webkit-box-ordinal-group:2;-webkit-order:2;order:2}@media (min-width:480px){.rs-base{left:20px;top:20px}}";
        _dereq_("browserify-css").createStyle(css, { "href": "src/style/rStats.css" });
        module3.exports = css;
      }, { "browserify-css": 1 }], 112: [function(_dereq_, module3, exports3) {
        var bind = _dereq_("../utils/bind");
        var constants = _dereq_("../constants/");
        var registerSystem = _dereq_("../core/system").registerSystem;
        var DEFAULT_CAMERA_ATTR = "data-aframe-default-camera";
        module3.exports.System = registerSystem("camera", {
          init: function() {
            this.activeCameraEl = null;
            this.sceneEl.addEventListener("loaded", bind(this.setupDefaultCamera, this));
          },
          /**
           * Create a default camera if user has not added one during the initial scene traversal.
           *
           * Default camera offset height is at average eye level (~1.6m).
           */
          setupDefaultCamera: function() {
            var sceneEl = this.sceneEl;
            var defaultCameraEl;
            if (sceneEl.camera) {
              sceneEl.emit("camera-ready", { cameraEl: sceneEl.camera.el });
              return;
            }
            defaultCameraEl = document.createElement("a-entity");
            defaultCameraEl.setAttribute("position", "0 0 0");
            defaultCameraEl.setAttribute(DEFAULT_CAMERA_ATTR, "");
            defaultCameraEl.setAttribute("camera", { active: true, userHeight: constants.DEFAULT_CAMERA_HEIGHT });
            defaultCameraEl.setAttribute("wasd-controls", "");
            defaultCameraEl.setAttribute("look-controls", "");
            defaultCameraEl.setAttribute(constants.AFRAME_INJECTED, "");
            sceneEl.appendChild(defaultCameraEl);
            sceneEl.addEventListener("enter-vr", this.removeDefaultOffset);
            sceneEl.addEventListener("exit-vr", this.addDefaultOffset);
            sceneEl.emit("camera-ready", { cameraEl: defaultCameraEl });
          },
          /**
           * Set a different active camera.
           * When we choose a (sort of) random scene camera as the replacement, set its `active` to
           * true. The camera component will call `setActiveCamera` and handle passing the torch to
           * the new camera.
           */
          disableActiveCamera: function() {
            var cameraEls = this.sceneEl.querySelectorAll("[camera]");
            var newActiveCameraEl = cameraEls[cameraEls.length - 1];
            newActiveCameraEl.setAttribute("camera", "active", true);
          },
          /**
           * Set active camera to be used by renderer.
           * Removes the default camera (if present).
           * Disables all other cameras in the scene.
           *
           * @param {Element} newCameraEl - Entity with camera component.
           */
          setActiveCamera: function(newCameraEl) {
            var cameraEl;
            var cameraEls;
            var i;
            var newCamera;
            var previousCamera = this.activeCameraEl;
            var sceneEl = this.sceneEl;
            newCamera = newCameraEl.getObject3D("camera");
            if (!newCamera || newCameraEl === this.activeCameraEl) {
              return;
            }
            var defaultCameraWrapper = sceneEl.querySelector("[" + DEFAULT_CAMERA_ATTR + "]");
            var defaultCameraEl = defaultCameraWrapper && defaultCameraWrapper.querySelector("[camera]");
            if (newCameraEl !== defaultCameraEl) {
              removeDefaultCamera(sceneEl);
            }
            this.activeCameraEl = newCameraEl;
            this.activeCameraEl.play();
            sceneEl.camera = newCamera;
            if (previousCamera) {
              previousCamera.setAttribute("camera", "active", false);
            }
            cameraEls = sceneEl.querySelectorAll("[camera]");
            for (i = 0; i < cameraEls.length; i++) {
              cameraEl = cameraEls[i];
              if (newCameraEl === cameraEl) {
                continue;
              }
              cameraEl.setAttribute("camera", "active", false);
              cameraEl.pause();
            }
            sceneEl.emit("camera-set-active", { cameraEl: newCameraEl });
          }
        });
        function removeDefaultCamera(sceneEl) {
          var defaultCamera;
          var camera = sceneEl.camera;
          if (!camera) {
            return;
          }
          defaultCamera = sceneEl.querySelector("[" + DEFAULT_CAMERA_ATTR + "]");
          if (!defaultCamera) {
            return;
          }
          sceneEl.removeChild(defaultCamera);
        }
      }, { "../constants/": 54, "../core/system": 72, "../utils/bind": 118 }], 113: [function(_dereq_, module3, exports3) {
        var geometries = _dereq_("../core/geometry").geometries;
        var registerSystem = _dereq_("../core/system").registerSystem;
        var THREE2 = _dereq_("../lib/three");
        module3.exports.System = registerSystem("geometry", {
          init: function() {
            this.cache = {};
            this.cacheCount = {};
          },
          /**
           * Reset cache. Mainly for testing.
           */
          clearCache: function() {
            this.cache = {};
            this.cacheCount = {};
          },
          /**
           * Attempt to retrieve from cache.
           *
           * @returns {Object|null} A geometry if it exists, else null.
           */
          getOrCreateGeometry: function(data) {
            var cache = this.cache;
            var cachedGeometry;
            var hash;
            if (data.skipCache) {
              return createGeometry(data);
            }
            hash = this.hash(data);
            cachedGeometry = cache[hash];
            incrementCacheCount(this.cacheCount, hash);
            if (cachedGeometry) {
              return cachedGeometry;
            }
            cachedGeometry = createGeometry(data);
            cache[hash] = cachedGeometry;
            return cachedGeometry;
          },
          /**
           * Let system know that an entity is no longer using a geometry.
           */
          unuseGeometry: function(data) {
            var cache = this.cache;
            var cacheCount = this.cacheCount;
            var geometry;
            var hash;
            if (data.skipCache) {
              return;
            }
            hash = this.hash(data);
            if (!cache[hash]) {
              return;
            }
            decrementCacheCount(cacheCount, hash);
            if (cacheCount[hash] > 0) {
              return;
            }
            geometry = cache[hash];
            geometry.dispose();
            delete cache[hash];
            delete cacheCount[hash];
          },
          /**
           * Use JSON.stringify to turn component data into hash.
           * Should be deterministic within a single browser engine.
           * If not, then look into json-stable-stringify.
           */
          hash: function(data) {
            return JSON.stringify(data);
          }
        });
        function createGeometry(data) {
          var geometryType = data.primitive;
          var GeometryClass = geometries[geometryType] && geometries[geometryType].Geometry;
          var geometryInstance = new GeometryClass();
          if (!GeometryClass) {
            throw new Error("Unknown geometry `" + geometryType + "`");
          }
          geometryInstance.init(data);
          return toBufferGeometry(geometryInstance.geometry, data.buffer);
        }
        function decrementCacheCount(cacheCount, hash) {
          cacheCount[hash]--;
        }
        function incrementCacheCount(cacheCount, hash) {
          cacheCount[hash] = cacheCount[hash] === void 0 ? 1 : cacheCount[hash] + 1;
        }
        function toBufferGeometry(geometry, doBuffer) {
          var bufferGeometry;
          if (!doBuffer) {
            return geometry;
          }
          bufferGeometry = new THREE2.BufferGeometry().fromGeometry(geometry);
          bufferGeometry.metadata = { type: geometry.type, parameters: geometry.parameters || {} };
          geometry.dispose();
          return bufferGeometry;
        }
      }, { "../core/geometry": 64, "../core/system": 72, "../lib/three": 106 }], 114: [function(_dereq_, module3, exports3) {
        _dereq_("./camera");
        _dereq_("./geometry");
        _dereq_("./light");
        _dereq_("./material");
        _dereq_("./tracked-controls");
      }, { "./camera": 112, "./geometry": 113, "./light": 115, "./material": 116, "./tracked-controls": 117 }], 115: [function(_dereq_, module3, exports3) {
        var registerSystem = _dereq_("../core/system").registerSystem;
        var bind = _dereq_("../utils/bind");
        var constants = _dereq_("../constants/");
        var DEFAULT_LIGHT_ATTR = "data-aframe-default-light";
        module3.exports.System = registerSystem("light", {
          init: function() {
            this.defaultLights = false;
            this.userDefinedLights = false;
            this.sceneEl.addEventListener("loaded", bind(this.setupDefaultLights, this));
          },
          /**
           * Notify scene that light has been added and to remove the default.
           *
           * @param {object} el - element holding the light component.
           */
          registerLight: function(el) {
            if (!el.hasAttribute(DEFAULT_LIGHT_ATTR)) {
              this.removeDefaultLights();
              this.userDefinedLights = true;
            }
          },
          removeDefaultLights: function() {
            var defaultLights;
            var sceneEl = this.sceneEl;
            if (!this.defaultLights) {
              return;
            }
            defaultLights = document.querySelectorAll("[" + DEFAULT_LIGHT_ATTR + "]");
            for (var i = 0; i < defaultLights.length; i++) {
              sceneEl.removeChild(defaultLights[i]);
            }
            this.defaultLights = false;
          },
          /**
           * Prescibe default lights to the scene.
           * Does so by injecting markup such that this state is not invisible.
           * These lights are removed if the user adds any lights.
           */
          setupDefaultLights: function() {
            var sceneEl = this.sceneEl;
            var ambientLight;
            var directionalLight;
            if (this.userDefinedLights || this.defaultLights) {
              return;
            }
            ambientLight = document.createElement("a-entity");
            directionalLight = document.createElement("a-entity");
            ambientLight.setAttribute("light", { color: "#BBB", type: "ambient" });
            ambientLight.setAttribute(DEFAULT_LIGHT_ATTR, "");
            ambientLight.setAttribute(constants.AFRAME_INJECTED, "");
            sceneEl.appendChild(ambientLight);
            directionalLight.setAttribute("light", { color: "#FFF", intensity: 0.6 });
            directionalLight.setAttribute("position", { x: -0.5, y: 1, z: 1 });
            directionalLight.setAttribute(DEFAULT_LIGHT_ATTR, "");
            directionalLight.setAttribute(constants.AFRAME_INJECTED, "");
            sceneEl.appendChild(directionalLight);
            this.defaultLights = true;
          }
        });
      }, { "../constants/": 54, "../core/system": 72, "../utils/bind": 118 }], 116: [function(_dereq_, module3, exports3) {
        var registerSystem = _dereq_("../core/system").registerSystem;
        var THREE2 = _dereq_("../lib/three");
        var utils = _dereq_("../utils/");
        var debug = utils.debug;
        var error = debug("components:texture:error");
        var TextureLoader = new THREE2.TextureLoader();
        var warn = debug("components:texture:warn");
        module3.exports.System = registerSystem("material", {
          init: function() {
            this.materials = {};
            this.textureCache = {};
          },
          clearTextureCache: function() {
            this.textureCache = {};
          },
          /**
           * Determine whether `src` is a image or video. Then try to load the asset, then call back.
           *
           * @param {string, or element} src - Texture URL or element.
           * @param {string} data - Relevant texture data used for caching.
           * @param {function} cb - Callback to pass texture to.
           */
          loadTexture: function(src, data, cb) {
            var self2 = this;
            if (src.tagName === "CANVAS") {
              this.loadCanvas(src, data, cb);
              return;
            }
            if (src.tagName === "VIDEO") {
              if (!src.hasAttribute("src") && !src.hasAttribute("srcObject")) {
                warn("Video element was defined without `src` nor `srcObject` attributes.");
              }
              this.loadVideo(src, data, cb);
              return;
            }
            utils.srcLoader.validateSrc(src, loadImageCb, loadVideoCb);
            function loadImageCb(src2) {
              self2.loadImage(src2, data, cb);
            }
            function loadVideoCb(src2) {
              self2.loadVideo(src2, data, cb);
            }
          },
          /**
           * High-level function for loading image textures (THREE.Texture).
           *
           * @param {Element|string} src - Texture source.
           * @param {object} data - Texture data.
           * @param {function} cb - Callback to pass texture to.
           */
          loadImage: function(src, data, cb) {
            var hash = this.hash(data);
            var handleImageTextureLoaded = cb;
            var textureCache = this.textureCache;
            if (textureCache[hash]) {
              textureCache[hash].then(handleImageTextureLoaded);
              return;
            }
            textureCache[hash] = loadImageTexture(src, data);
            textureCache[hash].then(handleImageTextureLoaded);
          },
          /**
           * High-level function for loading canvas textures (THREE.Texture).
           *
           * @param {Element|string} src - Texture source.
           * @param {object} data - Texture data.
           * @param {function} cb - Callback to pass texture to.
           */
          loadCanvas: function(src, data, cb) {
            src.readyState = 2;
            src.HAVE_CURRENT_DATA = 2;
            this.loadVideo(src, data, cb);
          },
          /**
          * Load video texture (THREE.VideoTexture).
          * Which is just an image texture that RAFs + needsUpdate.
          * Note that creating a video texture is synchronous unlike loading an image texture.
          * Made asynchronous to be consistent with image textures.
          *
          * @param {Element|string} src - Texture source.
          * @param {object} data - Texture data.
          * @param {function} cb - Callback to pass texture to.
          */
          loadVideo: function(src, data, cb) {
            var hash;
            var texture;
            var textureCache = this.textureCache;
            var videoEl;
            var videoTextureResult;
            function handleVideoTextureLoaded(result) {
              result.texture.needsUpdate = true;
              cb(result.texture, result.videoEl);
            }
            if (typeof src !== "string") {
              videoEl = src;
              hash = this.hashVideo(data, videoEl);
              if (textureCache[hash]) {
                textureCache[hash].then(handleVideoTextureLoaded);
                return;
              }
              fixVideoAttributes(videoEl);
            }
            videoEl = videoEl || createVideoEl(src, data.width, data.height);
            hash = this.hashVideo(data, videoEl);
            if (textureCache[hash]) {
              textureCache[hash].then(handleVideoTextureLoaded);
              return;
            }
            texture = new THREE2.VideoTexture(videoEl);
            texture.minFilter = THREE2.LinearFilter;
            setTextureProperties(texture, data);
            videoTextureResult = { texture, videoEl };
            textureCache[hash] = Promise.resolve(videoTextureResult);
            handleVideoTextureLoaded(videoTextureResult);
          },
          hash: function(data) {
            return JSON.stringify(data);
          },
          hashVideo: function(data, videoEl) {
            return calculateVideoCacheHash(data, videoEl);
          },
          /**
           * Keep track of material in case an update trigger is needed (e.g., fog).
           *
           * @param {object} material
           */
          registerMaterial: function(material) {
            this.materials[material.uuid] = material;
          },
          /**
           * Stop tracking material.
           *
           * @param {object} material
           */
          unregisterMaterial: function(material) {
            delete this.materials[material.uuid];
          },
          /**
           * Trigger update to all registered materials.
           */
          updateMaterials: function(material) {
            var materials = this.materials;
            Object.keys(materials).forEach(function(uuid) {
              materials[uuid].needsUpdate = true;
            });
          }
        });
        function calculateVideoCacheHash(data, videoEl) {
          var i;
          var id = videoEl.getAttribute("id");
          var hash;
          var videoAttributes;
          if (id) {
            return id;
          }
          hash = "";
          videoAttributes = data || {};
          for (i = 0; i < videoEl.attributes.length; i++) {
            videoAttributes[videoEl.attributes[i].name] = videoEl.attributes[i].value;
          }
          Object.keys(videoAttributes).sort().forEach(function(name) {
            hash += name + ":" + videoAttributes[name] + ";";
          });
          return hash;
        }
        function loadImageTexture(src, data) {
          return new Promise(doLoadImageTexture);
          function doLoadImageTexture(resolve, reject) {
            var isEl = typeof src !== "string";
            function resolveTexture(texture) {
              setTextureProperties(texture, data);
              texture.needsUpdate = true;
              resolve(texture);
            }
            if (isEl) {
              resolveTexture(new THREE2.Texture(src));
              return;
            }
            TextureLoader.load(
              src,
              resolveTexture,
              function() {
              },
              function(xhr) {
                error(
                  "`$s` could not be fetched (Error code: %s; Response: %s)",
                  xhr.status,
                  xhr.statusText
                );
              }
            );
          }
        }
        function setTextureProperties(texture, data) {
          var offset = data.offset || { x: 0, y: 0 };
          var repeat = data.repeat || { x: 1, y: 1 };
          if (repeat.x === 1 && repeat.y === 1) {
            return;
          }
          texture.wrapS = THREE2.RepeatWrapping;
          texture.wrapT = THREE2.RepeatWrapping;
          texture.repeat.set(repeat.x, repeat.y);
          if (offset.x === 0 && offset.y === 0) {
            return;
          }
          texture.offset.set(offset.x, offset.y);
        }
        function createVideoEl(src, width, height) {
          var videoEl = document.createElement("video");
          videoEl.width = width;
          videoEl.height = height;
          videoEl.setAttribute("webkit-playsinline", "");
          videoEl.autoplay = true;
          videoEl.loop = true;
          videoEl.crossOrigin = "anonymous";
          videoEl.addEventListener("error", function() {
            warn("`$s` is not a valid video", src);
          }, true);
          videoEl.src = src;
          return videoEl;
        }
        function fixVideoAttributes(videoEl) {
          videoEl.autoplay = videoEl.getAttribute("autoplay") !== "false";
          videoEl.controls = videoEl.getAttribute("controls") !== "false";
          if (videoEl.getAttribute("loop") === "false") {
            videoEl.removeAttribute("loop");
          }
          if (videoEl.getAttribute("preload") === "false") {
            videoEl.preload = "none";
          }
          videoEl.crossOrigin = videoEl.crossOrigin || "anonymous";
          videoEl.setAttribute("webkit-playsinline", "");
          return videoEl;
        }
      }, { "../core/system": 72, "../lib/three": 106, "../utils/": 124 }], 117: [function(_dereq_, module3, exports3) {
        var registerSystem = _dereq_("../core/system").registerSystem;
        var trackedControlsUtils = _dereq_("../utils/tracked-controls");
        module3.exports.System = registerSystem("tracked-controls", {
          init: function() {
            var self2 = this;
            this.controllers = [];
            this.lastControllersUpdate = 0;
            if (!navigator.getVRDisplays) {
              return;
            }
            navigator.getVRDisplays().then(function(displays) {
              if (displays.length > 0) {
                self2.vrDisplay = displays[0];
              }
            });
          },
          updateControllerList: function() {
            var controllers = this.controllers = [];
            var gamepads = trackedControlsUtils.getGamepadsByPrefix("");
            for (var i = 0; i < gamepads.length; i++) {
              var gamepad = gamepads[i];
              if (gamepad && gamepad.pose) {
                controllers.push(gamepad);
              }
            }
          },
          tick: function(time) {
            if (time < this.lastControllersUpdate + 10) {
              return;
            }
            this.lastControllersUpdate = time;
            this.updateControllerList();
            this.sceneEl.emit("controllersupdated", { timestamp: time, controllers: this.controllers });
          }
        });
      }, { "../core/system": 72, "../utils/tracked-controls": 128 }], 118: [function(_dereq_, module3, exports3) {
        module3.exports = function bind(fn, ctx) {
          return /* @__PURE__ */ function(prependedArgs) {
            return function bound() {
              var args = prependedArgs.concat(Array.prototype.slice.call(arguments, 0));
              return fn.apply(ctx, args);
            };
          }(Array.prototype.slice.call(arguments, 2));
        };
      }, {}], 119: [function(_dereq_, module3, exports3) {
        var extend = _dereq_("object-assign");
        var regex = /\s*(-?\d*\.{0,1}\d+)\s+(-?\d*\.{0,1}\d+)\s+(-?\d*\.{0,1}\d+)\s*/;
        module3.exports.regex = regex;
        function parse(value, defaultVec) {
          var coordinate;
          var vec = {};
          if (value && typeof value === "object") {
            return vecParseFloat(value);
          }
          if (typeof value !== "string" || value === null) {
            return typeof defaultVec === "object" ? extend({}, defaultVec) : defaultVec;
          }
          coordinate = value.trim().replace(/\s+/g, " ").split(" ");
          vec.x = coordinate[0] || defaultVec && defaultVec.x;
          vec.y = coordinate[1] || defaultVec && defaultVec.y;
          vec.z = coordinate[2] || defaultVec && defaultVec.z;
          vec.w = coordinate[3] || defaultVec && defaultVec.w;
          return vecParseFloat(vec);
        }
        module3.exports.parse = parse;
        function stringify(data) {
          if (typeof data !== "object") {
            return data;
          }
          return [data.x, data.y, data.z, data.w].join(" ").trim();
        }
        module3.exports.stringify = stringify;
        module3.exports.isCoordinate = function(value) {
          return regex.test(value);
        };
        function vecParseFloat(vec) {
          Object.keys(vec).forEach(function(key) {
            if (vec[key] === void 0) {
              delete vec[key];
              return;
            }
            vec[key] = parseFloat(vec[key], 10);
          });
          return vec;
        }
        module3.exports.toVector3 = function(vec3) {
          return new THREE.Vector3(vec3.x, vec3.y, vec3.z);
        };
      }, { "object-assign": 9 }], 120: [function(_dereq_, module3, exports3) {
        (function(process) {
          var debugLib = _dereq_("debug");
          var extend = _dereq_("object-assign");
          var settings = {
            colors: {
              debug: "gray",
              error: "red",
              info: "gray",
              warn: "orange"
            }
          };
          var debug = function(namespace) {
            var d = debugLib(namespace);
            d.color = getDebugNamespaceColor(namespace);
            return d;
          };
          extend(debug, debugLib);
          function getDebugNamespaceType(namespace) {
            var chunks = namespace.split(":");
            return chunks[chunks.length - 1];
          }
          function getDebugNamespaceColor(namespace) {
            var type = getDebugNamespaceType(namespace);
            var color = settings.colors && settings.colors[type];
            return color || null;
          }
          function storage() {
            try {
              return window.localStorage;
            } catch (e2) {
            }
          }
          var ls = storage();
          if (ls && (parseInt(ls.logs, 10) || ls.logs === "true")) {
            debug.enable("*");
          } else {
            debug.enable("*:error,*:info,*:warn");
          }
          if (process.browser) {
            window.logs = debug;
          }
          module3.exports = debug;
        }).call(this, _dereq_("_process"));
      }, { "_process": 2, "debug": 3, "object-assign": 9 }], 121: [function(_dereq_, module3, exports3) {
        var THREE2 = _dereq_("../lib/three");
        var dolly = new THREE2.Object3D();
        var controls = new THREE2.VRControls(dolly);
        function checkHeadsetConnected() {
          var orientation;
          controls.update();
          orientation = dolly.quaternion;
          if (orientation._x !== 0 || orientation._y !== 0 || orientation._z !== 0) {
            return true;
          }
          return false;
        }
        module3.exports.checkHeadsetConnected = checkHeadsetConnected;
        function checkHasPositionalTracking() {
          var position = new THREE2.Vector3();
          return function() {
            if (isMobile() || isGearVR()) {
              return false;
            }
            controls.update();
            dolly.updateMatrix();
            position.setFromMatrixPosition(dolly.matrix);
            if (position.x !== 0 || position.y !== 0 || position.z !== 0) {
              return true;
            }
            return false;
          }();
        }
        module3.exports.checkHasPositionalTracking = checkHasPositionalTracking;
        var isMobile = function() {
          var _isMobile = false;
          (function(a) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
              _isMobile = true;
            }
            if (isIOS()) {
              _isMobile = true;
            }
            if (isGearVR()) {
              _isMobile = false;
            }
          })(navigator.userAgent || navigator.vendor || window.opera);
          return function() {
            return _isMobile;
          };
        }();
        module3.exports.isMobile = isMobile;
        function isIOS() {
          return /iPad|iPhone|iPod/.test(navigator.platform);
        }
        module3.exports.isIOS = isIOS;
        function isGearVR() {
          return /SamsungBrowser.+Mobile VR/i.test(navigator.userAgent);
        }
        module3.exports.isGearVR = isGearVR;
        module3.exports.isLandscape = function() {
          return window.orientation === 90 || window.orientation === -90;
        };
      }, { "../lib/three": 106 }], 122: [function(_dereq_, module3, exports3) {
        module3.exports.getComponentPropertyPath = function(str, delimiter) {
          delimiter = delimiter || ".";
          if (str.indexOf(delimiter) === -1) {
            return str;
          }
          return str.split(delimiter);
        };
        module3.exports.getComponentProperty = function(el, name, delimiter) {
          var splitName;
          delimiter = delimiter || ".";
          if (name.indexOf(delimiter) !== -1) {
            splitName = name.split(delimiter);
            return el.getAttribute(splitName[0])[splitName[1]];
          }
          return el.getAttribute(name);
        };
        module3.exports.setComponentProperty = function(el, name, value, delimiter) {
          var splitName;
          delimiter = delimiter || ".";
          if (name.indexOf(delimiter) !== -1) {
            splitName = name.split(delimiter);
            el.setAttribute(splitName[0], splitName[1], value);
            return;
          }
          el.setAttribute(name, value);
        };
      }, {}], 123: [function(_dereq_, module3, exports3) {
        module3.exports = function forceCanvasResizeSafariMobile(canvasEl) {
          var width = canvasEl.style.width;
          var height = canvasEl.style.height;
          canvasEl.style.width = parseInt(width, 10) + 1 + "px";
          canvasEl.style.height = parseInt(height, 10) + 1 + "px";
          setTimeout(function() {
            canvasEl.style.width = width;
            canvasEl.style.height = height;
          }, 200);
        };
      }, {}], 124: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("./debug");
        var deepAssign = _dereq_("deep-assign");
        var device = _dereq_("./device");
        var objectAssign = _dereq_("object-assign");
        var warn = debug("utils:warn");
        module3.exports.bind = _dereq_("./bind");
        module3.exports.coordinates = _dereq_("./coordinates");
        module3.exports.debug = debug;
        module3.exports.device = device;
        module3.exports.entity = _dereq_("./entity");
        module3.exports.forceCanvasResizeSafariMobile = _dereq_("./forceCanvasResizeSafariMobile");
        module3.exports.material = _dereq_("./material");
        module3.exports.styleParser = _dereq_("./styleParser");
        module3.exports.trackedControls = _dereq_("./tracked-controls");
        module3.exports.checkHeadsetConnected = function() {
          warn("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`");
          return device.checkHeadsetConnected(arguments);
        };
        module3.exports.isGearVR = function() {
          warn("`utils.isGearVR` has moved to `utils.device.isGearVR`");
          return device.isGearVR(arguments);
        };
        module3.exports.isIOS = function() {
          warn("`utils.isIOS` has moved to `utils.device.isIOS`");
          return device.isIOS(arguments);
        };
        module3.exports.isMobile = function() {
          warn("`utils.isMobile has moved to `utils.device.isMobile`");
          return device.isMobile(arguments);
        };
        module3.exports.fireEvent = function(el, name, data) {
          data = data || {};
          data.detail = data.detail || {};
          data.detail.target = data.detail.target || el;
          var evt = new CustomEvent(name, data);
          el.dispatchEvent(evt);
        };
        module3.exports.extend = objectAssign;
        module3.exports.extendDeep = deepAssign;
        module3.exports.clone = function(obj) {
          return JSON.parse(JSON.stringify(obj));
        };
        function deepEqual(a, b) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          var i;
          if (keysA.length !== keysB.length) {
            return false;
          }
          if (keysA.length === 0) {
            return a === b;
          }
          for (i = 0; i < keysA.length; ++i) {
            if (a[keysA[i]] !== b[keysA[i]]) {
              return false;
            }
          }
          return true;
        }
        module3.exports.deepEqual = deepEqual;
        module3.exports.diff = function(a, b) {
          var diff = {};
          var keys = Object.keys(a);
          Object.keys(b).forEach(function collectKeys(bKey) {
            if (keys.indexOf(bKey) === -1) {
              keys.push(bKey);
            }
          });
          keys.forEach(function doDiff(key) {
            var aVal = a[key];
            var bVal = b[key];
            var isComparingObjects = aVal && bVal && aVal.constructor === Object && bVal.constructor === Object;
            if (isComparingObjects && !deepEqual(aVal, bVal) || !isComparingObjects && aVal !== bVal) {
              diff[key] = bVal;
            }
          });
          return diff;
        };
        module3.exports.shouldCaptureKeyEvent = function(event) {
          if (event.metaKey) {
            return false;
          }
          return document.activeElement === document.body;
        };
        module3.exports.splitString = function(str, delimiter) {
          if (typeof delimiter === "undefined") {
            delimiter = " ";
          }
          var regex = new RegExp(delimiter, "g");
          str = (str || "").replace(regex, delimiter);
          return str.split(delimiter);
        };
        module3.exports.getElData = function(el, defaults) {
          defaults = defaults || {};
          var data = {};
          Object.keys(defaults).forEach(copyAttribute);
          function copyAttribute(key) {
            if (el.hasAttribute(key)) {
              data[key] = el.getAttribute(key);
            }
          }
          return data;
        };
        module3.exports.getUrlParameter = function(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
          var results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        };
        module3.exports.isIframed = function() {
          return window.top !== window.self;
        };
        module3.exports.findAllScenes = function(el) {
          var matchingElements = [];
          var allElements = el.getElementsByTagName("*");
          for (var i = 0, n = allElements.length; i < n; i++) {
            if (allElements[i].isScene) {
              matchingElements.push(allElements[i]);
            }
          }
          return matchingElements;
        };
        module3.exports.srcLoader = _dereq_("./src-loader");
      }, { "./bind": 118, "./coordinates": 119, "./debug": 120, "./device": 121, "./entity": 122, "./forceCanvasResizeSafariMobile": 123, "./material": 125, "./src-loader": 126, "./styleParser": 127, "./tracked-controls": 128, "deep-assign": 6, "object-assign": 9 }], 125: [function(_dereq_, module3, exports3) {
        module3.exports.updateMap = function(shader, data) {
          var el = shader.el;
          var material = shader.material;
          var src = data.src;
          if (src) {
            if (src === shader.textureSrc) {
              return;
            }
            shader.textureSrc = src;
            el.sceneEl.systems.material.loadTexture(src, { src, repeat: data.repeat, offset: data.offset }, setMap);
            return;
          }
          if (!material.map) {
            return;
          }
          setMap(null);
          function setMap(texture) {
            material.map = texture;
            material.needsUpdate = true;
            handleTextureEvents(el, texture);
          }
        };
        module3.exports.updateDistortionMap = function(longType, shader, data) {
          var shortType = longType;
          if (longType === "ambientOcclusion") {
            shortType = "ao";
          }
          var el = shader.el;
          var material = shader.material;
          var src = data[longType + "Map"];
          var info = {};
          info.src = src;
          info.offset = data[longType + "TextureOffset"];
          info.repeat = data[longType + "TextureRepeat"];
          info.wrap = data[longType + "TextureWrap"];
          if (src) {
            if (src === shader[longType + "TextureSrc"]) {
              return;
            }
            shader[longType + "TextureSrc"] = src;
            el.sceneEl.systems.material.loadTexture(src, info, setMap);
            return;
          }
          if (!material.map) {
            return;
          }
          setMap(null);
          function setMap(texture) {
            material[shortType + "Map"] = texture;
            material.needsUpdate = true;
            handleTextureEvents(el, texture);
          }
        };
        function handleTextureEvents(el, texture) {
          if (!texture) {
            return;
          }
          el.emit("materialtextureloaded", { src: texture.image, texture });
          if (texture.image.tagName !== "VIDEO") {
            return;
          }
          texture.image.addEventListener("loadeddata", function emitVideoTextureLoadedDataAll() {
            el.emit("materialvideoloadeddata", { src: texture.image, texture });
          });
          texture.image.addEventListener("ended", function emitVideoTextureEndedAll() {
            el.emit("materialvideoended", { src: texture.image, texture });
          });
        }
        module3.exports.handleTextureEvents = handleTextureEvents;
      }, {}], 126: [function(_dereq_, module3, exports3) {
        var debug = _dereq_("./debug");
        var warn = debug("utils:src-loader:warn");
        function validateSrc(src, isImageCb, isVideoCb) {
          validateImageUrl(src, function isAnImageUrl(isImage) {
            if (isImage) {
              isImageCb(src);
              return;
            }
            isVideoCb(src);
          });
        }
        function validateCubemapSrc(src, cb) {
          var aCubemap;
          var cubemapSrcRegex = "";
          var i;
          var urls;
          var validatedUrls = [];
          for (i = 0; i < 5; i++) {
            cubemapSrcRegex += "(url\\((?:[^\\)]+)\\),\\s*)";
          }
          cubemapSrcRegex += "(url\\((?:[^\\)]+)\\)\\s*)";
          urls = src.match(new RegExp(cubemapSrcRegex));
          function isImageCb(url) {
            validatedUrls.push(url);
            if (validatedUrls.length === 6) {
              cb(validatedUrls);
            }
          }
          if (urls) {
            for (i = 1; i < 7; i++) {
              validateSrc(parseUrl(urls[i]), isImageCb);
            }
            return;
          }
          aCubemap = validateAndGetQuerySelector(src);
          if (!aCubemap) {
            return;
          }
          if (aCubemap.tagName === "A-CUBEMAP" && aCubemap.srcs) {
            return cb(aCubemap.srcs);
          }
          warn('Selector "%s" does not point to <a-cubemap>', src);
        }
        function parseUrl(src) {
          var parsedSrc = src.match(/\url\((.+)\)/);
          if (!parsedSrc) {
            return;
          }
          return parsedSrc[1];
        }
        function validateImageUrl(src, onResult) {
          var tester = new Image();
          tester.addEventListener("load", onLoad);
          function onLoad() {
            onResult(true);
          }
          tester.addEventListener("error", onError);
          function onError() {
            onResult(false);
          }
          tester.src = src;
        }
        function validateAndGetQuerySelector(selector) {
          try {
            var el = document.querySelector(selector);
            if (!el) {
              warn('No element was found matching the selector: "%s"', selector);
            }
            return el;
          } catch (e2) {
            warn('"%s" is not a valid selector', selector);
            return void 0;
          }
        }
        module3.exports = {
          parseUrl,
          validateSrc,
          validateCubemapSrc
        };
      }, { "./debug": 120 }], 127: [function(_dereq_, module3, exports3) {
        var styleParser = _dereq_("style-attr");
        module3.exports.parse = function(value) {
          var parsedData;
          if (typeof value !== "string") {
            return value;
          }
          parsedData = styleParser.parse(value);
          if (parsedData[""]) {
            return value;
          }
          return transformKeysToCamelCase(parsedData);
        };
        module3.exports.stringify = function(data) {
          if (typeof data === "string") {
            return data;
          }
          return styleParser.stringify(data);
        };
        function toCamelCase(str) {
          return str.replace(/-([a-z])/g, camelCase);
          function camelCase(g) {
            return g[1].toUpperCase();
          }
        }
        module3.exports.toCamelCase = toCamelCase;
        function transformKeysToCamelCase(obj) {
          var keys = Object.keys(obj);
          var camelCaseObj = {};
          keys.forEach(function(key) {
            var camelCaseKey = toCamelCase(key);
            camelCaseObj[camelCaseKey] = obj[key];
          });
          return camelCaseObj;
        }
        module3.exports.transformKeysToCamelCase = transformKeysToCamelCase;
      }, { "style-attr": 12 }], 128: [function(_dereq_, module3, exports3) {
        module3.exports.getGamepadsByPrefix = function(idPrefix) {
          var gamepadsList = [];
          var gamepad;
          var gamepads = navigator.getGamepads && navigator.getGamepads();
          if (!gamepads) {
            return gamepadsList;
          }
          for (var i = 0; i < gamepads.length; ++i) {
            gamepad = gamepads[i];
            if (gamepad) {
              if (!idPrefix || gamepad.id.indexOf(idPrefix) === 0) {
                gamepadsList.push(gamepad);
              }
            }
          }
          return gamepadsList;
        };
        module3.exports.isControllerPresent = function(sceneEl, idPrefix, queryObject) {
          var isPresent = false;
          var index = 0;
          var gamepad;
          var isPrefixMatch;
          var gamepads;
          var trackedControlsSystem = sceneEl && sceneEl.systems["tracked-controls"];
          if (!trackedControlsSystem) {
            return isPresent;
          }
          gamepads = trackedControlsSystem.controllers;
          if (!gamepads || gamepads.length === 0) {
            trackedControlsSystem.updateControllerList();
            gamepads = trackedControlsSystem.controllers;
          }
          if (!gamepads) {
            return isPresent;
          }
          for (var i = 0; i < gamepads.length; ++i) {
            gamepad = gamepads[i];
            isPrefixMatch = !idPrefix || idPrefix === "" || gamepad.id.indexOf(idPrefix) === 0;
            isPresent = isPrefixMatch;
            if (isPresent && queryObject.hand) {
              isPresent = gamepad.hand === queryObject.hand;
            }
            if (isPresent && queryObject.index) {
              isPresent = index === queryObject.index;
            }
            if (isPresent) {
              break;
            }
            if (isPrefixMatch) {
              index++;
            }
          }
          return isPresent;
        };
      }, {}], 129: [function(_dereq_, module3, exports3) {
        THREE.VRControls = function(object, onError) {
          var scope = this;
          var vrDisplay, vrDisplays;
          var standingMatrix = new THREE.Matrix4();
          var frameData = null;
          if ("VRFrameData" in window) {
            frameData = new VRFrameData();
          }
          function gotVRDisplays(displays) {
            vrDisplays = displays;
            if (displays.length > 0) {
              vrDisplay = displays[0];
            } else {
              if (onError)
                onError("VR input not available.");
            }
          }
          if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(gotVRDisplays).catch(function() {
              console.warn("THREE.VRControls: Unable to get VR Displays");
            });
          }
          this.scale = 1;
          this.standing = false;
          this.userHeight = 1.6;
          this.getVRDisplay = function() {
            return vrDisplay;
          };
          this.setVRDisplay = function(value) {
            vrDisplay = value;
          };
          this.getVRDisplays = function() {
            console.warn("THREE.VRControls: getVRDisplays() is being deprecated.");
            return vrDisplays;
          };
          this.getStandingMatrix = function() {
            return standingMatrix;
          };
          this.update = function() {
            if (vrDisplay) {
              var pose;
              if (vrDisplay.getFrameData) {
                vrDisplay.getFrameData(frameData);
                pose = frameData.pose;
              } else if (vrDisplay.getPose) {
                pose = vrDisplay.getPose();
              }
              if (pose.orientation !== null) {
                object.quaternion.fromArray(pose.orientation);
              }
              if (pose.position !== null) {
                object.position.fromArray(pose.position);
              } else {
                object.position.set(0, 0, 0);
              }
              if (this.standing) {
                if (vrDisplay.stageParameters) {
                  object.updateMatrix();
                  standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
                  object.applyMatrix(standingMatrix);
                } else {
                  object.position.setY(object.position.y + this.userHeight);
                }
              }
              object.position.multiplyScalar(scope.scale);
            }
          };
          this.resetPose = function() {
            if (vrDisplay) {
              vrDisplay.resetPose();
            }
          };
          this.resetSensor = function() {
            console.warn("THREE.VRControls: .resetSensor() is now .resetPose().");
            this.resetPose();
          };
          this.zeroSensor = function() {
            console.warn("THREE.VRControls: .zeroSensor() is now .resetPose().");
            this.resetPose();
          };
          this.dispose = function() {
            vrDisplay = null;
          };
        };
      }, {}], 130: [function(_dereq_, module3, exports3) {
        THREE.VREffect = function(renderer, onError) {
          var vrDisplay, vrDisplays;
          var eyeTranslationL = new THREE.Vector3();
          var eyeTranslationR = new THREE.Vector3();
          var renderRectL, renderRectR;
          var frameData = null;
          if ("VRFrameData" in window) {
            frameData = new VRFrameData();
          }
          function gotVRDisplays(displays) {
            vrDisplays = displays;
            if (displays.length > 0) {
              vrDisplay = displays[0];
            } else {
              if (onError)
                onError("HMD not available");
            }
          }
          if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(gotVRDisplays).catch(function() {
              console.warn("THREE.VREffect: Unable to get VR Displays");
            });
          }
          this.isPresenting = false;
          this.scale = 1;
          var scope = this;
          var rendererSize = renderer.getSize();
          var rendererUpdateStyle = false;
          var rendererPixelRatio = renderer.getPixelRatio();
          this.getVRDisplay = function() {
            return vrDisplay;
          };
          this.setVRDisplay = function(value) {
            vrDisplay = value;
          };
          this.getVRDisplays = function() {
            console.warn("THREE.VREffect: getVRDisplays() is being deprecated.");
            return vrDisplays;
          };
          this.setSize = function(width, height, updateStyle) {
            rendererSize = { width, height };
            rendererUpdateStyle = updateStyle;
            if (scope.isPresenting) {
              var eyeParamsL = vrDisplay.getEyeParameters("left");
              renderer.setPixelRatio(1);
              renderer.setSize(eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false);
            } else {
              renderer.setPixelRatio(rendererPixelRatio);
              renderer.setSize(width, height, updateStyle);
            }
          };
          var canvas = renderer.domElement;
          var requestFullscreen;
          var exitFullscreen;
          var fullscreenElement;
          var defaultLeftBounds = [0, 0, 0.5, 1];
          var defaultRightBounds = [0.5, 0, 0.5, 1];
          function onVRDisplayPresentChange() {
            var wasPresenting = scope.isPresenting;
            scope.isPresenting = vrDisplay !== void 0 && vrDisplay.isPresenting;
            if (scope.isPresenting) {
              var eyeParamsL = vrDisplay.getEyeParameters("left");
              var eyeWidth = eyeParamsL.renderWidth;
              var eyeHeight = eyeParamsL.renderHeight;
              if (!wasPresenting) {
                rendererPixelRatio = renderer.getPixelRatio();
                rendererSize = renderer.getSize();
                renderer.setPixelRatio(1);
                renderer.setSize(eyeWidth * 2, eyeHeight, false);
              }
            } else if (wasPresenting) {
              renderer.setPixelRatio(rendererPixelRatio);
              renderer.setSize(rendererSize.width, rendererSize.height, rendererUpdateStyle);
            }
          }
          window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
          this.setFullScreen = function(boolean) {
            return new Promise(function(resolve, reject) {
              if (vrDisplay === void 0) {
                reject(new Error("No VR hardware found."));
                return;
              }
              if (scope.isPresenting === boolean) {
                resolve();
                return;
              }
              if (boolean) {
                resolve(vrDisplay.requestPresent([{ source: canvas }]));
              } else {
                resolve(vrDisplay.exitPresent());
              }
            });
          };
          this.requestPresent = function() {
            return this.setFullScreen(true);
          };
          this.exitPresent = function() {
            return this.setFullScreen(false);
          };
          this.requestAnimationFrame = function(f) {
            if (vrDisplay !== void 0) {
              return vrDisplay.requestAnimationFrame(f);
            } else {
              return window.requestAnimationFrame(f);
            }
          };
          this.cancelAnimationFrame = function(h) {
            if (vrDisplay !== void 0) {
              vrDisplay.cancelAnimationFrame(h);
            } else {
              window.cancelAnimationFrame(h);
            }
          };
          this.submitFrame = function() {
            if (vrDisplay !== void 0 && scope.isPresenting) {
              vrDisplay.submitFrame();
            }
          };
          this.autoSubmitFrame = true;
          var cameraL = new THREE.PerspectiveCamera();
          cameraL.layers.enable(1);
          var cameraR = new THREE.PerspectiveCamera();
          cameraR.layers.enable(2);
          this.render = function(scene, camera, renderTarget, forceClear) {
            if (vrDisplay && scope.isPresenting) {
              var autoUpdate = scene.autoUpdate;
              if (autoUpdate) {
                scene.updateMatrixWorld();
                scene.autoUpdate = false;
              }
              var eyeParamsL = vrDisplay.getEyeParameters("left");
              var eyeParamsR = vrDisplay.getEyeParameters("right");
              eyeTranslationL.fromArray(eyeParamsL.offset);
              eyeTranslationR.fromArray(eyeParamsR.offset);
              if (Array.isArray(scene)) {
                console.warn("THREE.VREffect.render() no longer supports arrays. Use object.layers instead.");
                scene = scene[0];
              }
              var size = renderer.getSize();
              var layers = vrDisplay.getLayers();
              var leftBounds;
              var rightBounds;
              if (layers.length) {
                var layer = layers[0];
                leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
                rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;
              } else {
                leftBounds = defaultLeftBounds;
                rightBounds = defaultRightBounds;
              }
              renderRectL = {
                x: Math.round(size.width * leftBounds[0]),
                y: Math.round(size.height * leftBounds[1]),
                width: Math.round(size.width * leftBounds[2]),
                height: Math.round(size.height * leftBounds[3])
              };
              renderRectR = {
                x: Math.round(size.width * rightBounds[0]),
                y: Math.round(size.height * rightBounds[1]),
                width: Math.round(size.width * rightBounds[2]),
                height: Math.round(size.height * rightBounds[3])
              };
              if (renderTarget) {
                renderer.setRenderTarget(renderTarget);
                renderTarget.scissorTest = true;
              } else {
                renderer.setRenderTarget(null);
                renderer.setScissorTest(true);
              }
              if (renderer.autoClear || forceClear)
                renderer.clear();
              if (camera.parent === null)
                camera.updateMatrixWorld();
              camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
              camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);
              var scale = this.scale;
              cameraL.translateOnAxis(eyeTranslationL, scale);
              cameraR.translateOnAxis(eyeTranslationR, scale);
              if (vrDisplay.getFrameData) {
                vrDisplay.depthNear = camera.near;
                vrDisplay.depthFar = camera.far;
                vrDisplay.getFrameData(frameData);
                cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
                cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;
              } else {
                cameraL.projectionMatrix = fovToProjection(eyeParamsL.fieldOfView, true, camera.near, camera.far);
                cameraR.projectionMatrix = fovToProjection(eyeParamsR.fieldOfView, true, camera.near, camera.far);
              }
              if (renderTarget) {
                renderTarget.viewport.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
                renderTarget.scissor.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
              } else {
                renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
                renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
              }
              renderer.render(scene, cameraL, renderTarget, forceClear);
              if (renderTarget) {
                renderTarget.viewport.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
                renderTarget.scissor.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
              } else {
                renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
                renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
              }
              renderer.render(scene, cameraR, renderTarget, forceClear);
              if (renderTarget) {
                renderTarget.viewport.set(0, 0, size.width, size.height);
                renderTarget.scissor.set(0, 0, size.width, size.height);
                renderTarget.scissorTest = false;
                renderer.setRenderTarget(null);
              } else {
                renderer.setViewport(0, 0, size.width, size.height);
                renderer.setScissorTest(false);
              }
              if (autoUpdate) {
                scene.autoUpdate = true;
              }
              if (scope.autoSubmitFrame) {
                scope.submitFrame();
              }
              return;
            }
            renderer.render(scene, camera, renderTarget, forceClear);
          };
          this.dispose = function() {
            window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
          };
          function fovToNDCScaleOffset(fov) {
            var pxscale = 2 / (fov.leftTan + fov.rightTan);
            var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
            var pyscale = 2 / (fov.upTan + fov.downTan);
            var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
            return { scale: [pxscale, pyscale], offset: [pxoffset, pyoffset] };
          }
          function fovPortToProjection(fov, rightHanded, zNear, zFar) {
            rightHanded = rightHanded === void 0 ? true : rightHanded;
            zNear = zNear === void 0 ? 0.01 : zNear;
            zFar = zFar === void 0 ? 1e4 : zFar;
            var handednessScale = rightHanded ? -1 : 1;
            var mobj = new THREE.Matrix4();
            var m = mobj.elements;
            var scaleAndOffset = fovToNDCScaleOffset(fov);
            m[0 * 4 + 0] = scaleAndOffset.scale[0];
            m[0 * 4 + 1] = 0;
            m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
            m[0 * 4 + 3] = 0;
            m[1 * 4 + 0] = 0;
            m[1 * 4 + 1] = scaleAndOffset.scale[1];
            m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
            m[1 * 4 + 3] = 0;
            m[2 * 4 + 0] = 0;
            m[2 * 4 + 1] = 0;
            m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
            m[2 * 4 + 3] = zFar * zNear / (zNear - zFar);
            m[3 * 4 + 0] = 0;
            m[3 * 4 + 1] = 0;
            m[3 * 4 + 2] = handednessScale;
            m[3 * 4 + 3] = 0;
            mobj.transpose();
            return mobj;
          }
          function fovToProjection(fov, rightHanded, zNear, zFar) {
            var DEG2RAD = Math.PI / 180;
            var fovPort = {
              upTan: Math.tan(fov.upDegrees * DEG2RAD),
              downTan: Math.tan(fov.downDegrees * DEG2RAD),
              leftTan: Math.tan(fov.leftDegrees * DEG2RAD),
              rightTan: Math.tan(fov.rightDegrees * DEG2RAD)
            };
            return fovPortToProjection(fovPort, rightHanded, zNear, zFar);
          }
        };
      }, {}], 131: [function(_dereq_, module3, exports3) {
        window.glStats = function() {
          var _rS = null;
          var _totalDrawArraysCalls = 0, _totalDrawElementsCalls = 0, _totalUseProgramCalls = 0, _totalFaces = 0, _totalVertices = 0, _totalPoints = 0, _totalBindTexures = 0;
          function _h(f, c) {
            return function() {
              c.apply(this, arguments);
              f.apply(this, arguments);
            };
          }
          WebGLRenderingContext.prototype.drawArrays = _h(WebGLRenderingContext.prototype.drawArrays, function() {
            _totalDrawArraysCalls++;
            if (arguments[0] == this.POINTS)
              _totalPoints += arguments[2];
            else
              _totalVertices += arguments[2];
          });
          WebGLRenderingContext.prototype.drawElements = _h(WebGLRenderingContext.prototype.drawElements, function() {
            _totalDrawElementsCalls++;
            _totalFaces += arguments[1] / 3;
            _totalVertices += arguments[1];
          });
          WebGLRenderingContext.prototype.useProgram = _h(WebGLRenderingContext.prototype.useProgram, function() {
            _totalUseProgramCalls++;
          });
          WebGLRenderingContext.prototype.bindTexture = _h(WebGLRenderingContext.prototype.bindTexture, function() {
            _totalBindTexures++;
          });
          var _values = {
            allcalls: {
              over: 3e3,
              caption: "Calls (hook)"
            },
            drawelements: {
              caption: "drawElements (hook)"
            },
            drawarrays: {
              caption: "drawArrays (hook)"
            }
          };
          var _groups = [{
            caption: "WebGL",
            values: ["allcalls", "drawelements", "drawarrays", "useprogram", "bindtexture", "glfaces", "glvertices", "glpoints"]
          }];
          var _fractions = [{
            base: "allcalls",
            steps: ["drawelements", "drawarrays"]
          }];
          function _update() {
            _rS("allcalls").set(_totalDrawArraysCalls + _totalDrawElementsCalls);
            _rS("drawElements").set(_totalDrawElementsCalls);
            _rS("drawArrays").set(_totalDrawArraysCalls);
            _rS("bindTexture").set(_totalBindTexures);
            _rS("useProgram").set(_totalUseProgramCalls);
            _rS("glfaces").set(_totalFaces);
            _rS("glvertices").set(_totalVertices);
            _rS("glpoints").set(_totalPoints);
          }
          function _start() {
            _totalDrawArraysCalls = 0;
            _totalDrawElementsCalls = 0;
            _totalUseProgramCalls = 0;
            _totalFaces = 0;
            _totalVertices = 0;
            _totalPoints = 0;
            _totalBindTexures = 0;
          }
          function _end() {
          }
          function _attach(r) {
            _rS = r;
          }
          return {
            update: _update,
            start: _start,
            end: _end,
            attach: _attach,
            values: _values,
            groups: _groups,
            fractions: _fractions
          };
        };
        window.threeStats = function(renderer) {
          var _rS = null;
          var _values = {
            "renderer.info.memory.geometries": {
              caption: "Geometries"
            },
            "renderer.info.memory.textures": {
              caption: "Textures"
            },
            "renderer.info.programs": {
              caption: "Programs"
            },
            "renderer.info.render.calls": {
              caption: "Calls"
            },
            "renderer.info.render.faces": {
              caption: "Faces",
              over: 1e3
            },
            "renderer.info.render.points": {
              caption: "Points"
            },
            "renderer.info.render.vertices": {
              caption: "Vertices"
            }
          };
          var _groups = [{
            caption: "Three.js - Memory",
            values: ["renderer.info.memory.geometries", "renderer.info.programs", "renderer.info.memory.textures"]
          }, {
            caption: "Three.js - Render",
            values: ["renderer.info.render.calls", "renderer.info.render.faces", "renderer.info.render.points", "renderer.info.render.vertices"]
          }];
          var _fractions = [];
          function _update() {
            _rS("renderer.info.memory.geometries").set(renderer.info.memory.geometries);
            _rS("renderer.info.programs").set(renderer.info.programs.length);
            _rS("renderer.info.memory.textures").set(renderer.info.memory.textures);
            _rS("renderer.info.render.calls").set(renderer.info.render.calls);
            _rS("renderer.info.render.faces").set(renderer.info.render.faces);
            _rS("renderer.info.render.points").set(renderer.info.render.points);
            _rS("renderer.info.render.vertices").set(renderer.info.render.vertices);
          }
          function _start() {
          }
          function _end() {
          }
          function _attach(r) {
            _rS = r;
          }
          return {
            update: _update,
            start: _start,
            end: _end,
            attach: _attach,
            values: _values,
            groups: _groups,
            fractions: _fractions
          };
        };
        window.BrowserStats = function() {
          var _rS = null;
          var _usedJSHeapSize = 0, _totalJSHeapSize = 0;
          if (window.performance && !performance.memory) {
            performance.memory = {
              usedJSHeapSize: 0,
              totalJSHeapSize: 0
            };
          }
          if (performance.memory.totalJSHeapSize === 0) {
            console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");
          }
          var _values = {
            memory: {
              caption: "Used Memory",
              average: true,
              avgMs: 1e3,
              over: 22
            },
            total: {
              caption: "Total Memory"
            }
          };
          var _groups = [{
            caption: "Browser",
            values: ["memory", "total"]
          }];
          var _fractions = [{
            base: "total",
            steps: ["memory"]
          }];
          var log1024 = Math.log(1024);
          function _size(v) {
            var precision = 100;
            var i = Math.floor(Math.log(v) / log1024);
            return Math.round(v * precision / Math.pow(1024, i)) / precision;
          }
          function _update() {
            _usedJSHeapSize = _size(performance.memory.usedJSHeapSize);
            _totalJSHeapSize = _size(performance.memory.totalJSHeapSize);
            _rS("memory").set(_usedJSHeapSize);
            _rS("total").set(_totalJSHeapSize);
          }
          function _start() {
            _usedJSHeapSize = 0;
          }
          function _end() {
          }
          function _attach(r) {
            _rS = r;
          }
          return {
            update: _update,
            start: _start,
            end: _end,
            attach: _attach,
            values: _values,
            groups: _groups,
            fractions: _fractions
          };
        };
        if (typeof module3 === "object") {
          module3.exports = {
            glStats: window.glStats,
            threeStats: window.threeStats,
            BrowserStats: window.BrowserStats
          };
        }
      }, {}], 132: [function(_dereq_, module3, exports3) {
        "use strict";
        (function() {
          if (typeof window.performance === "undefined") {
            window.performance = {};
          }
          if (!window.performance.now) {
            var nowOffset = Date.now();
            if (performance.timing && performance.timing.navigationStart) {
              nowOffset = performance.timing.navigationStart;
            }
            window.performance.now = function now() {
              return Date.now() - nowOffset;
            };
          }
          if (!window.performance.mark) {
            window.performance.mark = function() {
            };
          }
          if (!window.performance.measure) {
            window.performance.measure = function() {
            };
          }
        })();
        window.rStats = function rStats(settings) {
          function iterateKeys(array, callback) {
            var keys = Object.keys(array);
            for (var j = 0, l = keys.length; j < l; j++) {
              callback(keys[j]);
            }
          }
          function importCSS(url) {
            var element = document.createElement("link");
            element.href = url;
            element.rel = "stylesheet";
            element.type = "text/css";
            document.getElementsByTagName("head")[0].appendChild(element);
          }
          var _settings = settings || {};
          var _colours = _settings.colours || ["#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c"];
          var _cssFont = "https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300";
          var _cssRStats = (_settings.CSSPath ? _settings.CSSPath : "") + "rStats.css";
          var _css = _settings.css || [_cssFont, _cssRStats];
          _css.forEach(function(uri) {
            importCSS(uri);
          });
          if (!_settings.values)
            _settings.values = {};
          var _base, _div, _elHeight = 10, _elWidth = 200;
          var _perfCounters = {};
          function Graph(_dom, _id, _defArg) {
            var _def = _defArg || {};
            var _canvas = document.createElement("canvas"), _ctx = _canvas.getContext("2d"), _max = 0, _current = 0;
            var c = _def.color ? _def.color : "#666666";
            var _dotCanvas = document.createElement("canvas"), _dotCtx = _dotCanvas.getContext("2d");
            _dotCanvas.width = 1;
            _dotCanvas.height = 2 * _elHeight;
            _dotCtx.fillStyle = "#444444";
            _dotCtx.fillRect(0, 0, 1, 2 * _elHeight);
            _dotCtx.fillStyle = c;
            _dotCtx.fillRect(0, _elHeight, 1, _elHeight);
            _dotCtx.fillStyle = "#ffffff";
            _dotCtx.globalAlpha = 0.5;
            _dotCtx.fillRect(0, _elHeight, 1, 1);
            _dotCtx.globalAlpha = 1;
            var _alarmCanvas = document.createElement("canvas"), _alarmCtx = _alarmCanvas.getContext("2d");
            _alarmCanvas.width = 1;
            _alarmCanvas.height = 2 * _elHeight;
            _alarmCtx.fillStyle = "#444444";
            _alarmCtx.fillRect(0, 0, 1, 2 * _elHeight);
            _alarmCtx.fillStyle = "#b70000";
            _alarmCtx.fillRect(0, _elHeight, 1, _elHeight);
            _alarmCtx.globalAlpha = 0.5;
            _alarmCtx.fillStyle = "#ffffff";
            _alarmCtx.fillRect(0, _elHeight, 1, 1);
            _alarmCtx.globalAlpha = 1;
            function _init2() {
              _canvas.width = _elWidth;
              _canvas.height = _elHeight;
              _canvas.style.width = _canvas.width + "px";
              _canvas.style.height = _canvas.height + "px";
              _canvas.className = "rs-canvas";
              _dom.appendChild(_canvas);
              _ctx.fillStyle = "#444444";
              _ctx.fillRect(0, 0, _canvas.width, _canvas.height);
            }
            function _draw(v, alarm) {
              _current += (v - _current) * 0.1;
              _max *= 0.99;
              if (_current > _max)
                _max = _current;
              _ctx.drawImage(_canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height);
              if (alarm) {
                _ctx.drawImage(_alarmCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight);
              } else {
                _ctx.drawImage(_dotCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight);
              }
            }
            _init2();
            return {
              draw: _draw
            };
          }
          function StackGraph(_dom, _num) {
            var _canvas = document.createElement("canvas"), _ctx = _canvas.getContext("2d");
            function _init2() {
              _canvas.width = _elWidth;
              _canvas.height = _elHeight * _num;
              _canvas.style.width = _canvas.width + "px";
              _canvas.style.height = _canvas.height + "px";
              _canvas.className = "rs-canvas";
              _dom.appendChild(_canvas);
              _ctx.fillStyle = "#444444";
              _ctx.fillRect(0, 0, _canvas.width, _canvas.height);
            }
            function _draw(v) {
              _ctx.drawImage(_canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height);
              var th = 0;
              iterateKeys(v, function(j) {
                var h = v[j] * _canvas.height;
                _ctx.fillStyle = _colours[j];
                _ctx.fillRect(_canvas.width - 1, th, 1, h);
                th += h;
              });
            }
            _init2();
            return {
              draw: _draw
            };
          }
          function PerfCounter(id, group) {
            var _id = id, _time, _value = 0, _total = 0, _averageValue = 0, _accumValue = 0, _accumStart = performance.now(), _accumSamples = 0, _dom = document.createElement("div"), _spanId = document.createElement("span"), _spanValue = document.createElement("div"), _spanValueText = document.createTextNode(""), _def = _settings ? _settings.values[_id.toLowerCase()] : null, _graph = new Graph(_dom, _id, _def), _started = false;
            _spanId.className = "rs-counter-id";
            _spanId.textContent = _def && _def.caption ? _def.caption : _id;
            _spanValue.className = "rs-counter-value";
            _spanValue.appendChild(_spanValueText);
            _dom.appendChild(_spanId);
            _dom.appendChild(_spanValue);
            if (group)
              group.div.appendChild(_dom);
            else
              _div.appendChild(_dom);
            _time = performance.now();
            function _average(v) {
              if (_def && _def.average) {
                _accumValue += v;
                _accumSamples++;
                var t = performance.now();
                if (t - _accumStart >= (_def.avgMs || 1e3)) {
                  _averageValue = _accumValue / _accumSamples;
                  _accumValue = 0;
                  _accumStart = t;
                  _accumSamples = 0;
                }
              }
            }
            function _start() {
              _time = performance.now();
              if (_settings.userTimingAPI)
                performance.mark(_id + "-start");
              _started = true;
            }
            function _end() {
              _value = performance.now() - _time;
              if (_settings.userTimingAPI) {
                performance.mark(_id + "-end");
                if (_started) {
                  performance.measure(_id, _id + "-start", _id + "-end");
                }
              }
              _average(_value);
            }
            function _tick() {
              _end();
              _start();
            }
            function _draw() {
              var v = _def && _def.average ? _averageValue : _value;
              _spanValueText.nodeValue = Math.round(v * 100) / 100;
              var a = _def && (_def.below && _value < _def.below || _def.over && _value > _def.over);
              _graph.draw(_value, a);
              _dom.className = a ? "rs-counter-base alarm" : "rs-counter-base";
            }
            function _frame() {
              var t = performance.now();
              var e2 = t - _time;
              _total++;
              if (e2 > 1e3) {
                if (_def && _def.interpolate === false) {
                  _value = _total;
                } else {
                  _value = _total * 1e3 / e2;
                }
                _total = 0;
                _time = t;
                _average(_value);
              }
            }
            function _set(v) {
              _value = v;
              _average(_value);
            }
            return {
              set: _set,
              start: _start,
              tick: _tick,
              end: _end,
              frame: _frame,
              value: function() {
                return _value;
              },
              draw: _draw
            };
          }
          function sample() {
            var _value = 0;
            function _set(v) {
              _value = v;
            }
            return {
              set: _set,
              value: function() {
                return _value;
              }
            };
          }
          function _perf(idArg) {
            var id = idArg.toLowerCase();
            if (id === void 0)
              id = "default";
            if (_perfCounters[id])
              return _perfCounters[id];
            var group = null;
            if (_settings && _settings.groups) {
              iterateKeys(_settings.groups, function(j) {
                var g = _settings.groups[parseInt(j, 10)];
                if (!group && g.values.indexOf(id.toLowerCase()) !== -1) {
                  group = g;
                }
              });
            }
            var p = new PerfCounter(id, group);
            _perfCounters[id] = p;
            return p;
          }
          function _init() {
            if (_settings.plugins) {
              if (!_settings.values)
                _settings.values = {};
              if (!_settings.groups)
                _settings.groups = [];
              if (!_settings.fractions)
                _settings.fractions = [];
              for (var j = 0; j < _settings.plugins.length; j++) {
                _settings.plugins[j].attach(_perf);
                iterateKeys(_settings.plugins[j].values, function(k) {
                  _settings.values[k] = _settings.plugins[j].values[k];
                });
                _settings.groups = _settings.groups.concat(_settings.plugins[j].groups);
                _settings.fractions = _settings.fractions.concat(_settings.plugins[j].fractions);
              }
            } else {
              _settings.plugins = {};
            }
            _base = document.createElement("div");
            _base.className = "rs-base";
            _div = document.createElement("div");
            _div.className = "rs-container";
            _div.style.height = "auto";
            _base.appendChild(_div);
            document.body.appendChild(_base);
            if (!_settings)
              return;
            if (_settings.groups) {
              iterateKeys(_settings.groups, function(j2) {
                var g = _settings.groups[parseInt(j2, 10)];
                var div = document.createElement("div");
                div.className = "rs-group";
                g.div = div;
                var h1 = document.createElement("h1");
                h1.textContent = g.caption;
                h1.addEventListener("click", (function(e2) {
                  this.classList.toggle("hidden");
                  e2.preventDefault();
                }).bind(div));
                _div.appendChild(h1);
                _div.appendChild(div);
              });
            }
            if (_settings.fractions) {
              iterateKeys(_settings.fractions, function(j2) {
                var f = _settings.fractions[parseInt(j2, 10)];
                var div = document.createElement("div");
                div.className = "rs-fraction";
                var legend = document.createElement("div");
                legend.className = "rs-legend";
                var h = 0;
                iterateKeys(_settings.fractions[j2].steps, function(k) {
                  var p = document.createElement("p");
                  p.textContent = _settings.fractions[j2].steps[k];
                  p.style.color = _colours[h];
                  legend.appendChild(p);
                  h++;
                });
                div.appendChild(legend);
                div.style.height = h * _elHeight + "px";
                f.div = div;
                var graph = new StackGraph(div, h);
                f.graph = graph;
                _div.appendChild(div);
              });
            }
          }
          function _update() {
            iterateKeys(_settings.plugins, function(j) {
              _settings.plugins[j].update();
            });
            iterateKeys(_perfCounters, function(j) {
              _perfCounters[j].draw();
            });
            if (_settings && _settings.fractions) {
              iterateKeys(_settings.fractions, function(j) {
                var f = _settings.fractions[parseInt(j, 10)];
                var v = [];
                var base = _perfCounters[f.base.toLowerCase()];
                if (base) {
                  base = base.value();
                  iterateKeys(_settings.fractions[j].steps, function(k) {
                    var s = _settings.fractions[j].steps[parseInt(k, 10)].toLowerCase();
                    var val = _perfCounters[s];
                    if (val) {
                      v.push(val.value() / base);
                    }
                  });
                }
                f.graph.draw(v);
              });
            }
          }
          _init();
          return function(id) {
            if (id)
              return _perf(id);
            return {
              element: _base,
              update: _update
            };
          };
        };
        if (typeof module3 === "object") {
          module3.exports = window.rStats;
        }
      }, {}], 133: [function(_dereq_, module3, exports3) {
        var Util = {};
        Util.base64 = function(mimeType, base64) {
          return "data:" + mimeType + ";base64," + base64;
        };
        Util.isMobile = function() {
          var check = false;
          (function(a) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
              check = true;
          })(navigator.userAgent || navigator.vendor || window.opera);
          return check;
        };
        Util.isIOS = function() {
          return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
        };
        Util.isIFrame = function() {
          try {
            return window.self !== window.top;
          } catch (e2) {
            return true;
          }
        };
        Util.appendQueryParameter = function(url, key, value) {
          var delimiter = url.indexOf("?") < 0 ? "?" : "&";
          url += delimiter + key + "=" + value;
          return url;
        };
        Util.getQueryParameter = function(name) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"), results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        };
        Util.isLandscapeMode = function() {
          return window.orientation == 90 || window.orientation == -90;
        };
        module3.exports = Util;
      }, {}], 134: [function(_dereq_, module3, exports3) {
        var Util = _dereq_("./util.js");
        function AndroidWakeLock() {
          var video = document.createElement("video");
          video.addEventListener("ended", function() {
            video.play();
          });
          this.request = function() {
            if (video.paused) {
              video.src = Util.base64("video/webm", "GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw==");
              video.play();
            }
          };
          this.release = function() {
            video.pause();
            video.src = "";
          };
        }
        function iOSWakeLock() {
          var timer = null;
          this.request = function() {
            if (!timer) {
              timer = setInterval(function() {
                window.location = window.location;
                setTimeout(window.stop, 0);
              }, 3e4);
            }
          };
          this.release = function() {
            if (timer) {
              clearInterval(timer);
              timer = null;
            }
          };
        }
        function getWakeLock() {
          var userAgent = navigator.userAgent || navigator.vendor || window.opera;
          if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
            return iOSWakeLock;
          } else {
            return AndroidWakeLock;
          }
        }
        module3.exports = getWakeLock();
      }, { "./util.js": 133 }] }, {}, [104])(104);
    });
  }
});
export default require_aframe_master();
/*! Bundled license information:

aframe/dist/aframe-master.js:
  (*! (C) WebReflection Mit Style License *)
*/
//# sourceMappingURL=aframe.js.map
